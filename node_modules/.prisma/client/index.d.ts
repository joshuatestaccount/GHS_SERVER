
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  userID: string
  email: string
  password: string
  role: Role
  createdAt: Date
  updatedAt: Date
  companyID: string
}

/**
 * Model Logs
 * 
 */
export type Logs = {
  logsID: string
  title: string
  modifiedBy: string
  createdAt: Date
}

/**
 * Model Notification
 * 
 */
export type Notification = {
  notificationID: string
  title: string
  notificationStatus: notificationStatus
  createdAt: Date
  userID: string | null
}

/**
 * Model Profile
 * 
 */
export type Profile = {
  profileID: string
  firstname: string
  lastname: string
  phone: string
  birthday: Date | null
  applicantID: string | null
  userID: string | null
}

/**
 * Model Address
 * 
 */
export type Address = {
  addressID: string
  city: string
  province: string
  zipcode: string
  street: string
  profileID: string | null
  companyDetailsID: string | null
}

/**
 * Model Company
 * 
 */
export type Company = {
  companyID: string
  companyName: string
  createdAt: Date | null
}

/**
 * Model CompanyDetails
 * 
 */
export type CompanyDetails = {
  companyDetailsID: string
  description: string
  mission: string | null
  vision: string | null
  companyID: string | null
}

/**
 * Model Comment
 * 
 */
export type Comment = {
  commentID: string
  message: string
  notes: string
  createdAt: Date
  updatedAt: Date
  endorsementID: string | null
  userID: string | null
}

/**
 * Model Endorsement
 * 
 */
export type Endorsement = {
  endorsementID: string
  Status: string
  createdAt: Date
  updatedAt: Date
  userID: string | null
  companyID: string | null
}

/**
 * Model Endorse
 * 
 */
export type Endorse = {
  endorseID: string
  endorseStatus: endorseStatus
  userID: string
  createdAt: Date
  companyID: string | null
}

/**
 * Model Feedback
 * 
 */
export type Feedback = {
  feedbackID: string
  feedback: string
  createdAt: Date
  endorseID: string | null
  userID: string | null
  applicantID: string | null
}

/**
 * Model Interviewer
 * 
 */
export type Interviewer = {
  interviewerID: string
  createdAt: Date
  userID: string
}

/**
 * Model Applicant
 * 
 */
export type Applicant = {
  applicantID: string
  id: string
  email: string
  createdAt: Date
  updatedAt: Date
  status: applicantStatus
  jobPostID: string
  interviewerID: string | null
  endorsementID: string | null
  notificaitonID: string | null
}

/**
 * Model UploadFile
 * 
 */
export type UploadFile = {
  uploadFileID: string
  file: string
  video: string
  createdAt: Date
  applicantID: string | null
}

/**
 * Model JobPost
 * 
 */
export type JobPost = {
  jobPostID: string
  title: string
  description: string
  qualification: string
  responsibilities: string
  status: JobStatus
  createdAt: Date
  updatedAt: Date
  companyID: string
  notificationID: string | null
  userID: string
}

/**
 * Model JobDetails
 * 
 */
export type JobDetails = {
  jobDetailsID: string
  location: string[]
  jobType: string[]
  workType: string[]
  category: string
  salary: string
  jobPostID: string | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const JobStatus: {
  inProgress: 'inProgress',
  approved: 'approved',
  rejected: 'rejected'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const Role: {
  administrator: 'administrator',
  recruiter: 'recruiter',
  moderator: 'moderator',
  manager: 'manager',
  employer: 'employer'
};

export type Role = (typeof Role)[keyof typeof Role]


export const applicantStatus: {
  waiting: 'waiting',
  approved: 'approved',
  rejected: 'rejected'
};

export type applicantStatus = (typeof applicantStatus)[keyof typeof applicantStatus]


export const endorseStatus: {
  waiting: 'waiting',
  rejected: 'rejected',
  approved: 'approved'
};

export type endorseStatus = (typeof endorseStatus)[keyof typeof endorseStatus]


export const notificationStatus: {
  read: 'read',
  unread: 'unread'
};

export type notificationStatus = (typeof notificationStatus)[keyof typeof notificationStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.logs`: Exposes CRUD operations for the **Logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.logs.findMany()
    * ```
    */
  get logs(): Prisma.LogsDelegate<GlobalReject>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<GlobalReject>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<GlobalReject>;

  /**
   * `prisma.companyDetails`: Exposes CRUD operations for the **CompanyDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyDetails
    * const companyDetails = await prisma.companyDetails.findMany()
    * ```
    */
  get companyDetails(): Prisma.CompanyDetailsDelegate<GlobalReject>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<GlobalReject>;

  /**
   * `prisma.endorsement`: Exposes CRUD operations for the **Endorsement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Endorsements
    * const endorsements = await prisma.endorsement.findMany()
    * ```
    */
  get endorsement(): Prisma.EndorsementDelegate<GlobalReject>;

  /**
   * `prisma.endorse`: Exposes CRUD operations for the **Endorse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Endorses
    * const endorses = await prisma.endorse.findMany()
    * ```
    */
  get endorse(): Prisma.EndorseDelegate<GlobalReject>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<GlobalReject>;

  /**
   * `prisma.interviewer`: Exposes CRUD operations for the **Interviewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interviewers
    * const interviewers = await prisma.interviewer.findMany()
    * ```
    */
  get interviewer(): Prisma.InterviewerDelegate<GlobalReject>;

  /**
   * `prisma.applicant`: Exposes CRUD operations for the **Applicant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicants
    * const applicants = await prisma.applicant.findMany()
    * ```
    */
  get applicant(): Prisma.ApplicantDelegate<GlobalReject>;

  /**
   * `prisma.uploadFile`: Exposes CRUD operations for the **UploadFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UploadFiles
    * const uploadFiles = await prisma.uploadFile.findMany()
    * ```
    */
  get uploadFile(): Prisma.UploadFileDelegate<GlobalReject>;

  /**
   * `prisma.jobPost`: Exposes CRUD operations for the **JobPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobPosts
    * const jobPosts = await prisma.jobPost.findMany()
    * ```
    */
  get jobPost(): Prisma.JobPostDelegate<GlobalReject>;

  /**
   * `prisma.jobDetails`: Exposes CRUD operations for the **JobDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobDetails
    * const jobDetails = await prisma.jobDetails.findMany()
    * ```
    */
  get jobDetails(): Prisma.JobDetailsDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.8.1
   * Query Engine version: d6e67a83f971b175a593ccc12e15c4a757f93ffe
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Logs: 'Logs',
    Notification: 'Notification',
    Profile: 'Profile',
    Address: 'Address',
    Company: 'Company',
    CompanyDetails: 'CompanyDetails',
    Comment: 'Comment',
    Endorsement: 'Endorsement',
    Endorse: 'Endorse',
    Feedback: 'Feedback',
    Interviewer: 'Interviewer',
    Applicant: 'Applicant',
    UploadFile: 'UploadFile',
    JobPost: 'JobPost',
    JobDetails: 'JobDetails'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    Endorse: number
    Endorsement: number
    interviewer: number
    JobPost: number
    Notification: number
    Logs: number
  }

  export type UserCountOutputTypeSelect = {
    Endorse?: boolean
    Endorsement?: boolean
    interviewer?: boolean
    JobPost?: boolean
    Notification?: boolean
    Logs?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type LogsCountOutputType
   */


  export type LogsCountOutputType = {
    User: number
  }

  export type LogsCountOutputTypeSelect = {
    User?: boolean
  }

  export type LogsCountOutputTypeGetPayload<S extends boolean | null | undefined | LogsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LogsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LogsCountOutputTypeArgs)
    ? LogsCountOutputType 
    : S extends { select: any } & (LogsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LogsCountOutputType ? LogsCountOutputType[P] : never
  } 
      : LogsCountOutputType




  // Custom InputTypes

  /**
   * LogsCountOutputType without action
   */
  export type LogsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LogsCountOutputType
     * 
    **/
    select?: LogsCountOutputTypeSelect | null
  }



  /**
   * Count Type CompanyCountOutputType
   */


  export type CompanyCountOutputType = {
    Endorse: number
    Endorsement: number
    jobPost: number
    User: number
  }

  export type CompanyCountOutputTypeSelect = {
    Endorse?: boolean
    Endorsement?: boolean
    jobPost?: boolean
    User?: boolean
  }

  export type CompanyCountOutputTypeGetPayload<S extends boolean | null | undefined | CompanyCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CompanyCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CompanyCountOutputTypeArgs)
    ? CompanyCountOutputType 
    : S extends { select: any } & (CompanyCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CompanyCountOutputType ? CompanyCountOutputType[P] : never
  } 
      : CompanyCountOutputType




  // Custom InputTypes

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     * 
    **/
    select?: CompanyCountOutputTypeSelect | null
  }



  /**
   * Count Type EndorsementCountOutputType
   */


  export type EndorsementCountOutputType = {
    Endorse: number
    Applicant: number
  }

  export type EndorsementCountOutputTypeSelect = {
    Endorse?: boolean
    Applicant?: boolean
  }

  export type EndorsementCountOutputTypeGetPayload<S extends boolean | null | undefined | EndorsementCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EndorsementCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (EndorsementCountOutputTypeArgs)
    ? EndorsementCountOutputType 
    : S extends { select: any } & (EndorsementCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EndorsementCountOutputType ? EndorsementCountOutputType[P] : never
  } 
      : EndorsementCountOutputType




  // Custom InputTypes

  /**
   * EndorsementCountOutputType without action
   */
  export type EndorsementCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EndorsementCountOutputType
     * 
    **/
    select?: EndorsementCountOutputTypeSelect | null
  }



  /**
   * Count Type EndorseCountOutputType
   */


  export type EndorseCountOutputType = {
    feedback: number
    Endorsement: number
  }

  export type EndorseCountOutputTypeSelect = {
    feedback?: boolean
    Endorsement?: boolean
  }

  export type EndorseCountOutputTypeGetPayload<S extends boolean | null | undefined | EndorseCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EndorseCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (EndorseCountOutputTypeArgs)
    ? EndorseCountOutputType 
    : S extends { select: any } & (EndorseCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EndorseCountOutputType ? EndorseCountOutputType[P] : never
  } 
      : EndorseCountOutputType




  // Custom InputTypes

  /**
   * EndorseCountOutputType without action
   */
  export type EndorseCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EndorseCountOutputType
     * 
    **/
    select?: EndorseCountOutputTypeSelect | null
  }



  /**
   * Count Type ApplicantCountOutputType
   */


  export type ApplicantCountOutputType = {
    Feedback: number
  }

  export type ApplicantCountOutputTypeSelect = {
    Feedback?: boolean
  }

  export type ApplicantCountOutputTypeGetPayload<S extends boolean | null | undefined | ApplicantCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ApplicantCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ApplicantCountOutputTypeArgs)
    ? ApplicantCountOutputType 
    : S extends { select: any } & (ApplicantCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ApplicantCountOutputType ? ApplicantCountOutputType[P] : never
  } 
      : ApplicantCountOutputType




  // Custom InputTypes

  /**
   * ApplicantCountOutputType without action
   */
  export type ApplicantCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ApplicantCountOutputType
     * 
    **/
    select?: ApplicantCountOutputTypeSelect | null
  }



  /**
   * Count Type JobPostCountOutputType
   */


  export type JobPostCountOutputType = {
    Applicants: number
  }

  export type JobPostCountOutputTypeSelect = {
    Applicants?: boolean
  }

  export type JobPostCountOutputTypeGetPayload<S extends boolean | null | undefined | JobPostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? JobPostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (JobPostCountOutputTypeArgs)
    ? JobPostCountOutputType 
    : S extends { select: any } & (JobPostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof JobPostCountOutputType ? JobPostCountOutputType[P] : never
  } 
      : JobPostCountOutputType




  // Custom InputTypes

  /**
   * JobPostCountOutputType without action
   */
  export type JobPostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the JobPostCountOutputType
     * 
    **/
    select?: JobPostCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    userID: string | null
    email: string | null
    password: string | null
    role: Role | null
    createdAt: Date | null
    updatedAt: Date | null
    companyID: string | null
  }

  export type UserMaxAggregateOutputType = {
    userID: string | null
    email: string | null
    password: string | null
    role: Role | null
    createdAt: Date | null
    updatedAt: Date | null
    companyID: string | null
  }

  export type UserCountAggregateOutputType = {
    userID: number
    email: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    companyID: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    userID?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    companyID?: true
  }

  export type UserMaxAggregateInputType = {
    userID?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    companyID?: true
  }

  export type UserCountAggregateInputType = {
    userID?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    companyID?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    userID: string
    email: string
    password: string
    role: Role
    createdAt: Date
    updatedAt: Date
    companyID: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    userID?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyID?: boolean
    Company?: boolean | CompanyArgs
    Comment?: boolean | CommentArgs
    Endorse?: boolean | User$EndorseArgs
    Endorsement?: boolean | User$EndorsementArgs
    Feedback?: boolean | FeedbackArgs
    interviewer?: boolean | User$interviewerArgs
    JobPost?: boolean | User$JobPostArgs
    Notification?: boolean | User$NotificationArgs
    Profile?: boolean | ProfileArgs
    Logs?: boolean | User$LogsArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    Company?: boolean | CompanyArgs
    Comment?: boolean | CommentArgs
    Endorse?: boolean | User$EndorseArgs
    Endorsement?: boolean | User$EndorsementArgs
    Feedback?: boolean | FeedbackArgs
    interviewer?: boolean | User$interviewerArgs
    JobPost?: boolean | User$JobPostArgs
    Notification?: boolean | User$NotificationArgs
    Profile?: boolean | ProfileArgs
    Logs?: boolean | User$LogsArgs
    _count?: boolean | UserCountOutputTypeArgs
  } 

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Company' ? CompanyGetPayload<S['include'][P]> :
        P extends 'Comment' ? CommentGetPayload<S['include'][P]> | null :
        P extends 'Endorse' ? Array < EndorseGetPayload<S['include'][P]>>  :
        P extends 'Endorsement' ? Array < EndorsementGetPayload<S['include'][P]>>  :
        P extends 'Feedback' ? FeedbackGetPayload<S['include'][P]> | null :
        P extends 'interviewer' ? Array < InterviewerGetPayload<S['include'][P]>>  :
        P extends 'JobPost' ? Array < JobPostGetPayload<S['include'][P]>>  :
        P extends 'Notification' ? Array < NotificationGetPayload<S['include'][P]>>  :
        P extends 'Profile' ? ProfileGetPayload<S['include'][P]> | null :
        P extends 'Logs' ? Array < LogsGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Company' ? CompanyGetPayload<S['select'][P]> :
        P extends 'Comment' ? CommentGetPayload<S['select'][P]> | null :
        P extends 'Endorse' ? Array < EndorseGetPayload<S['select'][P]>>  :
        P extends 'Endorsement' ? Array < EndorsementGetPayload<S['select'][P]>>  :
        P extends 'Feedback' ? FeedbackGetPayload<S['select'][P]> | null :
        P extends 'interviewer' ? Array < InterviewerGetPayload<S['select'][P]>>  :
        P extends 'JobPost' ? Array < JobPostGetPayload<S['select'][P]>>  :
        P extends 'Notification' ? Array < NotificationGetPayload<S['select'][P]>>  :
        P extends 'Profile' ? ProfileGetPayload<S['select'][P]> | null :
        P extends 'Logs' ? Array < LogsGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `userID`
     * const userWithUserIDOnly = await prisma.user.findMany({ select: { userID: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company<T extends CompanyArgs= {}>(args?: Subset<T, CompanyArgs>): Prisma__CompanyClient<CompanyGetPayload<T> | Null>;

    Comment<T extends CommentArgs= {}>(args?: Subset<T, CommentArgs>): Prisma__CommentClient<CommentGetPayload<T> | Null>;

    Endorse<T extends User$EndorseArgs= {}>(args?: Subset<T, User$EndorseArgs>): PrismaPromise<Array<EndorseGetPayload<T>>| Null>;

    Endorsement<T extends User$EndorsementArgs= {}>(args?: Subset<T, User$EndorsementArgs>): PrismaPromise<Array<EndorsementGetPayload<T>>| Null>;

    Feedback<T extends FeedbackArgs= {}>(args?: Subset<T, FeedbackArgs>): Prisma__FeedbackClient<FeedbackGetPayload<T> | Null>;

    interviewer<T extends User$interviewerArgs= {}>(args?: Subset<T, User$interviewerArgs>): PrismaPromise<Array<InterviewerGetPayload<T>>| Null>;

    JobPost<T extends User$JobPostArgs= {}>(args?: Subset<T, User$JobPostArgs>): PrismaPromise<Array<JobPostGetPayload<T>>| Null>;

    Notification<T extends User$NotificationArgs= {}>(args?: Subset<T, User$NotificationArgs>): PrismaPromise<Array<NotificationGetPayload<T>>| Null>;

    Profile<T extends ProfileArgs= {}>(args?: Subset<T, ProfileArgs>): Prisma__ProfileClient<ProfileGetPayload<T> | Null>;

    Logs<T extends User$LogsArgs= {}>(args?: Subset<T, User$LogsArgs>): PrismaPromise<Array<LogsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User.Endorse
   */
  export type User$EndorseArgs = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    where?: EndorseWhereInput
    orderBy?: Enumerable<EndorseOrderByWithRelationAndSearchRelevanceInput>
    cursor?: EndorseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EndorseScalarFieldEnum>
  }


  /**
   * User.Endorsement
   */
  export type User$EndorsementArgs = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    where?: EndorsementWhereInput
    orderBy?: Enumerable<EndorsementOrderByWithRelationAndSearchRelevanceInput>
    cursor?: EndorsementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EndorsementScalarFieldEnum>
  }


  /**
   * User.interviewer
   */
  export type User$interviewerArgs = {
    /**
     * Select specific fields to fetch from the Interviewer
     * 
    **/
    select?: InterviewerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InterviewerInclude | null
    where?: InterviewerWhereInput
    orderBy?: Enumerable<InterviewerOrderByWithRelationAndSearchRelevanceInput>
    cursor?: InterviewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InterviewerScalarFieldEnum>
  }


  /**
   * User.JobPost
   */
  export type User$JobPostArgs = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
    where?: JobPostWhereInput
    orderBy?: Enumerable<JobPostOrderByWithRelationAndSearchRelevanceInput>
    cursor?: JobPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<JobPostScalarFieldEnum>
  }


  /**
   * User.Notification
   */
  export type User$NotificationArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithRelationAndSearchRelevanceInput>
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * User.Logs
   */
  export type User$LogsArgs = {
    /**
     * Select specific fields to fetch from the Logs
     * 
    **/
    select?: LogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogsInclude | null
    where?: LogsWhereInput
    orderBy?: Enumerable<LogsOrderByWithRelationAndSearchRelevanceInput>
    cursor?: LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LogsScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Logs
   */


  export type AggregateLogs = {
    _count: LogsCountAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  export type LogsMinAggregateOutputType = {
    logsID: string | null
    title: string | null
    modifiedBy: string | null
    createdAt: Date | null
  }

  export type LogsMaxAggregateOutputType = {
    logsID: string | null
    title: string | null
    modifiedBy: string | null
    createdAt: Date | null
  }

  export type LogsCountAggregateOutputType = {
    logsID: number
    title: number
    modifiedBy: number
    createdAt: number
    _all: number
  }


  export type LogsMinAggregateInputType = {
    logsID?: true
    title?: true
    modifiedBy?: true
    createdAt?: true
  }

  export type LogsMaxAggregateInputType = {
    logsID?: true
    title?: true
    modifiedBy?: true
    createdAt?: true
  }

  export type LogsCountAggregateInputType = {
    logsID?: true
    title?: true
    modifiedBy?: true
    createdAt?: true
    _all?: true
  }

  export type LogsAggregateArgs = {
    /**
     * Filter which Logs to aggregate.
     * 
    **/
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     * 
    **/
    orderBy?: Enumerable<LogsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogsMaxAggregateInputType
  }

  export type GetLogsAggregateType<T extends LogsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs[P]>
      : GetScalarType<T[P], AggregateLogs[P]>
  }




  export type LogsGroupByArgs = {
    where?: LogsWhereInput
    orderBy?: Enumerable<LogsOrderByWithAggregationInput>
    by: Array<LogsScalarFieldEnum>
    having?: LogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogsCountAggregateInputType | true
    _min?: LogsMinAggregateInputType
    _max?: LogsMaxAggregateInputType
  }


  export type LogsGroupByOutputType = {
    logsID: string
    title: string
    modifiedBy: string
    createdAt: Date
    _count: LogsCountAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  type GetLogsGroupByPayload<T extends LogsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogsGroupByOutputType[P]>
            : GetScalarType<T[P], LogsGroupByOutputType[P]>
        }
      >
    >


  export type LogsSelect = {
    logsID?: boolean
    title?: boolean
    modifiedBy?: boolean
    createdAt?: boolean
    User?: boolean | Logs$UserArgs
    _count?: boolean | LogsCountOutputTypeArgs
  }


  export type LogsInclude = {
    User?: boolean | Logs$UserArgs
    _count?: boolean | LogsCountOutputTypeArgs
  } 

  export type LogsGetPayload<S extends boolean | null | undefined | LogsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Logs :
    S extends undefined ? never :
    S extends { include: any } & (LogsArgs | LogsFindManyArgs)
    ? Logs  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count' ? LogsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (LogsArgs | LogsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count' ? LogsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Logs ? Logs[P] : never
  } 
      : Logs


  type LogsCountArgs = Merge<
    Omit<LogsFindManyArgs, 'select' | 'include'> & {
      select?: LogsCountAggregateInputType | true
    }
  >

  export interface LogsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Logs that matches the filter.
     * @param {LogsFindUniqueArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LogsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Logs'> extends True ? Prisma__LogsClient<LogsGetPayload<T>> : Prisma__LogsClient<LogsGetPayload<T> | null, null>

    /**
     * Find one Logs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LogsFindUniqueOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LogsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, LogsFindUniqueOrThrowArgs>
    ): Prisma__LogsClient<LogsGetPayload<T>>

    /**
     * Find the first Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LogsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Logs'> extends True ? Prisma__LogsClient<LogsGetPayload<T>> : Prisma__LogsClient<LogsGetPayload<T> | null, null>

    /**
     * Find the first Logs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LogsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LogsFindFirstOrThrowArgs>
    ): Prisma__LogsClient<LogsGetPayload<T>>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.logs.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.logs.findMany({ take: 10 })
     * 
     * // Only select the `logsID`
     * const logsWithLogsIDOnly = await prisma.logs.findMany({ select: { logsID: true } })
     * 
    **/
    findMany<T extends LogsFindManyArgs>(
      args?: SelectSubset<T, LogsFindManyArgs>
    ): PrismaPromise<Array<LogsGetPayload<T>>>

    /**
     * Create a Logs.
     * @param {LogsCreateArgs} args - Arguments to create a Logs.
     * @example
     * // Create one Logs
     * const Logs = await prisma.logs.create({
     *   data: {
     *     // ... data to create a Logs
     *   }
     * })
     * 
    **/
    create<T extends LogsCreateArgs>(
      args: SelectSubset<T, LogsCreateArgs>
    ): Prisma__LogsClient<LogsGetPayload<T>>

    /**
     * Create many Logs.
     *     @param {LogsCreateManyArgs} args - Arguments to create many Logs.
     *     @example
     *     // Create many Logs
     *     const logs = await prisma.logs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LogsCreateManyArgs>(
      args?: SelectSubset<T, LogsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Logs.
     * @param {LogsDeleteArgs} args - Arguments to delete one Logs.
     * @example
     * // Delete one Logs
     * const Logs = await prisma.logs.delete({
     *   where: {
     *     // ... filter to delete one Logs
     *   }
     * })
     * 
    **/
    delete<T extends LogsDeleteArgs>(
      args: SelectSubset<T, LogsDeleteArgs>
    ): Prisma__LogsClient<LogsGetPayload<T>>

    /**
     * Update one Logs.
     * @param {LogsUpdateArgs} args - Arguments to update one Logs.
     * @example
     * // Update one Logs
     * const logs = await prisma.logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogsUpdateArgs>(
      args: SelectSubset<T, LogsUpdateArgs>
    ): Prisma__LogsClient<LogsGetPayload<T>>

    /**
     * Delete zero or more Logs.
     * @param {LogsDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogsDeleteManyArgs>(
      args?: SelectSubset<T, LogsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const logs = await prisma.logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogsUpdateManyArgs>(
      args: SelectSubset<T, LogsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Logs.
     * @param {LogsUpsertArgs} args - Arguments to update or create a Logs.
     * @example
     * // Update or create a Logs
     * const logs = await prisma.logs.upsert({
     *   create: {
     *     // ... data to create a Logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs we want to update
     *   }
     * })
    **/
    upsert<T extends LogsUpsertArgs>(
      args: SelectSubset<T, LogsUpsertArgs>
    ): Prisma__LogsClient<LogsGetPayload<T>>

    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.logs.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogsCountArgs>(
      args?: Subset<T, LogsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogsAggregateArgs>(args: Subset<T, LogsAggregateArgs>): PrismaPromise<GetLogsAggregateType<T>>

    /**
     * Group by Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogsGroupByArgs['orderBy'] }
        : { orderBy?: LogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LogsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends Logs$UserArgs= {}>(args?: Subset<T, Logs$UserArgs>): PrismaPromise<Array<UserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Logs base type for findUnique actions
   */
  export type LogsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Logs
     * 
    **/
    select?: LogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogsInclude | null
    /**
     * Filter, which Logs to fetch.
     * 
    **/
    where: LogsWhereUniqueInput
  }

  /**
   * Logs findUnique
   */
  export interface LogsFindUniqueArgs extends LogsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Logs findUniqueOrThrow
   */
  export type LogsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Logs
     * 
    **/
    select?: LogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogsInclude | null
    /**
     * Filter, which Logs to fetch.
     * 
    **/
    where: LogsWhereUniqueInput
  }


  /**
   * Logs base type for findFirst actions
   */
  export type LogsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Logs
     * 
    **/
    select?: LogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogsInclude | null
    /**
     * Filter, which Logs to fetch.
     * 
    **/
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     * 
    **/
    orderBy?: Enumerable<LogsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     * 
    **/
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     * 
    **/
    distinct?: Enumerable<LogsScalarFieldEnum>
  }

  /**
   * Logs findFirst
   */
  export interface LogsFindFirstArgs extends LogsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Logs findFirstOrThrow
   */
  export type LogsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Logs
     * 
    **/
    select?: LogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogsInclude | null
    /**
     * Filter, which Logs to fetch.
     * 
    **/
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     * 
    **/
    orderBy?: Enumerable<LogsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     * 
    **/
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     * 
    **/
    distinct?: Enumerable<LogsScalarFieldEnum>
  }


  /**
   * Logs findMany
   */
  export type LogsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Logs
     * 
    **/
    select?: LogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogsInclude | null
    /**
     * Filter, which Logs to fetch.
     * 
    **/
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     * 
    **/
    orderBy?: Enumerable<LogsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     * 
    **/
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LogsScalarFieldEnum>
  }


  /**
   * Logs create
   */
  export type LogsCreateArgs = {
    /**
     * Select specific fields to fetch from the Logs
     * 
    **/
    select?: LogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogsInclude | null
    /**
     * The data needed to create a Logs.
     * 
    **/
    data: XOR<LogsCreateInput, LogsUncheckedCreateInput>
  }


  /**
   * Logs createMany
   */
  export type LogsCreateManyArgs = {
    /**
     * The data used to create many Logs.
     * 
    **/
    data: Enumerable<LogsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Logs update
   */
  export type LogsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Logs
     * 
    **/
    select?: LogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogsInclude | null
    /**
     * The data needed to update a Logs.
     * 
    **/
    data: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
    /**
     * Choose, which Logs to update.
     * 
    **/
    where: LogsWhereUniqueInput
  }


  /**
   * Logs updateMany
   */
  export type LogsUpdateManyArgs = {
    /**
     * The data used to update Logs.
     * 
    **/
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     * 
    **/
    where?: LogsWhereInput
  }


  /**
   * Logs upsert
   */
  export type LogsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Logs
     * 
    **/
    select?: LogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogsInclude | null
    /**
     * The filter to search for the Logs to update in case it exists.
     * 
    **/
    where: LogsWhereUniqueInput
    /**
     * In case the Logs found by the `where` argument doesn't exist, create a new Logs with this data.
     * 
    **/
    create: XOR<LogsCreateInput, LogsUncheckedCreateInput>
    /**
     * In case the Logs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
  }


  /**
   * Logs delete
   */
  export type LogsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Logs
     * 
    **/
    select?: LogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogsInclude | null
    /**
     * Filter which Logs to delete.
     * 
    **/
    where: LogsWhereUniqueInput
  }


  /**
   * Logs deleteMany
   */
  export type LogsDeleteManyArgs = {
    /**
     * Filter which Logs to delete
     * 
    **/
    where?: LogsWhereInput
  }


  /**
   * Logs.User
   */
  export type Logs$UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Logs without action
   */
  export type LogsArgs = {
    /**
     * Select specific fields to fetch from the Logs
     * 
    **/
    select?: LogsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LogsInclude | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    notificationID: string | null
    title: string | null
    notificationStatus: notificationStatus | null
    createdAt: Date | null
    userID: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    notificationID: string | null
    title: string | null
    notificationStatus: notificationStatus | null
    createdAt: Date | null
    userID: string | null
  }

  export type NotificationCountAggregateOutputType = {
    notificationID: number
    title: number
    notificationStatus: number
    createdAt: number
    userID: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    notificationID?: true
    title?: true
    notificationStatus?: true
    createdAt?: true
    userID?: true
  }

  export type NotificationMaxAggregateInputType = {
    notificationID?: true
    title?: true
    notificationStatus?: true
    createdAt?: true
    userID?: true
  }

  export type NotificationCountAggregateInputType = {
    notificationID?: true
    title?: true
    notificationStatus?: true
    createdAt?: true
    userID?: true
    _all?: true
  }

  export type NotificationAggregateArgs = {
    /**
     * Filter which Notification to aggregate.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs = {
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithAggregationInput>
    by: Array<NotificationScalarFieldEnum>
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    notificationID: string
    title: string
    notificationStatus: notificationStatus
    createdAt: Date
    userID: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect = {
    notificationID?: boolean
    title?: boolean
    notificationStatus?: boolean
    createdAt?: boolean
    userID?: boolean
    User?: boolean | UserArgs
    JobPost?: boolean | JobPostArgs
    Applicant?: boolean | ApplicantArgs
  }


  export type NotificationInclude = {
    User?: boolean | UserArgs
    JobPost?: boolean | JobPostArgs
    Applicant?: boolean | ApplicantArgs
  } 

  export type NotificationGetPayload<S extends boolean | null | undefined | NotificationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Notification :
    S extends undefined ? never :
    S extends { include: any } & (NotificationArgs | NotificationFindManyArgs)
    ? Notification  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :
        P extends 'JobPost' ? JobPostGetPayload<S['include'][P]> | null :
        P extends 'Applicant' ? ApplicantGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (NotificationArgs | NotificationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :
        P extends 'JobPost' ? JobPostGetPayload<S['select'][P]> | null :
        P extends 'Applicant' ? ApplicantGetPayload<S['select'][P]> | null :  P extends keyof Notification ? Notification[P] : never
  } 
      : Notification


  type NotificationCountArgs = Merge<
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }
  >

  export interface NotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notification'> extends True ? Prisma__NotificationClient<NotificationGetPayload<T>> : Prisma__NotificationClient<NotificationGetPayload<T> | null, null>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notification'> extends True ? Prisma__NotificationClient<NotificationGetPayload<T>> : Prisma__NotificationClient<NotificationGetPayload<T> | null, null>

    /**
     * Find the first Notification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `notificationID`
     * const notificationWithNotificationIDOnly = await prisma.notification.findMany({ select: { notificationID: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs>
    ): PrismaPromise<Array<NotificationGetPayload<T>>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    JobPost<T extends JobPostArgs= {}>(args?: Subset<T, JobPostArgs>): Prisma__JobPostClient<JobPostGetPayload<T> | Null>;

    Applicant<T extends ApplicantArgs= {}>(args?: Subset<T, ApplicantArgs>): Prisma__ApplicantClient<ApplicantGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notification base type for findUnique actions
   */
  export type NotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUnique
   */
  export interface NotificationFindUniqueArgs extends NotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification base type for findFirst actions
   */
  export type NotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }

  /**
   * Notification findFirst
   */
  export interface NotificationFindFirstArgs extends NotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to create a Notification.
     * 
    **/
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs = {
    /**
     * The data used to create many Notifications.
     * 
    **/
    data: Enumerable<NotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to update a Notification.
     * 
    **/
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs = {
    /**
     * The data used to update Notifications.
     * 
    **/
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     * 
    **/
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The filter to search for the Notification to update in case it exists.
     * 
    **/
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     * 
    **/
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter which Notification to delete.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs = {
    /**
     * Filter which Notifications to delete
     * 
    **/
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
  }



  /**
   * Model Profile
   */


  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    profileID: string | null
    firstname: string | null
    lastname: string | null
    phone: string | null
    birthday: Date | null
    applicantID: string | null
    userID: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    profileID: string | null
    firstname: string | null
    lastname: string | null
    phone: string | null
    birthday: Date | null
    applicantID: string | null
    userID: string | null
  }

  export type ProfileCountAggregateOutputType = {
    profileID: number
    firstname: number
    lastname: number
    phone: number
    birthday: number
    applicantID: number
    userID: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    profileID?: true
    firstname?: true
    lastname?: true
    phone?: true
    birthday?: true
    applicantID?: true
    userID?: true
  }

  export type ProfileMaxAggregateInputType = {
    profileID?: true
    firstname?: true
    lastname?: true
    phone?: true
    birthday?: true
    applicantID?: true
    userID?: true
  }

  export type ProfileCountAggregateInputType = {
    profileID?: true
    firstname?: true
    lastname?: true
    phone?: true
    birthday?: true
    applicantID?: true
    userID?: true
    _all?: true
  }

  export type ProfileAggregateArgs = {
    /**
     * Filter which Profile to aggregate.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs = {
    where?: ProfileWhereInput
    orderBy?: Enumerable<ProfileOrderByWithAggregationInput>
    by: Array<ProfileScalarFieldEnum>
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }


  export type ProfileGroupByOutputType = {
    profileID: string
    firstname: string
    lastname: string
    phone: string
    birthday: Date | null
    applicantID: string | null
    userID: string | null
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect = {
    profileID?: boolean
    firstname?: boolean
    lastname?: boolean
    phone?: boolean
    birthday?: boolean
    applicantID?: boolean
    userID?: boolean
    Applicant?: boolean | ApplicantArgs
    User?: boolean | UserArgs
    Address?: boolean | AddressArgs
  }


  export type ProfileInclude = {
    Applicant?: boolean | ApplicantArgs
    User?: boolean | UserArgs
    Address?: boolean | AddressArgs
  } 

  export type ProfileGetPayload<S extends boolean | null | undefined | ProfileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Profile :
    S extends undefined ? never :
    S extends { include: any } & (ProfileArgs | ProfileFindManyArgs)
    ? Profile  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Applicant' ? ApplicantGetPayload<S['include'][P]> | null :
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :
        P extends 'Address' ? AddressGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (ProfileArgs | ProfileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Applicant' ? ApplicantGetPayload<S['select'][P]> | null :
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :
        P extends 'Address' ? AddressGetPayload<S['select'][P]> | null :  P extends keyof Profile ? Profile[P] : never
  } 
      : Profile


  type ProfileCountArgs = Merge<
    Omit<ProfileFindManyArgs, 'select' | 'include'> & {
      select?: ProfileCountAggregateInputType | true
    }
  >

  export interface ProfileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProfileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Profile'> extends True ? Prisma__ProfileClient<ProfileGetPayload<T>> : Prisma__ProfileClient<ProfileGetPayload<T> | null, null>

    /**
     * Find one Profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProfileFindUniqueOrThrowArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProfileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Profile'> extends True ? Prisma__ProfileClient<ProfileGetPayload<T>> : Prisma__ProfileClient<ProfileGetPayload<T> | null, null>

    /**
     * Find the first Profile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProfileFindFirstOrThrowArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `profileID`
     * const profileWithProfileIDOnly = await prisma.profile.findMany({ select: { profileID: true } })
     * 
    **/
    findMany<T extends ProfileFindManyArgs>(
      args?: SelectSubset<T, ProfileFindManyArgs>
    ): PrismaPromise<Array<ProfileGetPayload<T>>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends ProfileCreateArgs>(
      args: SelectSubset<T, ProfileCreateArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Create many Profiles.
     *     @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfileCreateManyArgs>(
      args?: SelectSubset<T, ProfileCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends ProfileDeleteArgs>(
      args: SelectSubset<T, ProfileDeleteArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfileUpdateArgs>(
      args: SelectSubset<T, ProfileUpdateArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfileDeleteManyArgs>(
      args?: SelectSubset<T, ProfileDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfileUpdateManyArgs>(
      args: SelectSubset<T, ProfileUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends ProfileUpsertArgs>(
      args: SelectSubset<T, ProfileUpsertArgs>
    ): Prisma__ProfileClient<ProfileGetPayload<T>>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProfileClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Applicant<T extends ApplicantArgs= {}>(args?: Subset<T, ApplicantArgs>): Prisma__ApplicantClient<ApplicantGetPayload<T> | Null>;

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    Address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Profile base type for findUnique actions
   */
  export type ProfileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUnique
   */
  export interface ProfileFindUniqueArgs extends ProfileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile base type for findFirst actions
   */
  export type ProfileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     * 
    **/
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }

  /**
   * Profile findFirst
   */
  export interface ProfileFindFirstArgs extends ProfileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profile to fetch.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     * 
    **/
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter, which Profiles to fetch.
     * 
    **/
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<ProfileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     * 
    **/
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * Profile create
   */
  export type ProfileCreateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The data needed to create a Profile.
     * 
    **/
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }


  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs = {
    /**
     * The data used to create many Profiles.
     * 
    **/
    data: Enumerable<ProfileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Profile update
   */
  export type ProfileUpdateArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The data needed to update a Profile.
     * 
    **/
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs = {
    /**
     * The data used to update Profiles.
     * 
    **/
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     * 
    **/
    where?: ProfileWhereInput
  }


  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * The filter to search for the Profile to update in case it exists.
     * 
    **/
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     * 
    **/
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }


  /**
   * Profile delete
   */
  export type ProfileDeleteArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
    /**
     * Filter which Profile to delete.
     * 
    **/
    where: ProfileWhereUniqueInput
  }


  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs = {
    /**
     * Filter which Profiles to delete
     * 
    **/
    where?: ProfileWhereInput
  }


  /**
   * Profile without action
   */
  export type ProfileArgs = {
    /**
     * Select specific fields to fetch from the Profile
     * 
    **/
    select?: ProfileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProfileInclude | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    addressID: string | null
    city: string | null
    province: string | null
    zipcode: string | null
    street: string | null
    profileID: string | null
    companyDetailsID: string | null
  }

  export type AddressMaxAggregateOutputType = {
    addressID: string | null
    city: string | null
    province: string | null
    zipcode: string | null
    street: string | null
    profileID: string | null
    companyDetailsID: string | null
  }

  export type AddressCountAggregateOutputType = {
    addressID: number
    city: number
    province: number
    zipcode: number
    street: number
    profileID: number
    companyDetailsID: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    addressID?: true
    city?: true
    province?: true
    zipcode?: true
    street?: true
    profileID?: true
    companyDetailsID?: true
  }

  export type AddressMaxAggregateInputType = {
    addressID?: true
    city?: true
    province?: true
    zipcode?: true
    street?: true
    profileID?: true
    companyDetailsID?: true
  }

  export type AddressCountAggregateInputType = {
    addressID?: true
    city?: true
    province?: true
    zipcode?: true
    street?: true
    profileID?: true
    companyDetailsID?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithAggregationInput>
    by: Array<AddressScalarFieldEnum>
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    addressID: string
    city: string
    province: string
    zipcode: string
    street: string
    profileID: string | null
    companyDetailsID: string | null
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect = {
    addressID?: boolean
    city?: boolean
    province?: boolean
    zipcode?: boolean
    street?: boolean
    profileID?: boolean
    companyDetailsID?: boolean
    Company_Details?: boolean | CompanyDetailsArgs
    Profile?: boolean | ProfileArgs
  }


  export type AddressInclude = {
    Company_Details?: boolean | CompanyDetailsArgs
    Profile?: boolean | ProfileArgs
  } 

  export type AddressGetPayload<S extends boolean | null | undefined | AddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Address :
    S extends undefined ? never :
    S extends { include: any } & (AddressArgs | AddressFindManyArgs)
    ? Address  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Company_Details' ? CompanyDetailsGetPayload<S['include'][P]> | null :
        P extends 'Profile' ? ProfileGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (AddressArgs | AddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Company_Details' ? CompanyDetailsGetPayload<S['select'][P]> | null :
        P extends 'Profile' ? ProfileGetPayload<S['select'][P]> | null :  P extends keyof Address ? Address[P] : never
  } 
      : Address


  type AddressCountArgs = Merge<
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }
  >

  export interface AddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? Prisma__AddressClient<AddressGetPayload<T>> : Prisma__AddressClient<AddressGetPayload<T> | null, null>

    /**
     * Find one Address that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AddressFindUniqueOrThrowArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? Prisma__AddressClient<AddressGetPayload<T>> : Prisma__AddressClient<AddressGetPayload<T> | null, null>

    /**
     * Find the first Address that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `addressID`
     * const addressWithAddressIDOnly = await prisma.address.findMany({ select: { addressID: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): PrismaPromise<Array<AddressGetPayload<T>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company_Details<T extends CompanyDetailsArgs= {}>(args?: Subset<T, CompanyDetailsArgs>): Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T> | Null>;

    Profile<T extends ProfileArgs= {}>(args?: Subset<T, ProfileArgs>): Prisma__ProfileClient<ProfileGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Address base type for findUnique actions
   */
  export type AddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUnique
   */
  export interface AddressFindUniqueArgs extends AddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address base type for findFirst actions
   */
  export type AddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     * 
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }

  /**
   * Address findFirst
   */
  export interface AddressFindFirstArgs extends AddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     * 
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
     * 
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     * 
    **/
    orderBy?: Enumerable<AddressOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     * 
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
     * 
    **/
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    /**
     * The data used to create many Addresses.
     * 
    **/
    data: Enumerable<AddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
     * 
    **/
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    /**
     * The data used to update Addresses.
     * 
    **/
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
     * 
    **/
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     * 
    **/
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
     * 
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    /**
     * Filter which Addresses to delete
     * 
    **/
    where?: AddressWhereInput
  }


  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     * 
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AddressInclude | null
  }



  /**
   * Model Company
   */


  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    companyID: string | null
    companyName: string | null
    createdAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    companyID: string | null
    companyName: string | null
    createdAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    companyID: number
    companyName: number
    createdAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    companyID?: true
    companyName?: true
    createdAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    companyID?: true
    companyName?: true
    createdAt?: true
  }

  export type CompanyCountAggregateInputType = {
    companyID?: true
    companyName?: true
    createdAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs = {
    /**
     * Filter which Company to aggregate.
     * 
    **/
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     * 
    **/
    orderBy?: Enumerable<CompanyOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs = {
    where?: CompanyWhereInput
    orderBy?: Enumerable<CompanyOrderByWithAggregationInput>
    by: Array<CompanyScalarFieldEnum>
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }


  export type CompanyGroupByOutputType = {
    companyID: string
    companyName: string
    createdAt: Date | null
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect = {
    companyID?: boolean
    companyName?: boolean
    details?: boolean | CompanyDetailsArgs
    createdAt?: boolean
    Endorse?: boolean | Company$EndorseArgs
    Endorsement?: boolean | Company$EndorsementArgs
    jobPost?: boolean | Company$jobPostArgs
    User?: boolean | Company$UserArgs
    _count?: boolean | CompanyCountOutputTypeArgs
  }


  export type CompanyInclude = {
    details?: boolean | CompanyDetailsArgs
    Endorse?: boolean | Company$EndorseArgs
    Endorsement?: boolean | Company$EndorsementArgs
    jobPost?: boolean | Company$jobPostArgs
    User?: boolean | Company$UserArgs
    _count?: boolean | CompanyCountOutputTypeArgs
  } 

  export type CompanyGetPayload<S extends boolean | null | undefined | CompanyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Company :
    S extends undefined ? never :
    S extends { include: any } & (CompanyArgs | CompanyFindManyArgs)
    ? Company  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'details' ? CompanyDetailsGetPayload<S['include'][P]> | null :
        P extends 'Endorse' ? Array < EndorseGetPayload<S['include'][P]>>  :
        P extends 'Endorsement' ? Array < EndorsementGetPayload<S['include'][P]>>  :
        P extends 'jobPost' ? Array < JobPostGetPayload<S['include'][P]>>  :
        P extends 'User' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count' ? CompanyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CompanyArgs | CompanyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'details' ? CompanyDetailsGetPayload<S['select'][P]> | null :
        P extends 'Endorse' ? Array < EndorseGetPayload<S['select'][P]>>  :
        P extends 'Endorsement' ? Array < EndorsementGetPayload<S['select'][P]>>  :
        P extends 'jobPost' ? Array < JobPostGetPayload<S['select'][P]>>  :
        P extends 'User' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count' ? CompanyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Company ? Company[P] : never
  } 
      : Company


  type CompanyCountArgs = Merge<
    Omit<CompanyFindManyArgs, 'select' | 'include'> & {
      select?: CompanyCountAggregateInputType | true
    }
  >

  export interface CompanyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CompanyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Company'> extends True ? Prisma__CompanyClient<CompanyGetPayload<T>> : Prisma__CompanyClient<CompanyGetPayload<T> | null, null>

    /**
     * Find one Company that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CompanyFindUniqueOrThrowArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CompanyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Company'> extends True ? Prisma__CompanyClient<CompanyGetPayload<T>> : Prisma__CompanyClient<CompanyGetPayload<T> | null, null>

    /**
     * Find the first Company that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CompanyFindFirstOrThrowArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `companyID`
     * const companyWithCompanyIDOnly = await prisma.company.findMany({ select: { companyID: true } })
     * 
    **/
    findMany<T extends CompanyFindManyArgs>(
      args?: SelectSubset<T, CompanyFindManyArgs>
    ): PrismaPromise<Array<CompanyGetPayload<T>>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends CompanyCreateArgs>(
      args: SelectSubset<T, CompanyCreateArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Create many Companies.
     *     @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     *     @example
     *     // Create many Companies
     *     const company = await prisma.company.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CompanyCreateManyArgs>(
      args?: SelectSubset<T, CompanyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends CompanyDeleteArgs>(
      args: SelectSubset<T, CompanyDeleteArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyUpdateArgs>(
      args: SelectSubset<T, CompanyUpdateArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyDeleteManyArgs>(
      args?: SelectSubset<T, CompanyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyUpdateManyArgs>(
      args: SelectSubset<T, CompanyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUpsertArgs>(
      args: SelectSubset<T, CompanyUpsertArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CompanyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    details<T extends CompanyDetailsArgs= {}>(args?: Subset<T, CompanyDetailsArgs>): Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T> | Null>;

    Endorse<T extends Company$EndorseArgs= {}>(args?: Subset<T, Company$EndorseArgs>): PrismaPromise<Array<EndorseGetPayload<T>>| Null>;

    Endorsement<T extends Company$EndorsementArgs= {}>(args?: Subset<T, Company$EndorsementArgs>): PrismaPromise<Array<EndorsementGetPayload<T>>| Null>;

    jobPost<T extends Company$jobPostArgs= {}>(args?: Subset<T, Company$jobPostArgs>): PrismaPromise<Array<JobPostGetPayload<T>>| Null>;

    User<T extends Company$UserArgs= {}>(args?: Subset<T, Company$UserArgs>): PrismaPromise<Array<UserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Company base type for findUnique actions
   */
  export type CompanyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * Filter, which Company to fetch.
     * 
    **/
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUnique
   */
  export interface CompanyFindUniqueArgs extends CompanyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * Filter, which Company to fetch.
     * 
    **/
    where: CompanyWhereUniqueInput
  }


  /**
   * Company base type for findFirst actions
   */
  export type CompanyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * Filter, which Company to fetch.
     * 
    **/
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     * 
    **/
    orderBy?: Enumerable<CompanyOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     * 
    **/
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     * 
    **/
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }

  /**
   * Company findFirst
   */
  export interface CompanyFindFirstArgs extends CompanyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * Filter, which Company to fetch.
     * 
    **/
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     * 
    **/
    orderBy?: Enumerable<CompanyOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     * 
    **/
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     * 
    **/
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * Company findMany
   */
  export type CompanyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * Filter, which Companies to fetch.
     * 
    **/
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     * 
    **/
    orderBy?: Enumerable<CompanyOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     * 
    **/
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * Company create
   */
  export type CompanyCreateArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * The data needed to create a Company.
     * 
    **/
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }


  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs = {
    /**
     * The data used to create many Companies.
     * 
    **/
    data: Enumerable<CompanyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Company update
   */
  export type CompanyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * The data needed to update a Company.
     * 
    **/
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     * 
    **/
    where: CompanyWhereUniqueInput
  }


  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs = {
    /**
     * The data used to update Companies.
     * 
    **/
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     * 
    **/
    where?: CompanyWhereInput
  }


  /**
   * Company upsert
   */
  export type CompanyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * The filter to search for the Company to update in case it exists.
     * 
    **/
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     * 
    **/
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }


  /**
   * Company delete
   */
  export type CompanyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
    /**
     * Filter which Company to delete.
     * 
    **/
    where: CompanyWhereUniqueInput
  }


  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs = {
    /**
     * Filter which Companies to delete
     * 
    **/
    where?: CompanyWhereInput
  }


  /**
   * Company.Endorse
   */
  export type Company$EndorseArgs = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    where?: EndorseWhereInput
    orderBy?: Enumerable<EndorseOrderByWithRelationAndSearchRelevanceInput>
    cursor?: EndorseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EndorseScalarFieldEnum>
  }


  /**
   * Company.Endorsement
   */
  export type Company$EndorsementArgs = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    where?: EndorsementWhereInput
    orderBy?: Enumerable<EndorsementOrderByWithRelationAndSearchRelevanceInput>
    cursor?: EndorsementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EndorsementScalarFieldEnum>
  }


  /**
   * Company.jobPost
   */
  export type Company$jobPostArgs = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
    where?: JobPostWhereInput
    orderBy?: Enumerable<JobPostOrderByWithRelationAndSearchRelevanceInput>
    cursor?: JobPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<JobPostScalarFieldEnum>
  }


  /**
   * Company.User
   */
  export type Company$UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationAndSearchRelevanceInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Company without action
   */
  export type CompanyArgs = {
    /**
     * Select specific fields to fetch from the Company
     * 
    **/
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyInclude | null
  }



  /**
   * Model CompanyDetails
   */


  export type AggregateCompanyDetails = {
    _count: CompanyDetailsCountAggregateOutputType | null
    _min: CompanyDetailsMinAggregateOutputType | null
    _max: CompanyDetailsMaxAggregateOutputType | null
  }

  export type CompanyDetailsMinAggregateOutputType = {
    companyDetailsID: string | null
    description: string | null
    mission: string | null
    vision: string | null
    companyID: string | null
  }

  export type CompanyDetailsMaxAggregateOutputType = {
    companyDetailsID: string | null
    description: string | null
    mission: string | null
    vision: string | null
    companyID: string | null
  }

  export type CompanyDetailsCountAggregateOutputType = {
    companyDetailsID: number
    description: number
    mission: number
    vision: number
    companyID: number
    _all: number
  }


  export type CompanyDetailsMinAggregateInputType = {
    companyDetailsID?: true
    description?: true
    mission?: true
    vision?: true
    companyID?: true
  }

  export type CompanyDetailsMaxAggregateInputType = {
    companyDetailsID?: true
    description?: true
    mission?: true
    vision?: true
    companyID?: true
  }

  export type CompanyDetailsCountAggregateInputType = {
    companyDetailsID?: true
    description?: true
    mission?: true
    vision?: true
    companyID?: true
    _all?: true
  }

  export type CompanyDetailsAggregateArgs = {
    /**
     * Filter which CompanyDetails to aggregate.
     * 
    **/
    where?: CompanyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<CompanyDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CompanyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyDetails
    **/
    _count?: true | CompanyDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyDetailsMaxAggregateInputType
  }

  export type GetCompanyDetailsAggregateType<T extends CompanyDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyDetails[P]>
      : GetScalarType<T[P], AggregateCompanyDetails[P]>
  }




  export type CompanyDetailsGroupByArgs = {
    where?: CompanyDetailsWhereInput
    orderBy?: Enumerable<CompanyDetailsOrderByWithAggregationInput>
    by: Array<CompanyDetailsScalarFieldEnum>
    having?: CompanyDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyDetailsCountAggregateInputType | true
    _min?: CompanyDetailsMinAggregateInputType
    _max?: CompanyDetailsMaxAggregateInputType
  }


  export type CompanyDetailsGroupByOutputType = {
    companyDetailsID: string
    description: string
    mission: string | null
    vision: string | null
    companyID: string | null
    _count: CompanyDetailsCountAggregateOutputType | null
    _min: CompanyDetailsMinAggregateOutputType | null
    _max: CompanyDetailsMaxAggregateOutputType | null
  }

  type GetCompanyDetailsGroupByPayload<T extends CompanyDetailsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CompanyDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyDetailsGroupByOutputType[P]>
        }
      >
    >


  export type CompanyDetailsSelect = {
    companyDetailsID?: boolean
    description?: boolean
    mission?: boolean
    vision?: boolean
    companyID?: boolean
    Company?: boolean | CompanyArgs
    location?: boolean | AddressArgs
  }


  export type CompanyDetailsInclude = {
    Company?: boolean | CompanyArgs
    location?: boolean | AddressArgs
  } 

  export type CompanyDetailsGetPayload<S extends boolean | null | undefined | CompanyDetailsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CompanyDetails :
    S extends undefined ? never :
    S extends { include: any } & (CompanyDetailsArgs | CompanyDetailsFindManyArgs)
    ? CompanyDetails  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Company' ? CompanyGetPayload<S['include'][P]> | null :
        P extends 'location' ? AddressGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (CompanyDetailsArgs | CompanyDetailsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Company' ? CompanyGetPayload<S['select'][P]> | null :
        P extends 'location' ? AddressGetPayload<S['select'][P]> | null :  P extends keyof CompanyDetails ? CompanyDetails[P] : never
  } 
      : CompanyDetails


  type CompanyDetailsCountArgs = Merge<
    Omit<CompanyDetailsFindManyArgs, 'select' | 'include'> & {
      select?: CompanyDetailsCountAggregateInputType | true
    }
  >

  export interface CompanyDetailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one CompanyDetails that matches the filter.
     * @param {CompanyDetailsFindUniqueArgs} args - Arguments to find a CompanyDetails
     * @example
     * // Get one CompanyDetails
     * const companyDetails = await prisma.companyDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyDetailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CompanyDetailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CompanyDetails'> extends True ? Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T>> : Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T> | null, null>

    /**
     * Find one CompanyDetails that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CompanyDetailsFindUniqueOrThrowArgs} args - Arguments to find a CompanyDetails
     * @example
     * // Get one CompanyDetails
     * const companyDetails = await prisma.companyDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyDetailsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CompanyDetailsFindUniqueOrThrowArgs>
    ): Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T>>

    /**
     * Find the first CompanyDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDetailsFindFirstArgs} args - Arguments to find a CompanyDetails
     * @example
     * // Get one CompanyDetails
     * const companyDetails = await prisma.companyDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyDetailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CompanyDetailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CompanyDetails'> extends True ? Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T>> : Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T> | null, null>

    /**
     * Find the first CompanyDetails that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDetailsFindFirstOrThrowArgs} args - Arguments to find a CompanyDetails
     * @example
     * // Get one CompanyDetails
     * const companyDetails = await prisma.companyDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyDetailsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CompanyDetailsFindFirstOrThrowArgs>
    ): Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T>>

    /**
     * Find zero or more CompanyDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyDetails
     * const companyDetails = await prisma.companyDetails.findMany()
     * 
     * // Get first 10 CompanyDetails
     * const companyDetails = await prisma.companyDetails.findMany({ take: 10 })
     * 
     * // Only select the `companyDetailsID`
     * const companyDetailsWithCompanyDetailsIDOnly = await prisma.companyDetails.findMany({ select: { companyDetailsID: true } })
     * 
    **/
    findMany<T extends CompanyDetailsFindManyArgs>(
      args?: SelectSubset<T, CompanyDetailsFindManyArgs>
    ): PrismaPromise<Array<CompanyDetailsGetPayload<T>>>

    /**
     * Create a CompanyDetails.
     * @param {CompanyDetailsCreateArgs} args - Arguments to create a CompanyDetails.
     * @example
     * // Create one CompanyDetails
     * const CompanyDetails = await prisma.companyDetails.create({
     *   data: {
     *     // ... data to create a CompanyDetails
     *   }
     * })
     * 
    **/
    create<T extends CompanyDetailsCreateArgs>(
      args: SelectSubset<T, CompanyDetailsCreateArgs>
    ): Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T>>

    /**
     * Create many CompanyDetails.
     *     @param {CompanyDetailsCreateManyArgs} args - Arguments to create many CompanyDetails.
     *     @example
     *     // Create many CompanyDetails
     *     const companyDetails = await prisma.companyDetails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CompanyDetailsCreateManyArgs>(
      args?: SelectSubset<T, CompanyDetailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyDetails.
     * @param {CompanyDetailsDeleteArgs} args - Arguments to delete one CompanyDetails.
     * @example
     * // Delete one CompanyDetails
     * const CompanyDetails = await prisma.companyDetails.delete({
     *   where: {
     *     // ... filter to delete one CompanyDetails
     *   }
     * })
     * 
    **/
    delete<T extends CompanyDetailsDeleteArgs>(
      args: SelectSubset<T, CompanyDetailsDeleteArgs>
    ): Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T>>

    /**
     * Update one CompanyDetails.
     * @param {CompanyDetailsUpdateArgs} args - Arguments to update one CompanyDetails.
     * @example
     * // Update one CompanyDetails
     * const companyDetails = await prisma.companyDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyDetailsUpdateArgs>(
      args: SelectSubset<T, CompanyDetailsUpdateArgs>
    ): Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T>>

    /**
     * Delete zero or more CompanyDetails.
     * @param {CompanyDetailsDeleteManyArgs} args - Arguments to filter CompanyDetails to delete.
     * @example
     * // Delete a few CompanyDetails
     * const { count } = await prisma.companyDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyDetailsDeleteManyArgs>(
      args?: SelectSubset<T, CompanyDetailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyDetails
     * const companyDetails = await prisma.companyDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyDetailsUpdateManyArgs>(
      args: SelectSubset<T, CompanyDetailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyDetails.
     * @param {CompanyDetailsUpsertArgs} args - Arguments to update or create a CompanyDetails.
     * @example
     * // Update or create a CompanyDetails
     * const companyDetails = await prisma.companyDetails.upsert({
     *   create: {
     *     // ... data to create a CompanyDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyDetails we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyDetailsUpsertArgs>(
      args: SelectSubset<T, CompanyDetailsUpsertArgs>
    ): Prisma__CompanyDetailsClient<CompanyDetailsGetPayload<T>>

    /**
     * Count the number of CompanyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDetailsCountArgs} args - Arguments to filter CompanyDetails to count.
     * @example
     * // Count the number of CompanyDetails
     * const count = await prisma.companyDetails.count({
     *   where: {
     *     // ... the filter for the CompanyDetails we want to count
     *   }
     * })
    **/
    count<T extends CompanyDetailsCountArgs>(
      args?: Subset<T, CompanyDetailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyDetailsAggregateArgs>(args: Subset<T, CompanyDetailsAggregateArgs>): PrismaPromise<GetCompanyDetailsAggregateType<T>>

    /**
     * Group by CompanyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyDetailsGroupByArgs['orderBy'] }
        : { orderBy?: CompanyDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyDetailsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CompanyDetailsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company<T extends CompanyArgs= {}>(args?: Subset<T, CompanyArgs>): Prisma__CompanyClient<CompanyGetPayload<T> | Null>;

    location<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CompanyDetails base type for findUnique actions
   */
  export type CompanyDetailsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CompanyDetails
     * 
    **/
    select?: CompanyDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyDetailsInclude | null
    /**
     * Filter, which CompanyDetails to fetch.
     * 
    **/
    where: CompanyDetailsWhereUniqueInput
  }

  /**
   * CompanyDetails findUnique
   */
  export interface CompanyDetailsFindUniqueArgs extends CompanyDetailsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CompanyDetails findUniqueOrThrow
   */
  export type CompanyDetailsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CompanyDetails
     * 
    **/
    select?: CompanyDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyDetailsInclude | null
    /**
     * Filter, which CompanyDetails to fetch.
     * 
    **/
    where: CompanyDetailsWhereUniqueInput
  }


  /**
   * CompanyDetails base type for findFirst actions
   */
  export type CompanyDetailsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CompanyDetails
     * 
    **/
    select?: CompanyDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyDetailsInclude | null
    /**
     * Filter, which CompanyDetails to fetch.
     * 
    **/
    where?: CompanyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<CompanyDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyDetails.
     * 
    **/
    cursor?: CompanyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyDetails.
     * 
    **/
    distinct?: Enumerable<CompanyDetailsScalarFieldEnum>
  }

  /**
   * CompanyDetails findFirst
   */
  export interface CompanyDetailsFindFirstArgs extends CompanyDetailsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CompanyDetails findFirstOrThrow
   */
  export type CompanyDetailsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CompanyDetails
     * 
    **/
    select?: CompanyDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyDetailsInclude | null
    /**
     * Filter, which CompanyDetails to fetch.
     * 
    **/
    where?: CompanyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<CompanyDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyDetails.
     * 
    **/
    cursor?: CompanyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyDetails.
     * 
    **/
    distinct?: Enumerable<CompanyDetailsScalarFieldEnum>
  }


  /**
   * CompanyDetails findMany
   */
  export type CompanyDetailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the CompanyDetails
     * 
    **/
    select?: CompanyDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyDetailsInclude | null
    /**
     * Filter, which CompanyDetails to fetch.
     * 
    **/
    where?: CompanyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<CompanyDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyDetails.
     * 
    **/
    cursor?: CompanyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CompanyDetailsScalarFieldEnum>
  }


  /**
   * CompanyDetails create
   */
  export type CompanyDetailsCreateArgs = {
    /**
     * Select specific fields to fetch from the CompanyDetails
     * 
    **/
    select?: CompanyDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyDetailsInclude | null
    /**
     * The data needed to create a CompanyDetails.
     * 
    **/
    data: XOR<CompanyDetailsCreateInput, CompanyDetailsUncheckedCreateInput>
  }


  /**
   * CompanyDetails createMany
   */
  export type CompanyDetailsCreateManyArgs = {
    /**
     * The data used to create many CompanyDetails.
     * 
    **/
    data: Enumerable<CompanyDetailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CompanyDetails update
   */
  export type CompanyDetailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the CompanyDetails
     * 
    **/
    select?: CompanyDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyDetailsInclude | null
    /**
     * The data needed to update a CompanyDetails.
     * 
    **/
    data: XOR<CompanyDetailsUpdateInput, CompanyDetailsUncheckedUpdateInput>
    /**
     * Choose, which CompanyDetails to update.
     * 
    **/
    where: CompanyDetailsWhereUniqueInput
  }


  /**
   * CompanyDetails updateMany
   */
  export type CompanyDetailsUpdateManyArgs = {
    /**
     * The data used to update CompanyDetails.
     * 
    **/
    data: XOR<CompanyDetailsUpdateManyMutationInput, CompanyDetailsUncheckedUpdateManyInput>
    /**
     * Filter which CompanyDetails to update
     * 
    **/
    where?: CompanyDetailsWhereInput
  }


  /**
   * CompanyDetails upsert
   */
  export type CompanyDetailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the CompanyDetails
     * 
    **/
    select?: CompanyDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyDetailsInclude | null
    /**
     * The filter to search for the CompanyDetails to update in case it exists.
     * 
    **/
    where: CompanyDetailsWhereUniqueInput
    /**
     * In case the CompanyDetails found by the `where` argument doesn't exist, create a new CompanyDetails with this data.
     * 
    **/
    create: XOR<CompanyDetailsCreateInput, CompanyDetailsUncheckedCreateInput>
    /**
     * In case the CompanyDetails was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CompanyDetailsUpdateInput, CompanyDetailsUncheckedUpdateInput>
  }


  /**
   * CompanyDetails delete
   */
  export type CompanyDetailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the CompanyDetails
     * 
    **/
    select?: CompanyDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyDetailsInclude | null
    /**
     * Filter which CompanyDetails to delete.
     * 
    **/
    where: CompanyDetailsWhereUniqueInput
  }


  /**
   * CompanyDetails deleteMany
   */
  export type CompanyDetailsDeleteManyArgs = {
    /**
     * Filter which CompanyDetails to delete
     * 
    **/
    where?: CompanyDetailsWhereInput
  }


  /**
   * CompanyDetails without action
   */
  export type CompanyDetailsArgs = {
    /**
     * Select specific fields to fetch from the CompanyDetails
     * 
    **/
    select?: CompanyDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CompanyDetailsInclude | null
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    commentID: string | null
    message: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    endorsementID: string | null
    userID: string | null
  }

  export type CommentMaxAggregateOutputType = {
    commentID: string | null
    message: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    endorsementID: string | null
    userID: string | null
  }

  export type CommentCountAggregateOutputType = {
    commentID: number
    message: number
    notes: number
    createdAt: number
    updatedAt: number
    endorsementID: number
    userID: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    commentID?: true
    message?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    endorsementID?: true
    userID?: true
  }

  export type CommentMaxAggregateInputType = {
    commentID?: true
    message?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    endorsementID?: true
    userID?: true
  }

  export type CommentCountAggregateInputType = {
    commentID?: true
    message?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    endorsementID?: true
    userID?: true
    _all?: true
  }

  export type CommentAggregateArgs = {
    /**
     * Filter which Comment to aggregate.
     * 
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     * 
    **/
    orderBy?: Enumerable<CommentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs = {
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithAggregationInput>
    by: Array<CommentScalarFieldEnum>
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }


  export type CommentGroupByOutputType = {
    commentID: string
    message: string
    notes: string
    createdAt: Date
    updatedAt: Date
    endorsementID: string | null
    userID: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect = {
    commentID?: boolean
    message?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    endorsementID?: boolean
    userID?: boolean
    Endorsement?: boolean | EndorsementArgs
    User?: boolean | UserArgs
  }


  export type CommentInclude = {
    Endorsement?: boolean | EndorsementArgs
    User?: boolean | UserArgs
  } 

  export type CommentGetPayload<S extends boolean | null | undefined | CommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Comment :
    S extends undefined ? never :
    S extends { include: any } & (CommentArgs | CommentFindManyArgs)
    ? Comment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Endorsement' ? EndorsementGetPayload<S['include'][P]> | null :
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (CommentArgs | CommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Endorsement' ? EndorsementGetPayload<S['select'][P]> | null :
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Comment ? Comment[P] : never
  } 
      : Comment


  type CommentCountArgs = Merge<
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }
  >

  export interface CommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comment'> extends True ? Prisma__CommentClient<CommentGetPayload<T>> : Prisma__CommentClient<CommentGetPayload<T> | null, null>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comment'> extends True ? Prisma__CommentClient<CommentGetPayload<T>> : Prisma__CommentClient<CommentGetPayload<T> | null, null>

    /**
     * Find the first Comment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `commentID`
     * const commentWithCommentIDOnly = await prisma.comment.findMany({ select: { commentID: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs>
    ): PrismaPromise<Array<CommentGetPayload<T>>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Endorsement<T extends EndorsementArgs= {}>(args?: Subset<T, EndorsementArgs>): Prisma__EndorsementClient<EndorsementGetPayload<T> | Null>;

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Comment base type for findUnique actions
   */
  export type CommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     * 
    **/
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUnique
   */
  export interface CommentFindUniqueArgs extends CommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     * 
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment base type for findFirst actions
   */
  export type CommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     * 
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     * 
    **/
    orderBy?: Enumerable<CommentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     * 
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     * 
    **/
    distinct?: Enumerable<CommentScalarFieldEnum>
  }

  /**
   * Comment findFirst
   */
  export interface CommentFindFirstArgs extends CommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     * 
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     * 
    **/
    orderBy?: Enumerable<CommentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     * 
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     * 
    **/
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentInclude | null
    /**
     * Filter, which Comments to fetch.
     * 
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     * 
    **/
    orderBy?: Enumerable<CommentOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     * 
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentInclude | null
    /**
     * The data needed to create a Comment.
     * 
    **/
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs = {
    /**
     * The data used to create many Comments.
     * 
    **/
    data: Enumerable<CommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentInclude | null
    /**
     * The data needed to update a Comment.
     * 
    **/
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     * 
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs = {
    /**
     * The data used to update Comments.
     * 
    **/
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     * 
    **/
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentInclude | null
    /**
     * The filter to search for the Comment to update in case it exists.
     * 
    **/
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     * 
    **/
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentInclude | null
    /**
     * Filter which Comment to delete.
     * 
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs = {
    /**
     * Filter which Comments to delete
     * 
    **/
    where?: CommentWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
     * 
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CommentInclude | null
  }



  /**
   * Model Endorsement
   */


  export type AggregateEndorsement = {
    _count: EndorsementCountAggregateOutputType | null
    _min: EndorsementMinAggregateOutputType | null
    _max: EndorsementMaxAggregateOutputType | null
  }

  export type EndorsementMinAggregateOutputType = {
    endorsementID: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userID: string | null
    companyID: string | null
  }

  export type EndorsementMaxAggregateOutputType = {
    endorsementID: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userID: string | null
    companyID: string | null
  }

  export type EndorsementCountAggregateOutputType = {
    endorsementID: number
    Status: number
    createdAt: number
    updatedAt: number
    userID: number
    companyID: number
    _all: number
  }


  export type EndorsementMinAggregateInputType = {
    endorsementID?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
    companyID?: true
  }

  export type EndorsementMaxAggregateInputType = {
    endorsementID?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
    companyID?: true
  }

  export type EndorsementCountAggregateInputType = {
    endorsementID?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    userID?: true
    companyID?: true
    _all?: true
  }

  export type EndorsementAggregateArgs = {
    /**
     * Filter which Endorsement to aggregate.
     * 
    **/
    where?: EndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorsements to fetch.
     * 
    **/
    orderBy?: Enumerable<EndorsementOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorsements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorsements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Endorsements
    **/
    _count?: true | EndorsementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EndorsementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EndorsementMaxAggregateInputType
  }

  export type GetEndorsementAggregateType<T extends EndorsementAggregateArgs> = {
        [P in keyof T & keyof AggregateEndorsement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndorsement[P]>
      : GetScalarType<T[P], AggregateEndorsement[P]>
  }




  export type EndorsementGroupByArgs = {
    where?: EndorsementWhereInput
    orderBy?: Enumerable<EndorsementOrderByWithAggregationInput>
    by: Array<EndorsementScalarFieldEnum>
    having?: EndorsementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EndorsementCountAggregateInputType | true
    _min?: EndorsementMinAggregateInputType
    _max?: EndorsementMaxAggregateInputType
  }


  export type EndorsementGroupByOutputType = {
    endorsementID: string
    Status: string
    createdAt: Date
    updatedAt: Date
    userID: string | null
    companyID: string | null
    _count: EndorsementCountAggregateOutputType | null
    _min: EndorsementMinAggregateOutputType | null
    _max: EndorsementMaxAggregateOutputType | null
  }

  type GetEndorsementGroupByPayload<T extends EndorsementGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EndorsementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EndorsementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EndorsementGroupByOutputType[P]>
            : GetScalarType<T[P], EndorsementGroupByOutputType[P]>
        }
      >
    >


  export type EndorsementSelect = {
    endorsementID?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userID?: boolean
    companyID?: boolean
    Company?: boolean | CompanyArgs
    User?: boolean | UserArgs
    Comment?: boolean | CommentArgs
    Endorse?: boolean | Endorsement$EndorseArgs
    Applicant?: boolean | Endorsement$ApplicantArgs
    _count?: boolean | EndorsementCountOutputTypeArgs
  }


  export type EndorsementInclude = {
    Company?: boolean | CompanyArgs
    User?: boolean | UserArgs
    Comment?: boolean | CommentArgs
    Endorse?: boolean | Endorsement$EndorseArgs
    Applicant?: boolean | Endorsement$ApplicantArgs
    _count?: boolean | EndorsementCountOutputTypeArgs
  } 

  export type EndorsementGetPayload<S extends boolean | null | undefined | EndorsementArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Endorsement :
    S extends undefined ? never :
    S extends { include: any } & (EndorsementArgs | EndorsementFindManyArgs)
    ? Endorsement  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Company' ? CompanyGetPayload<S['include'][P]> | null :
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :
        P extends 'Comment' ? CommentGetPayload<S['include'][P]> | null :
        P extends 'Endorse' ? Array < EndorseGetPayload<S['include'][P]>>  :
        P extends 'Applicant' ? Array < ApplicantGetPayload<S['include'][P]>>  :
        P extends '_count' ? EndorsementCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EndorsementArgs | EndorsementFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Company' ? CompanyGetPayload<S['select'][P]> | null :
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :
        P extends 'Comment' ? CommentGetPayload<S['select'][P]> | null :
        P extends 'Endorse' ? Array < EndorseGetPayload<S['select'][P]>>  :
        P extends 'Applicant' ? Array < ApplicantGetPayload<S['select'][P]>>  :
        P extends '_count' ? EndorsementCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Endorsement ? Endorsement[P] : never
  } 
      : Endorsement


  type EndorsementCountArgs = Merge<
    Omit<EndorsementFindManyArgs, 'select' | 'include'> & {
      select?: EndorsementCountAggregateInputType | true
    }
  >

  export interface EndorsementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Endorsement that matches the filter.
     * @param {EndorsementFindUniqueArgs} args - Arguments to find a Endorsement
     * @example
     * // Get one Endorsement
     * const endorsement = await prisma.endorsement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EndorsementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EndorsementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Endorsement'> extends True ? Prisma__EndorsementClient<EndorsementGetPayload<T>> : Prisma__EndorsementClient<EndorsementGetPayload<T> | null, null>

    /**
     * Find one Endorsement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EndorsementFindUniqueOrThrowArgs} args - Arguments to find a Endorsement
     * @example
     * // Get one Endorsement
     * const endorsement = await prisma.endorsement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EndorsementFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EndorsementFindUniqueOrThrowArgs>
    ): Prisma__EndorsementClient<EndorsementGetPayload<T>>

    /**
     * Find the first Endorsement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementFindFirstArgs} args - Arguments to find a Endorsement
     * @example
     * // Get one Endorsement
     * const endorsement = await prisma.endorsement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EndorsementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EndorsementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Endorsement'> extends True ? Prisma__EndorsementClient<EndorsementGetPayload<T>> : Prisma__EndorsementClient<EndorsementGetPayload<T> | null, null>

    /**
     * Find the first Endorsement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementFindFirstOrThrowArgs} args - Arguments to find a Endorsement
     * @example
     * // Get one Endorsement
     * const endorsement = await prisma.endorsement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EndorsementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EndorsementFindFirstOrThrowArgs>
    ): Prisma__EndorsementClient<EndorsementGetPayload<T>>

    /**
     * Find zero or more Endorsements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Endorsements
     * const endorsements = await prisma.endorsement.findMany()
     * 
     * // Get first 10 Endorsements
     * const endorsements = await prisma.endorsement.findMany({ take: 10 })
     * 
     * // Only select the `endorsementID`
     * const endorsementWithEndorsementIDOnly = await prisma.endorsement.findMany({ select: { endorsementID: true } })
     * 
    **/
    findMany<T extends EndorsementFindManyArgs>(
      args?: SelectSubset<T, EndorsementFindManyArgs>
    ): PrismaPromise<Array<EndorsementGetPayload<T>>>

    /**
     * Create a Endorsement.
     * @param {EndorsementCreateArgs} args - Arguments to create a Endorsement.
     * @example
     * // Create one Endorsement
     * const Endorsement = await prisma.endorsement.create({
     *   data: {
     *     // ... data to create a Endorsement
     *   }
     * })
     * 
    **/
    create<T extends EndorsementCreateArgs>(
      args: SelectSubset<T, EndorsementCreateArgs>
    ): Prisma__EndorsementClient<EndorsementGetPayload<T>>

    /**
     * Create many Endorsements.
     *     @param {EndorsementCreateManyArgs} args - Arguments to create many Endorsements.
     *     @example
     *     // Create many Endorsements
     *     const endorsement = await prisma.endorsement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EndorsementCreateManyArgs>(
      args?: SelectSubset<T, EndorsementCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Endorsement.
     * @param {EndorsementDeleteArgs} args - Arguments to delete one Endorsement.
     * @example
     * // Delete one Endorsement
     * const Endorsement = await prisma.endorsement.delete({
     *   where: {
     *     // ... filter to delete one Endorsement
     *   }
     * })
     * 
    **/
    delete<T extends EndorsementDeleteArgs>(
      args: SelectSubset<T, EndorsementDeleteArgs>
    ): Prisma__EndorsementClient<EndorsementGetPayload<T>>

    /**
     * Update one Endorsement.
     * @param {EndorsementUpdateArgs} args - Arguments to update one Endorsement.
     * @example
     * // Update one Endorsement
     * const endorsement = await prisma.endorsement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EndorsementUpdateArgs>(
      args: SelectSubset<T, EndorsementUpdateArgs>
    ): Prisma__EndorsementClient<EndorsementGetPayload<T>>

    /**
     * Delete zero or more Endorsements.
     * @param {EndorsementDeleteManyArgs} args - Arguments to filter Endorsements to delete.
     * @example
     * // Delete a few Endorsements
     * const { count } = await prisma.endorsement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EndorsementDeleteManyArgs>(
      args?: SelectSubset<T, EndorsementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Endorsements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Endorsements
     * const endorsement = await prisma.endorsement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EndorsementUpdateManyArgs>(
      args: SelectSubset<T, EndorsementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Endorsement.
     * @param {EndorsementUpsertArgs} args - Arguments to update or create a Endorsement.
     * @example
     * // Update or create a Endorsement
     * const endorsement = await prisma.endorsement.upsert({
     *   create: {
     *     // ... data to create a Endorsement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endorsement we want to update
     *   }
     * })
    **/
    upsert<T extends EndorsementUpsertArgs>(
      args: SelectSubset<T, EndorsementUpsertArgs>
    ): Prisma__EndorsementClient<EndorsementGetPayload<T>>

    /**
     * Count the number of Endorsements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementCountArgs} args - Arguments to filter Endorsements to count.
     * @example
     * // Count the number of Endorsements
     * const count = await prisma.endorsement.count({
     *   where: {
     *     // ... the filter for the Endorsements we want to count
     *   }
     * })
    **/
    count<T extends EndorsementCountArgs>(
      args?: Subset<T, EndorsementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EndorsementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Endorsement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EndorsementAggregateArgs>(args: Subset<T, EndorsementAggregateArgs>): PrismaPromise<GetEndorsementAggregateType<T>>

    /**
     * Group by Endorsement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorsementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EndorsementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EndorsementGroupByArgs['orderBy'] }
        : { orderBy?: EndorsementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EndorsementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEndorsementGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Endorsement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EndorsementClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company<T extends CompanyArgs= {}>(args?: Subset<T, CompanyArgs>): Prisma__CompanyClient<CompanyGetPayload<T> | Null>;

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    Comment<T extends CommentArgs= {}>(args?: Subset<T, CommentArgs>): Prisma__CommentClient<CommentGetPayload<T> | Null>;

    Endorse<T extends Endorsement$EndorseArgs= {}>(args?: Subset<T, Endorsement$EndorseArgs>): PrismaPromise<Array<EndorseGetPayload<T>>| Null>;

    Applicant<T extends Endorsement$ApplicantArgs= {}>(args?: Subset<T, Endorsement$ApplicantArgs>): PrismaPromise<Array<ApplicantGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Endorsement base type for findUnique actions
   */
  export type EndorsementFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    /**
     * Filter, which Endorsement to fetch.
     * 
    **/
    where: EndorsementWhereUniqueInput
  }

  /**
   * Endorsement findUnique
   */
  export interface EndorsementFindUniqueArgs extends EndorsementFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Endorsement findUniqueOrThrow
   */
  export type EndorsementFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    /**
     * Filter, which Endorsement to fetch.
     * 
    **/
    where: EndorsementWhereUniqueInput
  }


  /**
   * Endorsement base type for findFirst actions
   */
  export type EndorsementFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    /**
     * Filter, which Endorsement to fetch.
     * 
    **/
    where?: EndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorsements to fetch.
     * 
    **/
    orderBy?: Enumerable<EndorsementOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Endorsements.
     * 
    **/
    cursor?: EndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorsements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorsements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Endorsements.
     * 
    **/
    distinct?: Enumerable<EndorsementScalarFieldEnum>
  }

  /**
   * Endorsement findFirst
   */
  export interface EndorsementFindFirstArgs extends EndorsementFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Endorsement findFirstOrThrow
   */
  export type EndorsementFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    /**
     * Filter, which Endorsement to fetch.
     * 
    **/
    where?: EndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorsements to fetch.
     * 
    **/
    orderBy?: Enumerable<EndorsementOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Endorsements.
     * 
    **/
    cursor?: EndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorsements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorsements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Endorsements.
     * 
    **/
    distinct?: Enumerable<EndorsementScalarFieldEnum>
  }


  /**
   * Endorsement findMany
   */
  export type EndorsementFindManyArgs = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    /**
     * Filter, which Endorsements to fetch.
     * 
    **/
    where?: EndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorsements to fetch.
     * 
    **/
    orderBy?: Enumerable<EndorsementOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Endorsements.
     * 
    **/
    cursor?: EndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorsements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorsements.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EndorsementScalarFieldEnum>
  }


  /**
   * Endorsement create
   */
  export type EndorsementCreateArgs = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    /**
     * The data needed to create a Endorsement.
     * 
    **/
    data: XOR<EndorsementCreateInput, EndorsementUncheckedCreateInput>
  }


  /**
   * Endorsement createMany
   */
  export type EndorsementCreateManyArgs = {
    /**
     * The data used to create many Endorsements.
     * 
    **/
    data: Enumerable<EndorsementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Endorsement update
   */
  export type EndorsementUpdateArgs = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    /**
     * The data needed to update a Endorsement.
     * 
    **/
    data: XOR<EndorsementUpdateInput, EndorsementUncheckedUpdateInput>
    /**
     * Choose, which Endorsement to update.
     * 
    **/
    where: EndorsementWhereUniqueInput
  }


  /**
   * Endorsement updateMany
   */
  export type EndorsementUpdateManyArgs = {
    /**
     * The data used to update Endorsements.
     * 
    **/
    data: XOR<EndorsementUpdateManyMutationInput, EndorsementUncheckedUpdateManyInput>
    /**
     * Filter which Endorsements to update
     * 
    **/
    where?: EndorsementWhereInput
  }


  /**
   * Endorsement upsert
   */
  export type EndorsementUpsertArgs = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    /**
     * The filter to search for the Endorsement to update in case it exists.
     * 
    **/
    where: EndorsementWhereUniqueInput
    /**
     * In case the Endorsement found by the `where` argument doesn't exist, create a new Endorsement with this data.
     * 
    **/
    create: XOR<EndorsementCreateInput, EndorsementUncheckedCreateInput>
    /**
     * In case the Endorsement was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EndorsementUpdateInput, EndorsementUncheckedUpdateInput>
  }


  /**
   * Endorsement delete
   */
  export type EndorsementDeleteArgs = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    /**
     * Filter which Endorsement to delete.
     * 
    **/
    where: EndorsementWhereUniqueInput
  }


  /**
   * Endorsement deleteMany
   */
  export type EndorsementDeleteManyArgs = {
    /**
     * Filter which Endorsements to delete
     * 
    **/
    where?: EndorsementWhereInput
  }


  /**
   * Endorsement.Endorse
   */
  export type Endorsement$EndorseArgs = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    where?: EndorseWhereInput
    orderBy?: Enumerable<EndorseOrderByWithRelationAndSearchRelevanceInput>
    cursor?: EndorseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EndorseScalarFieldEnum>
  }


  /**
   * Endorsement.Applicant
   */
  export type Endorsement$ApplicantArgs = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
    where?: ApplicantWhereInput
    orderBy?: Enumerable<ApplicantOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ApplicantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ApplicantScalarFieldEnum>
  }


  /**
   * Endorsement without action
   */
  export type EndorsementArgs = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
  }



  /**
   * Model Endorse
   */


  export type AggregateEndorse = {
    _count: EndorseCountAggregateOutputType | null
    _min: EndorseMinAggregateOutputType | null
    _max: EndorseMaxAggregateOutputType | null
  }

  export type EndorseMinAggregateOutputType = {
    endorseID: string | null
    endorseStatus: endorseStatus | null
    userID: string | null
    createdAt: Date | null
    companyID: string | null
  }

  export type EndorseMaxAggregateOutputType = {
    endorseID: string | null
    endorseStatus: endorseStatus | null
    userID: string | null
    createdAt: Date | null
    companyID: string | null
  }

  export type EndorseCountAggregateOutputType = {
    endorseID: number
    endorseStatus: number
    userID: number
    createdAt: number
    companyID: number
    _all: number
  }


  export type EndorseMinAggregateInputType = {
    endorseID?: true
    endorseStatus?: true
    userID?: true
    createdAt?: true
    companyID?: true
  }

  export type EndorseMaxAggregateInputType = {
    endorseID?: true
    endorseStatus?: true
    userID?: true
    createdAt?: true
    companyID?: true
  }

  export type EndorseCountAggregateInputType = {
    endorseID?: true
    endorseStatus?: true
    userID?: true
    createdAt?: true
    companyID?: true
    _all?: true
  }

  export type EndorseAggregateArgs = {
    /**
     * Filter which Endorse to aggregate.
     * 
    **/
    where?: EndorseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorses to fetch.
     * 
    **/
    orderBy?: Enumerable<EndorseOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EndorseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Endorses
    **/
    _count?: true | EndorseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EndorseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EndorseMaxAggregateInputType
  }

  export type GetEndorseAggregateType<T extends EndorseAggregateArgs> = {
        [P in keyof T & keyof AggregateEndorse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndorse[P]>
      : GetScalarType<T[P], AggregateEndorse[P]>
  }




  export type EndorseGroupByArgs = {
    where?: EndorseWhereInput
    orderBy?: Enumerable<EndorseOrderByWithAggregationInput>
    by: Array<EndorseScalarFieldEnum>
    having?: EndorseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EndorseCountAggregateInputType | true
    _min?: EndorseMinAggregateInputType
    _max?: EndorseMaxAggregateInputType
  }


  export type EndorseGroupByOutputType = {
    endorseID: string
    endorseStatus: endorseStatus
    userID: string
    createdAt: Date
    companyID: string | null
    _count: EndorseCountAggregateOutputType | null
    _min: EndorseMinAggregateOutputType | null
    _max: EndorseMaxAggregateOutputType | null
  }

  type GetEndorseGroupByPayload<T extends EndorseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EndorseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EndorseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EndorseGroupByOutputType[P]>
            : GetScalarType<T[P], EndorseGroupByOutputType[P]>
        }
      >
    >


  export type EndorseSelect = {
    endorseID?: boolean
    endorseStatus?: boolean
    userID?: boolean
    createdAt?: boolean
    User?: boolean | UserArgs
    feedback?: boolean | Endorse$feedbackArgs
    Company?: boolean | CompanyArgs
    companyID?: boolean
    Endorsement?: boolean | Endorse$EndorsementArgs
    _count?: boolean | EndorseCountOutputTypeArgs
  }


  export type EndorseInclude = {
    User?: boolean | UserArgs
    feedback?: boolean | Endorse$feedbackArgs
    Company?: boolean | CompanyArgs
    Endorsement?: boolean | Endorse$EndorsementArgs
    _count?: boolean | EndorseCountOutputTypeArgs
  } 

  export type EndorseGetPayload<S extends boolean | null | undefined | EndorseArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Endorse :
    S extends undefined ? never :
    S extends { include: any } & (EndorseArgs | EndorseFindManyArgs)
    ? Endorse  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'feedback' ? Array < FeedbackGetPayload<S['include'][P]>>  :
        P extends 'Company' ? CompanyGetPayload<S['include'][P]> | null :
        P extends 'Endorsement' ? Array < EndorsementGetPayload<S['include'][P]>>  :
        P extends '_count' ? EndorseCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EndorseArgs | EndorseFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'feedback' ? Array < FeedbackGetPayload<S['select'][P]>>  :
        P extends 'Company' ? CompanyGetPayload<S['select'][P]> | null :
        P extends 'Endorsement' ? Array < EndorsementGetPayload<S['select'][P]>>  :
        P extends '_count' ? EndorseCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Endorse ? Endorse[P] : never
  } 
      : Endorse


  type EndorseCountArgs = Merge<
    Omit<EndorseFindManyArgs, 'select' | 'include'> & {
      select?: EndorseCountAggregateInputType | true
    }
  >

  export interface EndorseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Endorse that matches the filter.
     * @param {EndorseFindUniqueArgs} args - Arguments to find a Endorse
     * @example
     * // Get one Endorse
     * const endorse = await prisma.endorse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EndorseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EndorseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Endorse'> extends True ? Prisma__EndorseClient<EndorseGetPayload<T>> : Prisma__EndorseClient<EndorseGetPayload<T> | null, null>

    /**
     * Find one Endorse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EndorseFindUniqueOrThrowArgs} args - Arguments to find a Endorse
     * @example
     * // Get one Endorse
     * const endorse = await prisma.endorse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EndorseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EndorseFindUniqueOrThrowArgs>
    ): Prisma__EndorseClient<EndorseGetPayload<T>>

    /**
     * Find the first Endorse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorseFindFirstArgs} args - Arguments to find a Endorse
     * @example
     * // Get one Endorse
     * const endorse = await prisma.endorse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EndorseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EndorseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Endorse'> extends True ? Prisma__EndorseClient<EndorseGetPayload<T>> : Prisma__EndorseClient<EndorseGetPayload<T> | null, null>

    /**
     * Find the first Endorse that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorseFindFirstOrThrowArgs} args - Arguments to find a Endorse
     * @example
     * // Get one Endorse
     * const endorse = await prisma.endorse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EndorseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EndorseFindFirstOrThrowArgs>
    ): Prisma__EndorseClient<EndorseGetPayload<T>>

    /**
     * Find zero or more Endorses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Endorses
     * const endorses = await prisma.endorse.findMany()
     * 
     * // Get first 10 Endorses
     * const endorses = await prisma.endorse.findMany({ take: 10 })
     * 
     * // Only select the `endorseID`
     * const endorseWithEndorseIDOnly = await prisma.endorse.findMany({ select: { endorseID: true } })
     * 
    **/
    findMany<T extends EndorseFindManyArgs>(
      args?: SelectSubset<T, EndorseFindManyArgs>
    ): PrismaPromise<Array<EndorseGetPayload<T>>>

    /**
     * Create a Endorse.
     * @param {EndorseCreateArgs} args - Arguments to create a Endorse.
     * @example
     * // Create one Endorse
     * const Endorse = await prisma.endorse.create({
     *   data: {
     *     // ... data to create a Endorse
     *   }
     * })
     * 
    **/
    create<T extends EndorseCreateArgs>(
      args: SelectSubset<T, EndorseCreateArgs>
    ): Prisma__EndorseClient<EndorseGetPayload<T>>

    /**
     * Create many Endorses.
     *     @param {EndorseCreateManyArgs} args - Arguments to create many Endorses.
     *     @example
     *     // Create many Endorses
     *     const endorse = await prisma.endorse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EndorseCreateManyArgs>(
      args?: SelectSubset<T, EndorseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Endorse.
     * @param {EndorseDeleteArgs} args - Arguments to delete one Endorse.
     * @example
     * // Delete one Endorse
     * const Endorse = await prisma.endorse.delete({
     *   where: {
     *     // ... filter to delete one Endorse
     *   }
     * })
     * 
    **/
    delete<T extends EndorseDeleteArgs>(
      args: SelectSubset<T, EndorseDeleteArgs>
    ): Prisma__EndorseClient<EndorseGetPayload<T>>

    /**
     * Update one Endorse.
     * @param {EndorseUpdateArgs} args - Arguments to update one Endorse.
     * @example
     * // Update one Endorse
     * const endorse = await prisma.endorse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EndorseUpdateArgs>(
      args: SelectSubset<T, EndorseUpdateArgs>
    ): Prisma__EndorseClient<EndorseGetPayload<T>>

    /**
     * Delete zero or more Endorses.
     * @param {EndorseDeleteManyArgs} args - Arguments to filter Endorses to delete.
     * @example
     * // Delete a few Endorses
     * const { count } = await prisma.endorse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EndorseDeleteManyArgs>(
      args?: SelectSubset<T, EndorseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Endorses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Endorses
     * const endorse = await prisma.endorse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EndorseUpdateManyArgs>(
      args: SelectSubset<T, EndorseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Endorse.
     * @param {EndorseUpsertArgs} args - Arguments to update or create a Endorse.
     * @example
     * // Update or create a Endorse
     * const endorse = await prisma.endorse.upsert({
     *   create: {
     *     // ... data to create a Endorse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endorse we want to update
     *   }
     * })
    **/
    upsert<T extends EndorseUpsertArgs>(
      args: SelectSubset<T, EndorseUpsertArgs>
    ): Prisma__EndorseClient<EndorseGetPayload<T>>

    /**
     * Count the number of Endorses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorseCountArgs} args - Arguments to filter Endorses to count.
     * @example
     * // Count the number of Endorses
     * const count = await prisma.endorse.count({
     *   where: {
     *     // ... the filter for the Endorses we want to count
     *   }
     * })
    **/
    count<T extends EndorseCountArgs>(
      args?: Subset<T, EndorseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EndorseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Endorse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EndorseAggregateArgs>(args: Subset<T, EndorseAggregateArgs>): PrismaPromise<GetEndorseAggregateType<T>>

    /**
     * Group by Endorse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EndorseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EndorseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EndorseGroupByArgs['orderBy'] }
        : { orderBy?: EndorseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EndorseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEndorseGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Endorse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EndorseClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    feedback<T extends Endorse$feedbackArgs= {}>(args?: Subset<T, Endorse$feedbackArgs>): PrismaPromise<Array<FeedbackGetPayload<T>>| Null>;

    Company<T extends CompanyArgs= {}>(args?: Subset<T, CompanyArgs>): Prisma__CompanyClient<CompanyGetPayload<T> | Null>;

    Endorsement<T extends Endorse$EndorsementArgs= {}>(args?: Subset<T, Endorse$EndorsementArgs>): PrismaPromise<Array<EndorsementGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Endorse base type for findUnique actions
   */
  export type EndorseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    /**
     * Filter, which Endorse to fetch.
     * 
    **/
    where: EndorseWhereUniqueInput
  }

  /**
   * Endorse findUnique
   */
  export interface EndorseFindUniqueArgs extends EndorseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Endorse findUniqueOrThrow
   */
  export type EndorseFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    /**
     * Filter, which Endorse to fetch.
     * 
    **/
    where: EndorseWhereUniqueInput
  }


  /**
   * Endorse base type for findFirst actions
   */
  export type EndorseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    /**
     * Filter, which Endorse to fetch.
     * 
    **/
    where?: EndorseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorses to fetch.
     * 
    **/
    orderBy?: Enumerable<EndorseOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Endorses.
     * 
    **/
    cursor?: EndorseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Endorses.
     * 
    **/
    distinct?: Enumerable<EndorseScalarFieldEnum>
  }

  /**
   * Endorse findFirst
   */
  export interface EndorseFindFirstArgs extends EndorseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Endorse findFirstOrThrow
   */
  export type EndorseFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    /**
     * Filter, which Endorse to fetch.
     * 
    **/
    where?: EndorseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorses to fetch.
     * 
    **/
    orderBy?: Enumerable<EndorseOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Endorses.
     * 
    **/
    cursor?: EndorseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Endorses.
     * 
    **/
    distinct?: Enumerable<EndorseScalarFieldEnum>
  }


  /**
   * Endorse findMany
   */
  export type EndorseFindManyArgs = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    /**
     * Filter, which Endorses to fetch.
     * 
    **/
    where?: EndorseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Endorses to fetch.
     * 
    **/
    orderBy?: Enumerable<EndorseOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Endorses.
     * 
    **/
    cursor?: EndorseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Endorses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Endorses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EndorseScalarFieldEnum>
  }


  /**
   * Endorse create
   */
  export type EndorseCreateArgs = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    /**
     * The data needed to create a Endorse.
     * 
    **/
    data: XOR<EndorseCreateInput, EndorseUncheckedCreateInput>
  }


  /**
   * Endorse createMany
   */
  export type EndorseCreateManyArgs = {
    /**
     * The data used to create many Endorses.
     * 
    **/
    data: Enumerable<EndorseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Endorse update
   */
  export type EndorseUpdateArgs = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    /**
     * The data needed to update a Endorse.
     * 
    **/
    data: XOR<EndorseUpdateInput, EndorseUncheckedUpdateInput>
    /**
     * Choose, which Endorse to update.
     * 
    **/
    where: EndorseWhereUniqueInput
  }


  /**
   * Endorse updateMany
   */
  export type EndorseUpdateManyArgs = {
    /**
     * The data used to update Endorses.
     * 
    **/
    data: XOR<EndorseUpdateManyMutationInput, EndorseUncheckedUpdateManyInput>
    /**
     * Filter which Endorses to update
     * 
    **/
    where?: EndorseWhereInput
  }


  /**
   * Endorse upsert
   */
  export type EndorseUpsertArgs = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    /**
     * The filter to search for the Endorse to update in case it exists.
     * 
    **/
    where: EndorseWhereUniqueInput
    /**
     * In case the Endorse found by the `where` argument doesn't exist, create a new Endorse with this data.
     * 
    **/
    create: XOR<EndorseCreateInput, EndorseUncheckedCreateInput>
    /**
     * In case the Endorse was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EndorseUpdateInput, EndorseUncheckedUpdateInput>
  }


  /**
   * Endorse delete
   */
  export type EndorseDeleteArgs = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
    /**
     * Filter which Endorse to delete.
     * 
    **/
    where: EndorseWhereUniqueInput
  }


  /**
   * Endorse deleteMany
   */
  export type EndorseDeleteManyArgs = {
    /**
     * Filter which Endorses to delete
     * 
    **/
    where?: EndorseWhereInput
  }


  /**
   * Endorse.feedback
   */
  export type Endorse$feedbackArgs = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
    where?: FeedbackWhereInput
    orderBy?: Enumerable<FeedbackOrderByWithRelationAndSearchRelevanceInput>
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }


  /**
   * Endorse.Endorsement
   */
  export type Endorse$EndorsementArgs = {
    /**
     * Select specific fields to fetch from the Endorsement
     * 
    **/
    select?: EndorsementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorsementInclude | null
    where?: EndorsementWhereInput
    orderBy?: Enumerable<EndorsementOrderByWithRelationAndSearchRelevanceInput>
    cursor?: EndorsementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EndorsementScalarFieldEnum>
  }


  /**
   * Endorse without action
   */
  export type EndorseArgs = {
    /**
     * Select specific fields to fetch from the Endorse
     * 
    **/
    select?: EndorseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EndorseInclude | null
  }



  /**
   * Model Feedback
   */


  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackMinAggregateOutputType = {
    feedbackID: string | null
    feedback: string | null
    createdAt: Date | null
    endorseID: string | null
    userID: string | null
    applicantID: string | null
  }

  export type FeedbackMaxAggregateOutputType = {
    feedbackID: string | null
    feedback: string | null
    createdAt: Date | null
    endorseID: string | null
    userID: string | null
    applicantID: string | null
  }

  export type FeedbackCountAggregateOutputType = {
    feedbackID: number
    feedback: number
    createdAt: number
    endorseID: number
    userID: number
    applicantID: number
    _all: number
  }


  export type FeedbackMinAggregateInputType = {
    feedbackID?: true
    feedback?: true
    createdAt?: true
    endorseID?: true
    userID?: true
    applicantID?: true
  }

  export type FeedbackMaxAggregateInputType = {
    feedbackID?: true
    feedback?: true
    createdAt?: true
    endorseID?: true
    userID?: true
    applicantID?: true
  }

  export type FeedbackCountAggregateInputType = {
    feedbackID?: true
    feedback?: true
    createdAt?: true
    endorseID?: true
    userID?: true
    applicantID?: true
    _all?: true
  }

  export type FeedbackAggregateArgs = {
    /**
     * Filter which Feedback to aggregate.
     * 
    **/
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     * 
    **/
    orderBy?: Enumerable<FeedbackOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs = {
    where?: FeedbackWhereInput
    orderBy?: Enumerable<FeedbackOrderByWithAggregationInput>
    by: Array<FeedbackScalarFieldEnum>
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }


  export type FeedbackGroupByOutputType = {
    feedbackID: string
    feedback: string
    createdAt: Date
    endorseID: string | null
    userID: string | null
    applicantID: string | null
    _count: FeedbackCountAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect = {
    feedbackID?: boolean
    feedback?: boolean
    createdAt?: boolean
    endorseID?: boolean
    userID?: boolean
    Applicant?: boolean | ApplicantArgs
    Endorse?: boolean | EndorseArgs
    User?: boolean | UserArgs
    applicantID?: boolean
  }


  export type FeedbackInclude = {
    Applicant?: boolean | ApplicantArgs
    Endorse?: boolean | EndorseArgs
    User?: boolean | UserArgs
  } 

  export type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Feedback :
    S extends undefined ? never :
    S extends { include: any } & (FeedbackArgs | FeedbackFindManyArgs)
    ? Feedback  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Applicant' ? ApplicantGetPayload<S['include'][P]> | null :
        P extends 'Endorse' ? EndorseGetPayload<S['include'][P]> | null :
        P extends 'User' ? UserGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (FeedbackArgs | FeedbackFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Applicant' ? ApplicantGetPayload<S['select'][P]> | null :
        P extends 'Endorse' ? EndorseGetPayload<S['select'][P]> | null :
        P extends 'User' ? UserGetPayload<S['select'][P]> | null :  P extends keyof Feedback ? Feedback[P] : never
  } 
      : Feedback


  type FeedbackCountArgs = Merge<
    Omit<FeedbackFindManyArgs, 'select' | 'include'> & {
      select?: FeedbackCountAggregateInputType | true
    }
  >

  export interface FeedbackDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedbackFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FeedbackFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Feedback'> extends True ? Prisma__FeedbackClient<FeedbackGetPayload<T>> : Prisma__FeedbackClient<FeedbackGetPayload<T> | null, null>

    /**
     * Find one Feedback that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FeedbackFindUniqueOrThrowArgs>
    ): Prisma__FeedbackClient<FeedbackGetPayload<T>>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedbackFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FeedbackFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Feedback'> extends True ? Prisma__FeedbackClient<FeedbackGetPayload<T>> : Prisma__FeedbackClient<FeedbackGetPayload<T> | null, null>

    /**
     * Find the first Feedback that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs>
    ): Prisma__FeedbackClient<FeedbackGetPayload<T>>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `feedbackID`
     * const feedbackWithFeedbackIDOnly = await prisma.feedback.findMany({ select: { feedbackID: true } })
     * 
    **/
    findMany<T extends FeedbackFindManyArgs>(
      args?: SelectSubset<T, FeedbackFindManyArgs>
    ): PrismaPromise<Array<FeedbackGetPayload<T>>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
    **/
    create<T extends FeedbackCreateArgs>(
      args: SelectSubset<T, FeedbackCreateArgs>
    ): Prisma__FeedbackClient<FeedbackGetPayload<T>>

    /**
     * Create many Feedbacks.
     *     @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     *     @example
     *     // Create many Feedbacks
     *     const feedback = await prisma.feedback.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedbackCreateManyArgs>(
      args?: SelectSubset<T, FeedbackCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
    **/
    delete<T extends FeedbackDeleteArgs>(
      args: SelectSubset<T, FeedbackDeleteArgs>
    ): Prisma__FeedbackClient<FeedbackGetPayload<T>>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedbackUpdateArgs>(
      args: SelectSubset<T, FeedbackUpdateArgs>
    ): Prisma__FeedbackClient<FeedbackGetPayload<T>>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedbackDeleteManyArgs>(
      args?: SelectSubset<T, FeedbackDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedbackUpdateManyArgs>(
      args: SelectSubset<T, FeedbackUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
    **/
    upsert<T extends FeedbackUpsertArgs>(
      args: SelectSubset<T, FeedbackUpsertArgs>
    ): Prisma__FeedbackClient<FeedbackGetPayload<T>>

    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FeedbackClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Applicant<T extends ApplicantArgs= {}>(args?: Subset<T, ApplicantArgs>): Prisma__ApplicantClient<ApplicantGetPayload<T> | Null>;

    Endorse<T extends EndorseArgs= {}>(args?: Subset<T, EndorseArgs>): Prisma__EndorseClient<EndorseGetPayload<T> | Null>;

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Feedback base type for findUnique actions
   */
  export type FeedbackFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
    /**
     * Filter, which Feedback to fetch.
     * 
    **/
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUnique
   */
  export interface FeedbackFindUniqueArgs extends FeedbackFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
    /**
     * Filter, which Feedback to fetch.
     * 
    **/
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback base type for findFirst actions
   */
  export type FeedbackFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
    /**
     * Filter, which Feedback to fetch.
     * 
    **/
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     * 
    **/
    orderBy?: Enumerable<FeedbackOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     * 
    **/
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     * 
    **/
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }

  /**
   * Feedback findFirst
   */
  export interface FeedbackFindFirstArgs extends FeedbackFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
    /**
     * Filter, which Feedback to fetch.
     * 
    **/
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     * 
    **/
    orderBy?: Enumerable<FeedbackOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     * 
    **/
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     * 
    **/
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }


  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
    /**
     * Filter, which Feedbacks to fetch.
     * 
    **/
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     * 
    **/
    orderBy?: Enumerable<FeedbackOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     * 
    **/
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }


  /**
   * Feedback create
   */
  export type FeedbackCreateArgs = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
    /**
     * The data needed to create a Feedback.
     * 
    **/
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }


  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs = {
    /**
     * The data used to create many Feedbacks.
     * 
    **/
    data: Enumerable<FeedbackCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
    /**
     * The data needed to update a Feedback.
     * 
    **/
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     * 
    **/
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs = {
    /**
     * The data used to update Feedbacks.
     * 
    **/
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     * 
    **/
    where?: FeedbackWhereInput
  }


  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     * 
    **/
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     * 
    **/
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }


  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
    /**
     * Filter which Feedback to delete.
     * 
    **/
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs = {
    /**
     * Filter which Feedbacks to delete
     * 
    **/
    where?: FeedbackWhereInput
  }


  /**
   * Feedback without action
   */
  export type FeedbackArgs = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
  }



  /**
   * Model Interviewer
   */


  export type AggregateInterviewer = {
    _count: InterviewerCountAggregateOutputType | null
    _min: InterviewerMinAggregateOutputType | null
    _max: InterviewerMaxAggregateOutputType | null
  }

  export type InterviewerMinAggregateOutputType = {
    interviewerID: string | null
    createdAt: Date | null
    userID: string | null
  }

  export type InterviewerMaxAggregateOutputType = {
    interviewerID: string | null
    createdAt: Date | null
    userID: string | null
  }

  export type InterviewerCountAggregateOutputType = {
    interviewerID: number
    createdAt: number
    userID: number
    _all: number
  }


  export type InterviewerMinAggregateInputType = {
    interviewerID?: true
    createdAt?: true
    userID?: true
  }

  export type InterviewerMaxAggregateInputType = {
    interviewerID?: true
    createdAt?: true
    userID?: true
  }

  export type InterviewerCountAggregateInputType = {
    interviewerID?: true
    createdAt?: true
    userID?: true
    _all?: true
  }

  export type InterviewerAggregateArgs = {
    /**
     * Filter which Interviewer to aggregate.
     * 
    **/
    where?: InterviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviewers to fetch.
     * 
    **/
    orderBy?: Enumerable<InterviewerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: InterviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviewers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviewers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interviewers
    **/
    _count?: true | InterviewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewerMaxAggregateInputType
  }

  export type GetInterviewerAggregateType<T extends InterviewerAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewer[P]>
      : GetScalarType<T[P], AggregateInterviewer[P]>
  }




  export type InterviewerGroupByArgs = {
    where?: InterviewerWhereInput
    orderBy?: Enumerable<InterviewerOrderByWithAggregationInput>
    by: Array<InterviewerScalarFieldEnum>
    having?: InterviewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewerCountAggregateInputType | true
    _min?: InterviewerMinAggregateInputType
    _max?: InterviewerMaxAggregateInputType
  }


  export type InterviewerGroupByOutputType = {
    interviewerID: string
    createdAt: Date
    userID: string
    _count: InterviewerCountAggregateOutputType | null
    _min: InterviewerMinAggregateOutputType | null
    _max: InterviewerMaxAggregateOutputType | null
  }

  type GetInterviewerGroupByPayload<T extends InterviewerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InterviewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewerGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewerGroupByOutputType[P]>
        }
      >
    >


  export type InterviewerSelect = {
    interviewerID?: boolean
    createdAt?: boolean
    userID?: boolean
    User?: boolean | UserArgs
    Applicant?: boolean | ApplicantArgs
  }


  export type InterviewerInclude = {
    User?: boolean | UserArgs
    Applicant?: boolean | ApplicantArgs
  } 

  export type InterviewerGetPayload<S extends boolean | null | undefined | InterviewerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Interviewer :
    S extends undefined ? never :
    S extends { include: any } & (InterviewerArgs | InterviewerFindManyArgs)
    ? Interviewer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'Applicant' ? ApplicantGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (InterviewerArgs | InterviewerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'Applicant' ? ApplicantGetPayload<S['select'][P]> | null :  P extends keyof Interviewer ? Interviewer[P] : never
  } 
      : Interviewer


  type InterviewerCountArgs = Merge<
    Omit<InterviewerFindManyArgs, 'select' | 'include'> & {
      select?: InterviewerCountAggregateInputType | true
    }
  >

  export interface InterviewerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Interviewer that matches the filter.
     * @param {InterviewerFindUniqueArgs} args - Arguments to find a Interviewer
     * @example
     * // Get one Interviewer
     * const interviewer = await prisma.interviewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InterviewerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InterviewerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Interviewer'> extends True ? Prisma__InterviewerClient<InterviewerGetPayload<T>> : Prisma__InterviewerClient<InterviewerGetPayload<T> | null, null>

    /**
     * Find one Interviewer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InterviewerFindUniqueOrThrowArgs} args - Arguments to find a Interviewer
     * @example
     * // Get one Interviewer
     * const interviewer = await prisma.interviewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InterviewerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, InterviewerFindUniqueOrThrowArgs>
    ): Prisma__InterviewerClient<InterviewerGetPayload<T>>

    /**
     * Find the first Interviewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewerFindFirstArgs} args - Arguments to find a Interviewer
     * @example
     * // Get one Interviewer
     * const interviewer = await prisma.interviewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InterviewerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InterviewerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Interviewer'> extends True ? Prisma__InterviewerClient<InterviewerGetPayload<T>> : Prisma__InterviewerClient<InterviewerGetPayload<T> | null, null>

    /**
     * Find the first Interviewer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewerFindFirstOrThrowArgs} args - Arguments to find a Interviewer
     * @example
     * // Get one Interviewer
     * const interviewer = await prisma.interviewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InterviewerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, InterviewerFindFirstOrThrowArgs>
    ): Prisma__InterviewerClient<InterviewerGetPayload<T>>

    /**
     * Find zero or more Interviewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interviewers
     * const interviewers = await prisma.interviewer.findMany()
     * 
     * // Get first 10 Interviewers
     * const interviewers = await prisma.interviewer.findMany({ take: 10 })
     * 
     * // Only select the `interviewerID`
     * const interviewerWithInterviewerIDOnly = await prisma.interviewer.findMany({ select: { interviewerID: true } })
     * 
    **/
    findMany<T extends InterviewerFindManyArgs>(
      args?: SelectSubset<T, InterviewerFindManyArgs>
    ): PrismaPromise<Array<InterviewerGetPayload<T>>>

    /**
     * Create a Interviewer.
     * @param {InterviewerCreateArgs} args - Arguments to create a Interviewer.
     * @example
     * // Create one Interviewer
     * const Interviewer = await prisma.interviewer.create({
     *   data: {
     *     // ... data to create a Interviewer
     *   }
     * })
     * 
    **/
    create<T extends InterviewerCreateArgs>(
      args: SelectSubset<T, InterviewerCreateArgs>
    ): Prisma__InterviewerClient<InterviewerGetPayload<T>>

    /**
     * Create many Interviewers.
     *     @param {InterviewerCreateManyArgs} args - Arguments to create many Interviewers.
     *     @example
     *     // Create many Interviewers
     *     const interviewer = await prisma.interviewer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InterviewerCreateManyArgs>(
      args?: SelectSubset<T, InterviewerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Interviewer.
     * @param {InterviewerDeleteArgs} args - Arguments to delete one Interviewer.
     * @example
     * // Delete one Interviewer
     * const Interviewer = await prisma.interviewer.delete({
     *   where: {
     *     // ... filter to delete one Interviewer
     *   }
     * })
     * 
    **/
    delete<T extends InterviewerDeleteArgs>(
      args: SelectSubset<T, InterviewerDeleteArgs>
    ): Prisma__InterviewerClient<InterviewerGetPayload<T>>

    /**
     * Update one Interviewer.
     * @param {InterviewerUpdateArgs} args - Arguments to update one Interviewer.
     * @example
     * // Update one Interviewer
     * const interviewer = await prisma.interviewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InterviewerUpdateArgs>(
      args: SelectSubset<T, InterviewerUpdateArgs>
    ): Prisma__InterviewerClient<InterviewerGetPayload<T>>

    /**
     * Delete zero or more Interviewers.
     * @param {InterviewerDeleteManyArgs} args - Arguments to filter Interviewers to delete.
     * @example
     * // Delete a few Interviewers
     * const { count } = await prisma.interviewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InterviewerDeleteManyArgs>(
      args?: SelectSubset<T, InterviewerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interviewers
     * const interviewer = await prisma.interviewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InterviewerUpdateManyArgs>(
      args: SelectSubset<T, InterviewerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Interviewer.
     * @param {InterviewerUpsertArgs} args - Arguments to update or create a Interviewer.
     * @example
     * // Update or create a Interviewer
     * const interviewer = await prisma.interviewer.upsert({
     *   create: {
     *     // ... data to create a Interviewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interviewer we want to update
     *   }
     * })
    **/
    upsert<T extends InterviewerUpsertArgs>(
      args: SelectSubset<T, InterviewerUpsertArgs>
    ): Prisma__InterviewerClient<InterviewerGetPayload<T>>

    /**
     * Count the number of Interviewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewerCountArgs} args - Arguments to filter Interviewers to count.
     * @example
     * // Count the number of Interviewers
     * const count = await prisma.interviewer.count({
     *   where: {
     *     // ... the filter for the Interviewers we want to count
     *   }
     * })
    **/
    count<T extends InterviewerCountArgs>(
      args?: Subset<T, InterviewerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewerAggregateArgs>(args: Subset<T, InterviewerAggregateArgs>): PrismaPromise<GetInterviewerAggregateType<T>>

    /**
     * Group by Interviewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewerGroupByArgs['orderBy'] }
        : { orderBy?: InterviewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewerGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Interviewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InterviewerClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    Applicant<T extends ApplicantArgs= {}>(args?: Subset<T, ApplicantArgs>): Prisma__ApplicantClient<ApplicantGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Interviewer base type for findUnique actions
   */
  export type InterviewerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Interviewer
     * 
    **/
    select?: InterviewerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InterviewerInclude | null
    /**
     * Filter, which Interviewer to fetch.
     * 
    **/
    where: InterviewerWhereUniqueInput
  }

  /**
   * Interviewer findUnique
   */
  export interface InterviewerFindUniqueArgs extends InterviewerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Interviewer findUniqueOrThrow
   */
  export type InterviewerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Interviewer
     * 
    **/
    select?: InterviewerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InterviewerInclude | null
    /**
     * Filter, which Interviewer to fetch.
     * 
    **/
    where: InterviewerWhereUniqueInput
  }


  /**
   * Interviewer base type for findFirst actions
   */
  export type InterviewerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Interviewer
     * 
    **/
    select?: InterviewerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InterviewerInclude | null
    /**
     * Filter, which Interviewer to fetch.
     * 
    **/
    where?: InterviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviewers to fetch.
     * 
    **/
    orderBy?: Enumerable<InterviewerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviewers.
     * 
    **/
    cursor?: InterviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviewers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviewers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviewers.
     * 
    **/
    distinct?: Enumerable<InterviewerScalarFieldEnum>
  }

  /**
   * Interviewer findFirst
   */
  export interface InterviewerFindFirstArgs extends InterviewerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Interviewer findFirstOrThrow
   */
  export type InterviewerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Interviewer
     * 
    **/
    select?: InterviewerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InterviewerInclude | null
    /**
     * Filter, which Interviewer to fetch.
     * 
    **/
    where?: InterviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviewers to fetch.
     * 
    **/
    orderBy?: Enumerable<InterviewerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviewers.
     * 
    **/
    cursor?: InterviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviewers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviewers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviewers.
     * 
    **/
    distinct?: Enumerable<InterviewerScalarFieldEnum>
  }


  /**
   * Interviewer findMany
   */
  export type InterviewerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Interviewer
     * 
    **/
    select?: InterviewerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InterviewerInclude | null
    /**
     * Filter, which Interviewers to fetch.
     * 
    **/
    where?: InterviewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviewers to fetch.
     * 
    **/
    orderBy?: Enumerable<InterviewerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interviewers.
     * 
    **/
    cursor?: InterviewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviewers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviewers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<InterviewerScalarFieldEnum>
  }


  /**
   * Interviewer create
   */
  export type InterviewerCreateArgs = {
    /**
     * Select specific fields to fetch from the Interviewer
     * 
    **/
    select?: InterviewerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InterviewerInclude | null
    /**
     * The data needed to create a Interviewer.
     * 
    **/
    data: XOR<InterviewerCreateInput, InterviewerUncheckedCreateInput>
  }


  /**
   * Interviewer createMany
   */
  export type InterviewerCreateManyArgs = {
    /**
     * The data used to create many Interviewers.
     * 
    **/
    data: Enumerable<InterviewerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Interviewer update
   */
  export type InterviewerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Interviewer
     * 
    **/
    select?: InterviewerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InterviewerInclude | null
    /**
     * The data needed to update a Interviewer.
     * 
    **/
    data: XOR<InterviewerUpdateInput, InterviewerUncheckedUpdateInput>
    /**
     * Choose, which Interviewer to update.
     * 
    **/
    where: InterviewerWhereUniqueInput
  }


  /**
   * Interviewer updateMany
   */
  export type InterviewerUpdateManyArgs = {
    /**
     * The data used to update Interviewers.
     * 
    **/
    data: XOR<InterviewerUpdateManyMutationInput, InterviewerUncheckedUpdateManyInput>
    /**
     * Filter which Interviewers to update
     * 
    **/
    where?: InterviewerWhereInput
  }


  /**
   * Interviewer upsert
   */
  export type InterviewerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Interviewer
     * 
    **/
    select?: InterviewerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InterviewerInclude | null
    /**
     * The filter to search for the Interviewer to update in case it exists.
     * 
    **/
    where: InterviewerWhereUniqueInput
    /**
     * In case the Interviewer found by the `where` argument doesn't exist, create a new Interviewer with this data.
     * 
    **/
    create: XOR<InterviewerCreateInput, InterviewerUncheckedCreateInput>
    /**
     * In case the Interviewer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<InterviewerUpdateInput, InterviewerUncheckedUpdateInput>
  }


  /**
   * Interviewer delete
   */
  export type InterviewerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Interviewer
     * 
    **/
    select?: InterviewerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InterviewerInclude | null
    /**
     * Filter which Interviewer to delete.
     * 
    **/
    where: InterviewerWhereUniqueInput
  }


  /**
   * Interviewer deleteMany
   */
  export type InterviewerDeleteManyArgs = {
    /**
     * Filter which Interviewers to delete
     * 
    **/
    where?: InterviewerWhereInput
  }


  /**
   * Interviewer without action
   */
  export type InterviewerArgs = {
    /**
     * Select specific fields to fetch from the Interviewer
     * 
    **/
    select?: InterviewerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: InterviewerInclude | null
  }



  /**
   * Model Applicant
   */


  export type AggregateApplicant = {
    _count: ApplicantCountAggregateOutputType | null
    _min: ApplicantMinAggregateOutputType | null
    _max: ApplicantMaxAggregateOutputType | null
  }

  export type ApplicantMinAggregateOutputType = {
    applicantID: string | null
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: applicantStatus | null
    jobPostID: string | null
    interviewerID: string | null
    endorsementID: string | null
    notificaitonID: string | null
  }

  export type ApplicantMaxAggregateOutputType = {
    applicantID: string | null
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: applicantStatus | null
    jobPostID: string | null
    interviewerID: string | null
    endorsementID: string | null
    notificaitonID: string | null
  }

  export type ApplicantCountAggregateOutputType = {
    applicantID: number
    id: number
    email: number
    createdAt: number
    updatedAt: number
    status: number
    jobPostID: number
    interviewerID: number
    endorsementID: number
    notificaitonID: number
    _all: number
  }


  export type ApplicantMinAggregateInputType = {
    applicantID?: true
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    jobPostID?: true
    interviewerID?: true
    endorsementID?: true
    notificaitonID?: true
  }

  export type ApplicantMaxAggregateInputType = {
    applicantID?: true
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    jobPostID?: true
    interviewerID?: true
    endorsementID?: true
    notificaitonID?: true
  }

  export type ApplicantCountAggregateInputType = {
    applicantID?: true
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    jobPostID?: true
    interviewerID?: true
    endorsementID?: true
    notificaitonID?: true
    _all?: true
  }

  export type ApplicantAggregateArgs = {
    /**
     * Filter which Applicant to aggregate.
     * 
    **/
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     * 
    **/
    orderBy?: Enumerable<ApplicantOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applicants
    **/
    _count?: true | ApplicantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicantMaxAggregateInputType
  }

  export type GetApplicantAggregateType<T extends ApplicantAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicant[P]>
      : GetScalarType<T[P], AggregateApplicant[P]>
  }




  export type ApplicantGroupByArgs = {
    where?: ApplicantWhereInput
    orderBy?: Enumerable<ApplicantOrderByWithAggregationInput>
    by: Array<ApplicantScalarFieldEnum>
    having?: ApplicantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicantCountAggregateInputType | true
    _min?: ApplicantMinAggregateInputType
    _max?: ApplicantMaxAggregateInputType
  }


  export type ApplicantGroupByOutputType = {
    applicantID: string
    id: string
    email: string
    createdAt: Date
    updatedAt: Date
    status: applicantStatus
    jobPostID: string
    interviewerID: string | null
    endorsementID: string | null
    notificaitonID: string | null
    _count: ApplicantCountAggregateOutputType | null
    _min: ApplicantMinAggregateOutputType | null
    _max: ApplicantMaxAggregateOutputType | null
  }

  type GetApplicantGroupByPayload<T extends ApplicantGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ApplicantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicantGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicantGroupByOutputType[P]>
        }
      >
    >


  export type ApplicantSelect = {
    applicantID?: boolean
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    jobPostID?: boolean
    interviewerID?: boolean
    interviewer?: boolean | InterviewerArgs
    JobPost?: boolean | JobPostArgs
    Endorsement?: boolean | EndorsementArgs
    endorsementID?: boolean
    Profile?: boolean | ProfileArgs
    FileUpload?: boolean | UploadFileArgs
    Notification?: boolean | NotificationArgs
    notificaitonID?: boolean
    Feedback?: boolean | Applicant$FeedbackArgs
    _count?: boolean | ApplicantCountOutputTypeArgs
  }


  export type ApplicantInclude = {
    interviewer?: boolean | InterviewerArgs
    JobPost?: boolean | JobPostArgs
    Endorsement?: boolean | EndorsementArgs
    Profile?: boolean | ProfileArgs
    FileUpload?: boolean | UploadFileArgs
    Notification?: boolean | NotificationArgs
    Feedback?: boolean | Applicant$FeedbackArgs
    _count?: boolean | ApplicantCountOutputTypeArgs
  } 

  export type ApplicantGetPayload<S extends boolean | null | undefined | ApplicantArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Applicant :
    S extends undefined ? never :
    S extends { include: any } & (ApplicantArgs | ApplicantFindManyArgs)
    ? Applicant  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'interviewer' ? InterviewerGetPayload<S['include'][P]> | null :
        P extends 'JobPost' ? JobPostGetPayload<S['include'][P]> :
        P extends 'Endorsement' ? EndorsementGetPayload<S['include'][P]> | null :
        P extends 'Profile' ? ProfileGetPayload<S['include'][P]> | null :
        P extends 'FileUpload' ? UploadFileGetPayload<S['include'][P]> | null :
        P extends 'Notification' ? NotificationGetPayload<S['include'][P]> | null :
        P extends 'Feedback' ? Array < FeedbackGetPayload<S['include'][P]>>  :
        P extends '_count' ? ApplicantCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ApplicantArgs | ApplicantFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'interviewer' ? InterviewerGetPayload<S['select'][P]> | null :
        P extends 'JobPost' ? JobPostGetPayload<S['select'][P]> :
        P extends 'Endorsement' ? EndorsementGetPayload<S['select'][P]> | null :
        P extends 'Profile' ? ProfileGetPayload<S['select'][P]> | null :
        P extends 'FileUpload' ? UploadFileGetPayload<S['select'][P]> | null :
        P extends 'Notification' ? NotificationGetPayload<S['select'][P]> | null :
        P extends 'Feedback' ? Array < FeedbackGetPayload<S['select'][P]>>  :
        P extends '_count' ? ApplicantCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Applicant ? Applicant[P] : never
  } 
      : Applicant


  type ApplicantCountArgs = Merge<
    Omit<ApplicantFindManyArgs, 'select' | 'include'> & {
      select?: ApplicantCountAggregateInputType | true
    }
  >

  export interface ApplicantDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Applicant that matches the filter.
     * @param {ApplicantFindUniqueArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ApplicantFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ApplicantFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Applicant'> extends True ? Prisma__ApplicantClient<ApplicantGetPayload<T>> : Prisma__ApplicantClient<ApplicantGetPayload<T> | null, null>

    /**
     * Find one Applicant that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ApplicantFindUniqueOrThrowArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ApplicantFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ApplicantFindUniqueOrThrowArgs>
    ): Prisma__ApplicantClient<ApplicantGetPayload<T>>

    /**
     * Find the first Applicant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindFirstArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ApplicantFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ApplicantFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Applicant'> extends True ? Prisma__ApplicantClient<ApplicantGetPayload<T>> : Prisma__ApplicantClient<ApplicantGetPayload<T> | null, null>

    /**
     * Find the first Applicant that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindFirstOrThrowArgs} args - Arguments to find a Applicant
     * @example
     * // Get one Applicant
     * const applicant = await prisma.applicant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ApplicantFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ApplicantFindFirstOrThrowArgs>
    ): Prisma__ApplicantClient<ApplicantGetPayload<T>>

    /**
     * Find zero or more Applicants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicants
     * const applicants = await prisma.applicant.findMany()
     * 
     * // Get first 10 Applicants
     * const applicants = await prisma.applicant.findMany({ take: 10 })
     * 
     * // Only select the `applicantID`
     * const applicantWithApplicantIDOnly = await prisma.applicant.findMany({ select: { applicantID: true } })
     * 
    **/
    findMany<T extends ApplicantFindManyArgs>(
      args?: SelectSubset<T, ApplicantFindManyArgs>
    ): PrismaPromise<Array<ApplicantGetPayload<T>>>

    /**
     * Create a Applicant.
     * @param {ApplicantCreateArgs} args - Arguments to create a Applicant.
     * @example
     * // Create one Applicant
     * const Applicant = await prisma.applicant.create({
     *   data: {
     *     // ... data to create a Applicant
     *   }
     * })
     * 
    **/
    create<T extends ApplicantCreateArgs>(
      args: SelectSubset<T, ApplicantCreateArgs>
    ): Prisma__ApplicantClient<ApplicantGetPayload<T>>

    /**
     * Create many Applicants.
     *     @param {ApplicantCreateManyArgs} args - Arguments to create many Applicants.
     *     @example
     *     // Create many Applicants
     *     const applicant = await prisma.applicant.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ApplicantCreateManyArgs>(
      args?: SelectSubset<T, ApplicantCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Applicant.
     * @param {ApplicantDeleteArgs} args - Arguments to delete one Applicant.
     * @example
     * // Delete one Applicant
     * const Applicant = await prisma.applicant.delete({
     *   where: {
     *     // ... filter to delete one Applicant
     *   }
     * })
     * 
    **/
    delete<T extends ApplicantDeleteArgs>(
      args: SelectSubset<T, ApplicantDeleteArgs>
    ): Prisma__ApplicantClient<ApplicantGetPayload<T>>

    /**
     * Update one Applicant.
     * @param {ApplicantUpdateArgs} args - Arguments to update one Applicant.
     * @example
     * // Update one Applicant
     * const applicant = await prisma.applicant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ApplicantUpdateArgs>(
      args: SelectSubset<T, ApplicantUpdateArgs>
    ): Prisma__ApplicantClient<ApplicantGetPayload<T>>

    /**
     * Delete zero or more Applicants.
     * @param {ApplicantDeleteManyArgs} args - Arguments to filter Applicants to delete.
     * @example
     * // Delete a few Applicants
     * const { count } = await prisma.applicant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ApplicantDeleteManyArgs>(
      args?: SelectSubset<T, ApplicantDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicants
     * const applicant = await prisma.applicant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ApplicantUpdateManyArgs>(
      args: SelectSubset<T, ApplicantUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Applicant.
     * @param {ApplicantUpsertArgs} args - Arguments to update or create a Applicant.
     * @example
     * // Update or create a Applicant
     * const applicant = await prisma.applicant.upsert({
     *   create: {
     *     // ... data to create a Applicant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicant we want to update
     *   }
     * })
    **/
    upsert<T extends ApplicantUpsertArgs>(
      args: SelectSubset<T, ApplicantUpsertArgs>
    ): Prisma__ApplicantClient<ApplicantGetPayload<T>>

    /**
     * Count the number of Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantCountArgs} args - Arguments to filter Applicants to count.
     * @example
     * // Count the number of Applicants
     * const count = await prisma.applicant.count({
     *   where: {
     *     // ... the filter for the Applicants we want to count
     *   }
     * })
    **/
    count<T extends ApplicantCountArgs>(
      args?: Subset<T, ApplicantCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicantAggregateArgs>(args: Subset<T, ApplicantAggregateArgs>): PrismaPromise<GetApplicantAggregateType<T>>

    /**
     * Group by Applicant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicantGroupByArgs['orderBy'] }
        : { orderBy?: ApplicantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicantGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Applicant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ApplicantClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    interviewer<T extends InterviewerArgs= {}>(args?: Subset<T, InterviewerArgs>): Prisma__InterviewerClient<InterviewerGetPayload<T> | Null>;

    JobPost<T extends JobPostArgs= {}>(args?: Subset<T, JobPostArgs>): Prisma__JobPostClient<JobPostGetPayload<T> | Null>;

    Endorsement<T extends EndorsementArgs= {}>(args?: Subset<T, EndorsementArgs>): Prisma__EndorsementClient<EndorsementGetPayload<T> | Null>;

    Profile<T extends ProfileArgs= {}>(args?: Subset<T, ProfileArgs>): Prisma__ProfileClient<ProfileGetPayload<T> | Null>;

    FileUpload<T extends UploadFileArgs= {}>(args?: Subset<T, UploadFileArgs>): Prisma__UploadFileClient<UploadFileGetPayload<T> | Null>;

    Notification<T extends NotificationArgs= {}>(args?: Subset<T, NotificationArgs>): Prisma__NotificationClient<NotificationGetPayload<T> | Null>;

    Feedback<T extends Applicant$FeedbackArgs= {}>(args?: Subset<T, Applicant$FeedbackArgs>): PrismaPromise<Array<FeedbackGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Applicant base type for findUnique actions
   */
  export type ApplicantFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
    /**
     * Filter, which Applicant to fetch.
     * 
    **/
    where: ApplicantWhereUniqueInput
  }

  /**
   * Applicant findUnique
   */
  export interface ApplicantFindUniqueArgs extends ApplicantFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Applicant findUniqueOrThrow
   */
  export type ApplicantFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
    /**
     * Filter, which Applicant to fetch.
     * 
    **/
    where: ApplicantWhereUniqueInput
  }


  /**
   * Applicant base type for findFirst actions
   */
  export type ApplicantFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
    /**
     * Filter, which Applicant to fetch.
     * 
    **/
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     * 
    **/
    orderBy?: Enumerable<ApplicantOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applicants.
     * 
    **/
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applicants.
     * 
    **/
    distinct?: Enumerable<ApplicantScalarFieldEnum>
  }

  /**
   * Applicant findFirst
   */
  export interface ApplicantFindFirstArgs extends ApplicantFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Applicant findFirstOrThrow
   */
  export type ApplicantFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
    /**
     * Filter, which Applicant to fetch.
     * 
    **/
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     * 
    **/
    orderBy?: Enumerable<ApplicantOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applicants.
     * 
    **/
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applicants.
     * 
    **/
    distinct?: Enumerable<ApplicantScalarFieldEnum>
  }


  /**
   * Applicant findMany
   */
  export type ApplicantFindManyArgs = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
    /**
     * Filter, which Applicants to fetch.
     * 
    **/
    where?: ApplicantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applicants to fetch.
     * 
    **/
    orderBy?: Enumerable<ApplicantOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applicants.
     * 
    **/
    cursor?: ApplicantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applicants from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applicants.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ApplicantScalarFieldEnum>
  }


  /**
   * Applicant create
   */
  export type ApplicantCreateArgs = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
    /**
     * The data needed to create a Applicant.
     * 
    **/
    data: XOR<ApplicantCreateInput, ApplicantUncheckedCreateInput>
  }


  /**
   * Applicant createMany
   */
  export type ApplicantCreateManyArgs = {
    /**
     * The data used to create many Applicants.
     * 
    **/
    data: Enumerable<ApplicantCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Applicant update
   */
  export type ApplicantUpdateArgs = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
    /**
     * The data needed to update a Applicant.
     * 
    **/
    data: XOR<ApplicantUpdateInput, ApplicantUncheckedUpdateInput>
    /**
     * Choose, which Applicant to update.
     * 
    **/
    where: ApplicantWhereUniqueInput
  }


  /**
   * Applicant updateMany
   */
  export type ApplicantUpdateManyArgs = {
    /**
     * The data used to update Applicants.
     * 
    **/
    data: XOR<ApplicantUpdateManyMutationInput, ApplicantUncheckedUpdateManyInput>
    /**
     * Filter which Applicants to update
     * 
    **/
    where?: ApplicantWhereInput
  }


  /**
   * Applicant upsert
   */
  export type ApplicantUpsertArgs = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
    /**
     * The filter to search for the Applicant to update in case it exists.
     * 
    **/
    where: ApplicantWhereUniqueInput
    /**
     * In case the Applicant found by the `where` argument doesn't exist, create a new Applicant with this data.
     * 
    **/
    create: XOR<ApplicantCreateInput, ApplicantUncheckedCreateInput>
    /**
     * In case the Applicant was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ApplicantUpdateInput, ApplicantUncheckedUpdateInput>
  }


  /**
   * Applicant delete
   */
  export type ApplicantDeleteArgs = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
    /**
     * Filter which Applicant to delete.
     * 
    **/
    where: ApplicantWhereUniqueInput
  }


  /**
   * Applicant deleteMany
   */
  export type ApplicantDeleteManyArgs = {
    /**
     * Filter which Applicants to delete
     * 
    **/
    where?: ApplicantWhereInput
  }


  /**
   * Applicant.Feedback
   */
  export type Applicant$FeedbackArgs = {
    /**
     * Select specific fields to fetch from the Feedback
     * 
    **/
    select?: FeedbackSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FeedbackInclude | null
    where?: FeedbackWhereInput
    orderBy?: Enumerable<FeedbackOrderByWithRelationAndSearchRelevanceInput>
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FeedbackScalarFieldEnum>
  }


  /**
   * Applicant without action
   */
  export type ApplicantArgs = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
  }



  /**
   * Model UploadFile
   */


  export type AggregateUploadFile = {
    _count: UploadFileCountAggregateOutputType | null
    _min: UploadFileMinAggregateOutputType | null
    _max: UploadFileMaxAggregateOutputType | null
  }

  export type UploadFileMinAggregateOutputType = {
    uploadFileID: string | null
    file: string | null
    video: string | null
    createdAt: Date | null
    applicantID: string | null
  }

  export type UploadFileMaxAggregateOutputType = {
    uploadFileID: string | null
    file: string | null
    video: string | null
    createdAt: Date | null
    applicantID: string | null
  }

  export type UploadFileCountAggregateOutputType = {
    uploadFileID: number
    file: number
    video: number
    createdAt: number
    applicantID: number
    _all: number
  }


  export type UploadFileMinAggregateInputType = {
    uploadFileID?: true
    file?: true
    video?: true
    createdAt?: true
    applicantID?: true
  }

  export type UploadFileMaxAggregateInputType = {
    uploadFileID?: true
    file?: true
    video?: true
    createdAt?: true
    applicantID?: true
  }

  export type UploadFileCountAggregateInputType = {
    uploadFileID?: true
    file?: true
    video?: true
    createdAt?: true
    applicantID?: true
    _all?: true
  }

  export type UploadFileAggregateArgs = {
    /**
     * Filter which UploadFile to aggregate.
     * 
    **/
    where?: UploadFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadFiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UploadFileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UploadFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadFiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadFiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UploadFiles
    **/
    _count?: true | UploadFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UploadFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UploadFileMaxAggregateInputType
  }

  export type GetUploadFileAggregateType<T extends UploadFileAggregateArgs> = {
        [P in keyof T & keyof AggregateUploadFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUploadFile[P]>
      : GetScalarType<T[P], AggregateUploadFile[P]>
  }




  export type UploadFileGroupByArgs = {
    where?: UploadFileWhereInput
    orderBy?: Enumerable<UploadFileOrderByWithAggregationInput>
    by: Array<UploadFileScalarFieldEnum>
    having?: UploadFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UploadFileCountAggregateInputType | true
    _min?: UploadFileMinAggregateInputType
    _max?: UploadFileMaxAggregateInputType
  }


  export type UploadFileGroupByOutputType = {
    uploadFileID: string
    file: string
    video: string
    createdAt: Date
    applicantID: string | null
    _count: UploadFileCountAggregateOutputType | null
    _min: UploadFileMinAggregateOutputType | null
    _max: UploadFileMaxAggregateOutputType | null
  }

  type GetUploadFileGroupByPayload<T extends UploadFileGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UploadFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UploadFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UploadFileGroupByOutputType[P]>
            : GetScalarType<T[P], UploadFileGroupByOutputType[P]>
        }
      >
    >


  export type UploadFileSelect = {
    uploadFileID?: boolean
    file?: boolean
    video?: boolean
    createdAt?: boolean
    applicantID?: boolean
    Applicant?: boolean | ApplicantArgs
  }


  export type UploadFileInclude = {
    Applicant?: boolean | ApplicantArgs
  } 

  export type UploadFileGetPayload<S extends boolean | null | undefined | UploadFileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UploadFile :
    S extends undefined ? never :
    S extends { include: any } & (UploadFileArgs | UploadFileFindManyArgs)
    ? UploadFile  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Applicant' ? ApplicantGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (UploadFileArgs | UploadFileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Applicant' ? ApplicantGetPayload<S['select'][P]> | null :  P extends keyof UploadFile ? UploadFile[P] : never
  } 
      : UploadFile


  type UploadFileCountArgs = Merge<
    Omit<UploadFileFindManyArgs, 'select' | 'include'> & {
      select?: UploadFileCountAggregateInputType | true
    }
  >

  export interface UploadFileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one UploadFile that matches the filter.
     * @param {UploadFileFindUniqueArgs} args - Arguments to find a UploadFile
     * @example
     * // Get one UploadFile
     * const uploadFile = await prisma.uploadFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UploadFileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UploadFileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UploadFile'> extends True ? Prisma__UploadFileClient<UploadFileGetPayload<T>> : Prisma__UploadFileClient<UploadFileGetPayload<T> | null, null>

    /**
     * Find one UploadFile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UploadFileFindUniqueOrThrowArgs} args - Arguments to find a UploadFile
     * @example
     * // Get one UploadFile
     * const uploadFile = await prisma.uploadFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UploadFileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UploadFileFindUniqueOrThrowArgs>
    ): Prisma__UploadFileClient<UploadFileGetPayload<T>>

    /**
     * Find the first UploadFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFileFindFirstArgs} args - Arguments to find a UploadFile
     * @example
     * // Get one UploadFile
     * const uploadFile = await prisma.uploadFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UploadFileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UploadFileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UploadFile'> extends True ? Prisma__UploadFileClient<UploadFileGetPayload<T>> : Prisma__UploadFileClient<UploadFileGetPayload<T> | null, null>

    /**
     * Find the first UploadFile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFileFindFirstOrThrowArgs} args - Arguments to find a UploadFile
     * @example
     * // Get one UploadFile
     * const uploadFile = await prisma.uploadFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UploadFileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UploadFileFindFirstOrThrowArgs>
    ): Prisma__UploadFileClient<UploadFileGetPayload<T>>

    /**
     * Find zero or more UploadFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UploadFiles
     * const uploadFiles = await prisma.uploadFile.findMany()
     * 
     * // Get first 10 UploadFiles
     * const uploadFiles = await prisma.uploadFile.findMany({ take: 10 })
     * 
     * // Only select the `uploadFileID`
     * const uploadFileWithUploadFileIDOnly = await prisma.uploadFile.findMany({ select: { uploadFileID: true } })
     * 
    **/
    findMany<T extends UploadFileFindManyArgs>(
      args?: SelectSubset<T, UploadFileFindManyArgs>
    ): PrismaPromise<Array<UploadFileGetPayload<T>>>

    /**
     * Create a UploadFile.
     * @param {UploadFileCreateArgs} args - Arguments to create a UploadFile.
     * @example
     * // Create one UploadFile
     * const UploadFile = await prisma.uploadFile.create({
     *   data: {
     *     // ... data to create a UploadFile
     *   }
     * })
     * 
    **/
    create<T extends UploadFileCreateArgs>(
      args: SelectSubset<T, UploadFileCreateArgs>
    ): Prisma__UploadFileClient<UploadFileGetPayload<T>>

    /**
     * Create many UploadFiles.
     *     @param {UploadFileCreateManyArgs} args - Arguments to create many UploadFiles.
     *     @example
     *     // Create many UploadFiles
     *     const uploadFile = await prisma.uploadFile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UploadFileCreateManyArgs>(
      args?: SelectSubset<T, UploadFileCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UploadFile.
     * @param {UploadFileDeleteArgs} args - Arguments to delete one UploadFile.
     * @example
     * // Delete one UploadFile
     * const UploadFile = await prisma.uploadFile.delete({
     *   where: {
     *     // ... filter to delete one UploadFile
     *   }
     * })
     * 
    **/
    delete<T extends UploadFileDeleteArgs>(
      args: SelectSubset<T, UploadFileDeleteArgs>
    ): Prisma__UploadFileClient<UploadFileGetPayload<T>>

    /**
     * Update one UploadFile.
     * @param {UploadFileUpdateArgs} args - Arguments to update one UploadFile.
     * @example
     * // Update one UploadFile
     * const uploadFile = await prisma.uploadFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UploadFileUpdateArgs>(
      args: SelectSubset<T, UploadFileUpdateArgs>
    ): Prisma__UploadFileClient<UploadFileGetPayload<T>>

    /**
     * Delete zero or more UploadFiles.
     * @param {UploadFileDeleteManyArgs} args - Arguments to filter UploadFiles to delete.
     * @example
     * // Delete a few UploadFiles
     * const { count } = await prisma.uploadFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UploadFileDeleteManyArgs>(
      args?: SelectSubset<T, UploadFileDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UploadFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UploadFiles
     * const uploadFile = await prisma.uploadFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UploadFileUpdateManyArgs>(
      args: SelectSubset<T, UploadFileUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UploadFile.
     * @param {UploadFileUpsertArgs} args - Arguments to update or create a UploadFile.
     * @example
     * // Update or create a UploadFile
     * const uploadFile = await prisma.uploadFile.upsert({
     *   create: {
     *     // ... data to create a UploadFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UploadFile we want to update
     *   }
     * })
    **/
    upsert<T extends UploadFileUpsertArgs>(
      args: SelectSubset<T, UploadFileUpsertArgs>
    ): Prisma__UploadFileClient<UploadFileGetPayload<T>>

    /**
     * Count the number of UploadFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFileCountArgs} args - Arguments to filter UploadFiles to count.
     * @example
     * // Count the number of UploadFiles
     * const count = await prisma.uploadFile.count({
     *   where: {
     *     // ... the filter for the UploadFiles we want to count
     *   }
     * })
    **/
    count<T extends UploadFileCountArgs>(
      args?: Subset<T, UploadFileCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UploadFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UploadFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UploadFileAggregateArgs>(args: Subset<T, UploadFileAggregateArgs>): PrismaPromise<GetUploadFileAggregateType<T>>

    /**
     * Group by UploadFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UploadFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UploadFileGroupByArgs['orderBy'] }
        : { orderBy?: UploadFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UploadFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUploadFileGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UploadFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UploadFileClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Applicant<T extends ApplicantArgs= {}>(args?: Subset<T, ApplicantArgs>): Prisma__ApplicantClient<ApplicantGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UploadFile base type for findUnique actions
   */
  export type UploadFileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UploadFile
     * 
    **/
    select?: UploadFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UploadFileInclude | null
    /**
     * Filter, which UploadFile to fetch.
     * 
    **/
    where: UploadFileWhereUniqueInput
  }

  /**
   * UploadFile findUnique
   */
  export interface UploadFileFindUniqueArgs extends UploadFileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UploadFile findUniqueOrThrow
   */
  export type UploadFileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UploadFile
     * 
    **/
    select?: UploadFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UploadFileInclude | null
    /**
     * Filter, which UploadFile to fetch.
     * 
    **/
    where: UploadFileWhereUniqueInput
  }


  /**
   * UploadFile base type for findFirst actions
   */
  export type UploadFileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UploadFile
     * 
    **/
    select?: UploadFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UploadFileInclude | null
    /**
     * Filter, which UploadFile to fetch.
     * 
    **/
    where?: UploadFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadFiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UploadFileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadFiles.
     * 
    **/
    cursor?: UploadFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadFiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadFiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadFiles.
     * 
    **/
    distinct?: Enumerable<UploadFileScalarFieldEnum>
  }

  /**
   * UploadFile findFirst
   */
  export interface UploadFileFindFirstArgs extends UploadFileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UploadFile findFirstOrThrow
   */
  export type UploadFileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UploadFile
     * 
    **/
    select?: UploadFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UploadFileInclude | null
    /**
     * Filter, which UploadFile to fetch.
     * 
    **/
    where?: UploadFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadFiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UploadFileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadFiles.
     * 
    **/
    cursor?: UploadFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadFiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadFiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadFiles.
     * 
    **/
    distinct?: Enumerable<UploadFileScalarFieldEnum>
  }


  /**
   * UploadFile findMany
   */
  export type UploadFileFindManyArgs = {
    /**
     * Select specific fields to fetch from the UploadFile
     * 
    **/
    select?: UploadFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UploadFileInclude | null
    /**
     * Filter, which UploadFiles to fetch.
     * 
    **/
    where?: UploadFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadFiles to fetch.
     * 
    **/
    orderBy?: Enumerable<UploadFileOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UploadFiles.
     * 
    **/
    cursor?: UploadFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadFiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadFiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UploadFileScalarFieldEnum>
  }


  /**
   * UploadFile create
   */
  export type UploadFileCreateArgs = {
    /**
     * Select specific fields to fetch from the UploadFile
     * 
    **/
    select?: UploadFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UploadFileInclude | null
    /**
     * The data needed to create a UploadFile.
     * 
    **/
    data: XOR<UploadFileCreateInput, UploadFileUncheckedCreateInput>
  }


  /**
   * UploadFile createMany
   */
  export type UploadFileCreateManyArgs = {
    /**
     * The data used to create many UploadFiles.
     * 
    **/
    data: Enumerable<UploadFileCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UploadFile update
   */
  export type UploadFileUpdateArgs = {
    /**
     * Select specific fields to fetch from the UploadFile
     * 
    **/
    select?: UploadFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UploadFileInclude | null
    /**
     * The data needed to update a UploadFile.
     * 
    **/
    data: XOR<UploadFileUpdateInput, UploadFileUncheckedUpdateInput>
    /**
     * Choose, which UploadFile to update.
     * 
    **/
    where: UploadFileWhereUniqueInput
  }


  /**
   * UploadFile updateMany
   */
  export type UploadFileUpdateManyArgs = {
    /**
     * The data used to update UploadFiles.
     * 
    **/
    data: XOR<UploadFileUpdateManyMutationInput, UploadFileUncheckedUpdateManyInput>
    /**
     * Filter which UploadFiles to update
     * 
    **/
    where?: UploadFileWhereInput
  }


  /**
   * UploadFile upsert
   */
  export type UploadFileUpsertArgs = {
    /**
     * Select specific fields to fetch from the UploadFile
     * 
    **/
    select?: UploadFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UploadFileInclude | null
    /**
     * The filter to search for the UploadFile to update in case it exists.
     * 
    **/
    where: UploadFileWhereUniqueInput
    /**
     * In case the UploadFile found by the `where` argument doesn't exist, create a new UploadFile with this data.
     * 
    **/
    create: XOR<UploadFileCreateInput, UploadFileUncheckedCreateInput>
    /**
     * In case the UploadFile was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UploadFileUpdateInput, UploadFileUncheckedUpdateInput>
  }


  /**
   * UploadFile delete
   */
  export type UploadFileDeleteArgs = {
    /**
     * Select specific fields to fetch from the UploadFile
     * 
    **/
    select?: UploadFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UploadFileInclude | null
    /**
     * Filter which UploadFile to delete.
     * 
    **/
    where: UploadFileWhereUniqueInput
  }


  /**
   * UploadFile deleteMany
   */
  export type UploadFileDeleteManyArgs = {
    /**
     * Filter which UploadFiles to delete
     * 
    **/
    where?: UploadFileWhereInput
  }


  /**
   * UploadFile without action
   */
  export type UploadFileArgs = {
    /**
     * Select specific fields to fetch from the UploadFile
     * 
    **/
    select?: UploadFileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UploadFileInclude | null
  }



  /**
   * Model JobPost
   */


  export type AggregateJobPost = {
    _count: JobPostCountAggregateOutputType | null
    _min: JobPostMinAggregateOutputType | null
    _max: JobPostMaxAggregateOutputType | null
  }

  export type JobPostMinAggregateOutputType = {
    jobPostID: string | null
    title: string | null
    description: string | null
    qualification: string | null
    responsibilities: string | null
    status: JobStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    companyID: string | null
    notificationID: string | null
    userID: string | null
  }

  export type JobPostMaxAggregateOutputType = {
    jobPostID: string | null
    title: string | null
    description: string | null
    qualification: string | null
    responsibilities: string | null
    status: JobStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    companyID: string | null
    notificationID: string | null
    userID: string | null
  }

  export type JobPostCountAggregateOutputType = {
    jobPostID: number
    title: number
    description: number
    qualification: number
    responsibilities: number
    status: number
    createdAt: number
    updatedAt: number
    companyID: number
    notificationID: number
    userID: number
    _all: number
  }


  export type JobPostMinAggregateInputType = {
    jobPostID?: true
    title?: true
    description?: true
    qualification?: true
    responsibilities?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    companyID?: true
    notificationID?: true
    userID?: true
  }

  export type JobPostMaxAggregateInputType = {
    jobPostID?: true
    title?: true
    description?: true
    qualification?: true
    responsibilities?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    companyID?: true
    notificationID?: true
    userID?: true
  }

  export type JobPostCountAggregateInputType = {
    jobPostID?: true
    title?: true
    description?: true
    qualification?: true
    responsibilities?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    companyID?: true
    notificationID?: true
    userID?: true
    _all?: true
  }

  export type JobPostAggregateArgs = {
    /**
     * Filter which JobPost to aggregate.
     * 
    **/
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     * 
    **/
    orderBy?: Enumerable<JobPostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobPosts
    **/
    _count?: true | JobPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobPostMaxAggregateInputType
  }

  export type GetJobPostAggregateType<T extends JobPostAggregateArgs> = {
        [P in keyof T & keyof AggregateJobPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobPost[P]>
      : GetScalarType<T[P], AggregateJobPost[P]>
  }




  export type JobPostGroupByArgs = {
    where?: JobPostWhereInput
    orderBy?: Enumerable<JobPostOrderByWithAggregationInput>
    by: Array<JobPostScalarFieldEnum>
    having?: JobPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobPostCountAggregateInputType | true
    _min?: JobPostMinAggregateInputType
    _max?: JobPostMaxAggregateInputType
  }


  export type JobPostGroupByOutputType = {
    jobPostID: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date
    updatedAt: Date
    companyID: string
    notificationID: string | null
    userID: string
    _count: JobPostCountAggregateOutputType | null
    _min: JobPostMinAggregateOutputType | null
    _max: JobPostMaxAggregateOutputType | null
  }

  type GetJobPostGroupByPayload<T extends JobPostGroupByArgs> = PrismaPromise<
    Array<
      PickArray<JobPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobPostGroupByOutputType[P]>
            : GetScalarType<T[P], JobPostGroupByOutputType[P]>
        }
      >
    >


  export type JobPostSelect = {
    jobPostID?: boolean
    title?: boolean
    description?: boolean
    qualification?: boolean
    responsibilities?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyID?: boolean
    notificationID?: boolean
    userID?: boolean
    Company?: boolean | CompanyArgs
    Notification?: boolean | NotificationArgs
    User?: boolean | UserArgs
    Applicants?: boolean | JobPost$ApplicantsArgs
    details?: boolean | JobDetailsArgs
    _count?: boolean | JobPostCountOutputTypeArgs
  }


  export type JobPostInclude = {
    Company?: boolean | CompanyArgs
    Notification?: boolean | NotificationArgs
    User?: boolean | UserArgs
    Applicants?: boolean | JobPost$ApplicantsArgs
    details?: boolean | JobDetailsArgs
    _count?: boolean | JobPostCountOutputTypeArgs
  } 

  export type JobPostGetPayload<S extends boolean | null | undefined | JobPostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? JobPost :
    S extends undefined ? never :
    S extends { include: any } & (JobPostArgs | JobPostFindManyArgs)
    ? JobPost  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Company' ? CompanyGetPayload<S['include'][P]> :
        P extends 'Notification' ? NotificationGetPayload<S['include'][P]> | null :
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'Applicants' ? Array < ApplicantGetPayload<S['include'][P]>>  :
        P extends 'details' ? JobDetailsGetPayload<S['include'][P]> | null :
        P extends '_count' ? JobPostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (JobPostArgs | JobPostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Company' ? CompanyGetPayload<S['select'][P]> :
        P extends 'Notification' ? NotificationGetPayload<S['select'][P]> | null :
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'Applicants' ? Array < ApplicantGetPayload<S['select'][P]>>  :
        P extends 'details' ? JobDetailsGetPayload<S['select'][P]> | null :
        P extends '_count' ? JobPostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof JobPost ? JobPost[P] : never
  } 
      : JobPost


  type JobPostCountArgs = Merge<
    Omit<JobPostFindManyArgs, 'select' | 'include'> & {
      select?: JobPostCountAggregateInputType | true
    }
  >

  export interface JobPostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one JobPost that matches the filter.
     * @param {JobPostFindUniqueArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobPostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JobPostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'JobPost'> extends True ? Prisma__JobPostClient<JobPostGetPayload<T>> : Prisma__JobPostClient<JobPostGetPayload<T> | null, null>

    /**
     * Find one JobPost that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobPostFindUniqueOrThrowArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobPostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, JobPostFindUniqueOrThrowArgs>
    ): Prisma__JobPostClient<JobPostGetPayload<T>>

    /**
     * Find the first JobPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindFirstArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobPostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JobPostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'JobPost'> extends True ? Prisma__JobPostClient<JobPostGetPayload<T>> : Prisma__JobPostClient<JobPostGetPayload<T> | null, null>

    /**
     * Find the first JobPost that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindFirstOrThrowArgs} args - Arguments to find a JobPost
     * @example
     * // Get one JobPost
     * const jobPost = await prisma.jobPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobPostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, JobPostFindFirstOrThrowArgs>
    ): Prisma__JobPostClient<JobPostGetPayload<T>>

    /**
     * Find zero or more JobPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobPosts
     * const jobPosts = await prisma.jobPost.findMany()
     * 
     * // Get first 10 JobPosts
     * const jobPosts = await prisma.jobPost.findMany({ take: 10 })
     * 
     * // Only select the `jobPostID`
     * const jobPostWithJobPostIDOnly = await prisma.jobPost.findMany({ select: { jobPostID: true } })
     * 
    **/
    findMany<T extends JobPostFindManyArgs>(
      args?: SelectSubset<T, JobPostFindManyArgs>
    ): PrismaPromise<Array<JobPostGetPayload<T>>>

    /**
     * Create a JobPost.
     * @param {JobPostCreateArgs} args - Arguments to create a JobPost.
     * @example
     * // Create one JobPost
     * const JobPost = await prisma.jobPost.create({
     *   data: {
     *     // ... data to create a JobPost
     *   }
     * })
     * 
    **/
    create<T extends JobPostCreateArgs>(
      args: SelectSubset<T, JobPostCreateArgs>
    ): Prisma__JobPostClient<JobPostGetPayload<T>>

    /**
     * Create many JobPosts.
     *     @param {JobPostCreateManyArgs} args - Arguments to create many JobPosts.
     *     @example
     *     // Create many JobPosts
     *     const jobPost = await prisma.jobPost.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobPostCreateManyArgs>(
      args?: SelectSubset<T, JobPostCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a JobPost.
     * @param {JobPostDeleteArgs} args - Arguments to delete one JobPost.
     * @example
     * // Delete one JobPost
     * const JobPost = await prisma.jobPost.delete({
     *   where: {
     *     // ... filter to delete one JobPost
     *   }
     * })
     * 
    **/
    delete<T extends JobPostDeleteArgs>(
      args: SelectSubset<T, JobPostDeleteArgs>
    ): Prisma__JobPostClient<JobPostGetPayload<T>>

    /**
     * Update one JobPost.
     * @param {JobPostUpdateArgs} args - Arguments to update one JobPost.
     * @example
     * // Update one JobPost
     * const jobPost = await prisma.jobPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobPostUpdateArgs>(
      args: SelectSubset<T, JobPostUpdateArgs>
    ): Prisma__JobPostClient<JobPostGetPayload<T>>

    /**
     * Delete zero or more JobPosts.
     * @param {JobPostDeleteManyArgs} args - Arguments to filter JobPosts to delete.
     * @example
     * // Delete a few JobPosts
     * const { count } = await prisma.jobPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobPostDeleteManyArgs>(
      args?: SelectSubset<T, JobPostDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobPosts
     * const jobPost = await prisma.jobPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobPostUpdateManyArgs>(
      args: SelectSubset<T, JobPostUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one JobPost.
     * @param {JobPostUpsertArgs} args - Arguments to update or create a JobPost.
     * @example
     * // Update or create a JobPost
     * const jobPost = await prisma.jobPost.upsert({
     *   create: {
     *     // ... data to create a JobPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobPost we want to update
     *   }
     * })
    **/
    upsert<T extends JobPostUpsertArgs>(
      args: SelectSubset<T, JobPostUpsertArgs>
    ): Prisma__JobPostClient<JobPostGetPayload<T>>

    /**
     * Count the number of JobPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostCountArgs} args - Arguments to filter JobPosts to count.
     * @example
     * // Count the number of JobPosts
     * const count = await prisma.jobPost.count({
     *   where: {
     *     // ... the filter for the JobPosts we want to count
     *   }
     * })
    **/
    count<T extends JobPostCountArgs>(
      args?: Subset<T, JobPostCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobPostAggregateArgs>(args: Subset<T, JobPostAggregateArgs>): PrismaPromise<GetJobPostAggregateType<T>>

    /**
     * Group by JobPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobPostGroupByArgs['orderBy'] }
        : { orderBy?: JobPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobPostGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for JobPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JobPostClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Company<T extends CompanyArgs= {}>(args?: Subset<T, CompanyArgs>): Prisma__CompanyClient<CompanyGetPayload<T> | Null>;

    Notification<T extends NotificationArgs= {}>(args?: Subset<T, NotificationArgs>): Prisma__NotificationClient<NotificationGetPayload<T> | Null>;

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    Applicants<T extends JobPost$ApplicantsArgs= {}>(args?: Subset<T, JobPost$ApplicantsArgs>): PrismaPromise<Array<ApplicantGetPayload<T>>| Null>;

    details<T extends JobDetailsArgs= {}>(args?: Subset<T, JobDetailsArgs>): Prisma__JobDetailsClient<JobDetailsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * JobPost base type for findUnique actions
   */
  export type JobPostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
    /**
     * Filter, which JobPost to fetch.
     * 
    **/
    where: JobPostWhereUniqueInput
  }

  /**
   * JobPost findUnique
   */
  export interface JobPostFindUniqueArgs extends JobPostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobPost findUniqueOrThrow
   */
  export type JobPostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
    /**
     * Filter, which JobPost to fetch.
     * 
    **/
    where: JobPostWhereUniqueInput
  }


  /**
   * JobPost base type for findFirst actions
   */
  export type JobPostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
    /**
     * Filter, which JobPost to fetch.
     * 
    **/
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     * 
    **/
    orderBy?: Enumerable<JobPostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPosts.
     * 
    **/
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPosts.
     * 
    **/
    distinct?: Enumerable<JobPostScalarFieldEnum>
  }

  /**
   * JobPost findFirst
   */
  export interface JobPostFindFirstArgs extends JobPostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobPost findFirstOrThrow
   */
  export type JobPostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
    /**
     * Filter, which JobPost to fetch.
     * 
    **/
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     * 
    **/
    orderBy?: Enumerable<JobPostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobPosts.
     * 
    **/
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobPosts.
     * 
    **/
    distinct?: Enumerable<JobPostScalarFieldEnum>
  }


  /**
   * JobPost findMany
   */
  export type JobPostFindManyArgs = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
    /**
     * Filter, which JobPosts to fetch.
     * 
    **/
    where?: JobPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobPosts to fetch.
     * 
    **/
    orderBy?: Enumerable<JobPostOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobPosts.
     * 
    **/
    cursor?: JobPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobPosts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobPosts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<JobPostScalarFieldEnum>
  }


  /**
   * JobPost create
   */
  export type JobPostCreateArgs = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
    /**
     * The data needed to create a JobPost.
     * 
    **/
    data: XOR<JobPostCreateInput, JobPostUncheckedCreateInput>
  }


  /**
   * JobPost createMany
   */
  export type JobPostCreateManyArgs = {
    /**
     * The data used to create many JobPosts.
     * 
    **/
    data: Enumerable<JobPostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * JobPost update
   */
  export type JobPostUpdateArgs = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
    /**
     * The data needed to update a JobPost.
     * 
    **/
    data: XOR<JobPostUpdateInput, JobPostUncheckedUpdateInput>
    /**
     * Choose, which JobPost to update.
     * 
    **/
    where: JobPostWhereUniqueInput
  }


  /**
   * JobPost updateMany
   */
  export type JobPostUpdateManyArgs = {
    /**
     * The data used to update JobPosts.
     * 
    **/
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyInput>
    /**
     * Filter which JobPosts to update
     * 
    **/
    where?: JobPostWhereInput
  }


  /**
   * JobPost upsert
   */
  export type JobPostUpsertArgs = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
    /**
     * The filter to search for the JobPost to update in case it exists.
     * 
    **/
    where: JobPostWhereUniqueInput
    /**
     * In case the JobPost found by the `where` argument doesn't exist, create a new JobPost with this data.
     * 
    **/
    create: XOR<JobPostCreateInput, JobPostUncheckedCreateInput>
    /**
     * In case the JobPost was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<JobPostUpdateInput, JobPostUncheckedUpdateInput>
  }


  /**
   * JobPost delete
   */
  export type JobPostDeleteArgs = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
    /**
     * Filter which JobPost to delete.
     * 
    **/
    where: JobPostWhereUniqueInput
  }


  /**
   * JobPost deleteMany
   */
  export type JobPostDeleteManyArgs = {
    /**
     * Filter which JobPosts to delete
     * 
    **/
    where?: JobPostWhereInput
  }


  /**
   * JobPost.Applicants
   */
  export type JobPost$ApplicantsArgs = {
    /**
     * Select specific fields to fetch from the Applicant
     * 
    **/
    select?: ApplicantSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ApplicantInclude | null
    where?: ApplicantWhereInput
    orderBy?: Enumerable<ApplicantOrderByWithRelationAndSearchRelevanceInput>
    cursor?: ApplicantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ApplicantScalarFieldEnum>
  }


  /**
   * JobPost without action
   */
  export type JobPostArgs = {
    /**
     * Select specific fields to fetch from the JobPost
     * 
    **/
    select?: JobPostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobPostInclude | null
  }



  /**
   * Model JobDetails
   */


  export type AggregateJobDetails = {
    _count: JobDetailsCountAggregateOutputType | null
    _min: JobDetailsMinAggregateOutputType | null
    _max: JobDetailsMaxAggregateOutputType | null
  }

  export type JobDetailsMinAggregateOutputType = {
    jobDetailsID: string | null
    category: string | null
    salary: string | null
    jobPostID: string | null
  }

  export type JobDetailsMaxAggregateOutputType = {
    jobDetailsID: string | null
    category: string | null
    salary: string | null
    jobPostID: string | null
  }

  export type JobDetailsCountAggregateOutputType = {
    jobDetailsID: number
    location: number
    jobType: number
    workType: number
    category: number
    salary: number
    jobPostID: number
    _all: number
  }


  export type JobDetailsMinAggregateInputType = {
    jobDetailsID?: true
    category?: true
    salary?: true
    jobPostID?: true
  }

  export type JobDetailsMaxAggregateInputType = {
    jobDetailsID?: true
    category?: true
    salary?: true
    jobPostID?: true
  }

  export type JobDetailsCountAggregateInputType = {
    jobDetailsID?: true
    location?: true
    jobType?: true
    workType?: true
    category?: true
    salary?: true
    jobPostID?: true
    _all?: true
  }

  export type JobDetailsAggregateArgs = {
    /**
     * Filter which JobDetails to aggregate.
     * 
    **/
    where?: JobDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<JobDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: JobDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobDetails
    **/
    _count?: true | JobDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobDetailsMaxAggregateInputType
  }

  export type GetJobDetailsAggregateType<T extends JobDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobDetails[P]>
      : GetScalarType<T[P], AggregateJobDetails[P]>
  }




  export type JobDetailsGroupByArgs = {
    where?: JobDetailsWhereInput
    orderBy?: Enumerable<JobDetailsOrderByWithAggregationInput>
    by: Array<JobDetailsScalarFieldEnum>
    having?: JobDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobDetailsCountAggregateInputType | true
    _min?: JobDetailsMinAggregateInputType
    _max?: JobDetailsMaxAggregateInputType
  }


  export type JobDetailsGroupByOutputType = {
    jobDetailsID: string
    location: string[]
    jobType: string[]
    workType: string[]
    category: string
    salary: string
    jobPostID: string | null
    _count: JobDetailsCountAggregateOutputType | null
    _min: JobDetailsMinAggregateOutputType | null
    _max: JobDetailsMaxAggregateOutputType | null
  }

  type GetJobDetailsGroupByPayload<T extends JobDetailsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<JobDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], JobDetailsGroupByOutputType[P]>
        }
      >
    >


  export type JobDetailsSelect = {
    jobDetailsID?: boolean
    location?: boolean
    jobType?: boolean
    workType?: boolean
    category?: boolean
    salary?: boolean
    jobPostID?: boolean
    JobPost?: boolean | JobPostArgs
  }


  export type JobDetailsInclude = {
    JobPost?: boolean | JobPostArgs
  } 

  export type JobDetailsGetPayload<S extends boolean | null | undefined | JobDetailsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? JobDetails :
    S extends undefined ? never :
    S extends { include: any } & (JobDetailsArgs | JobDetailsFindManyArgs)
    ? JobDetails  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'JobPost' ? JobPostGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (JobDetailsArgs | JobDetailsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'JobPost' ? JobPostGetPayload<S['select'][P]> | null :  P extends keyof JobDetails ? JobDetails[P] : never
  } 
      : JobDetails


  type JobDetailsCountArgs = Merge<
    Omit<JobDetailsFindManyArgs, 'select' | 'include'> & {
      select?: JobDetailsCountAggregateInputType | true
    }
  >

  export interface JobDetailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one JobDetails that matches the filter.
     * @param {JobDetailsFindUniqueArgs} args - Arguments to find a JobDetails
     * @example
     * // Get one JobDetails
     * const jobDetails = await prisma.jobDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JobDetailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JobDetailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'JobDetails'> extends True ? Prisma__JobDetailsClient<JobDetailsGetPayload<T>> : Prisma__JobDetailsClient<JobDetailsGetPayload<T> | null, null>

    /**
     * Find one JobDetails that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {JobDetailsFindUniqueOrThrowArgs} args - Arguments to find a JobDetails
     * @example
     * // Get one JobDetails
     * const jobDetails = await prisma.jobDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends JobDetailsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, JobDetailsFindUniqueOrThrowArgs>
    ): Prisma__JobDetailsClient<JobDetailsGetPayload<T>>

    /**
     * Find the first JobDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDetailsFindFirstArgs} args - Arguments to find a JobDetails
     * @example
     * // Get one JobDetails
     * const jobDetails = await prisma.jobDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JobDetailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JobDetailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'JobDetails'> extends True ? Prisma__JobDetailsClient<JobDetailsGetPayload<T>> : Prisma__JobDetailsClient<JobDetailsGetPayload<T> | null, null>

    /**
     * Find the first JobDetails that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDetailsFindFirstOrThrowArgs} args - Arguments to find a JobDetails
     * @example
     * // Get one JobDetails
     * const jobDetails = await prisma.jobDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends JobDetailsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, JobDetailsFindFirstOrThrowArgs>
    ): Prisma__JobDetailsClient<JobDetailsGetPayload<T>>

    /**
     * Find zero or more JobDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobDetails
     * const jobDetails = await prisma.jobDetails.findMany()
     * 
     * // Get first 10 JobDetails
     * const jobDetails = await prisma.jobDetails.findMany({ take: 10 })
     * 
     * // Only select the `jobDetailsID`
     * const jobDetailsWithJobDetailsIDOnly = await prisma.jobDetails.findMany({ select: { jobDetailsID: true } })
     * 
    **/
    findMany<T extends JobDetailsFindManyArgs>(
      args?: SelectSubset<T, JobDetailsFindManyArgs>
    ): PrismaPromise<Array<JobDetailsGetPayload<T>>>

    /**
     * Create a JobDetails.
     * @param {JobDetailsCreateArgs} args - Arguments to create a JobDetails.
     * @example
     * // Create one JobDetails
     * const JobDetails = await prisma.jobDetails.create({
     *   data: {
     *     // ... data to create a JobDetails
     *   }
     * })
     * 
    **/
    create<T extends JobDetailsCreateArgs>(
      args: SelectSubset<T, JobDetailsCreateArgs>
    ): Prisma__JobDetailsClient<JobDetailsGetPayload<T>>

    /**
     * Create many JobDetails.
     *     @param {JobDetailsCreateManyArgs} args - Arguments to create many JobDetails.
     *     @example
     *     // Create many JobDetails
     *     const jobDetails = await prisma.jobDetails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JobDetailsCreateManyArgs>(
      args?: SelectSubset<T, JobDetailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a JobDetails.
     * @param {JobDetailsDeleteArgs} args - Arguments to delete one JobDetails.
     * @example
     * // Delete one JobDetails
     * const JobDetails = await prisma.jobDetails.delete({
     *   where: {
     *     // ... filter to delete one JobDetails
     *   }
     * })
     * 
    **/
    delete<T extends JobDetailsDeleteArgs>(
      args: SelectSubset<T, JobDetailsDeleteArgs>
    ): Prisma__JobDetailsClient<JobDetailsGetPayload<T>>

    /**
     * Update one JobDetails.
     * @param {JobDetailsUpdateArgs} args - Arguments to update one JobDetails.
     * @example
     * // Update one JobDetails
     * const jobDetails = await prisma.jobDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JobDetailsUpdateArgs>(
      args: SelectSubset<T, JobDetailsUpdateArgs>
    ): Prisma__JobDetailsClient<JobDetailsGetPayload<T>>

    /**
     * Delete zero or more JobDetails.
     * @param {JobDetailsDeleteManyArgs} args - Arguments to filter JobDetails to delete.
     * @example
     * // Delete a few JobDetails
     * const { count } = await prisma.jobDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JobDetailsDeleteManyArgs>(
      args?: SelectSubset<T, JobDetailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobDetails
     * const jobDetails = await prisma.jobDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JobDetailsUpdateManyArgs>(
      args: SelectSubset<T, JobDetailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one JobDetails.
     * @param {JobDetailsUpsertArgs} args - Arguments to update or create a JobDetails.
     * @example
     * // Update or create a JobDetails
     * const jobDetails = await prisma.jobDetails.upsert({
     *   create: {
     *     // ... data to create a JobDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobDetails we want to update
     *   }
     * })
    **/
    upsert<T extends JobDetailsUpsertArgs>(
      args: SelectSubset<T, JobDetailsUpsertArgs>
    ): Prisma__JobDetailsClient<JobDetailsGetPayload<T>>

    /**
     * Count the number of JobDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDetailsCountArgs} args - Arguments to filter JobDetails to count.
     * @example
     * // Count the number of JobDetails
     * const count = await prisma.jobDetails.count({
     *   where: {
     *     // ... the filter for the JobDetails we want to count
     *   }
     * })
    **/
    count<T extends JobDetailsCountArgs>(
      args?: Subset<T, JobDetailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobDetailsAggregateArgs>(args: Subset<T, JobDetailsAggregateArgs>): PrismaPromise<GetJobDetailsAggregateType<T>>

    /**
     * Group by JobDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobDetailsGroupByArgs['orderBy'] }
        : { orderBy?: JobDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobDetailsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for JobDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JobDetailsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    JobPost<T extends JobPostArgs= {}>(args?: Subset<T, JobPostArgs>): Prisma__JobPostClient<JobPostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * JobDetails base type for findUnique actions
   */
  export type JobDetailsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the JobDetails
     * 
    **/
    select?: JobDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobDetailsInclude | null
    /**
     * Filter, which JobDetails to fetch.
     * 
    **/
    where: JobDetailsWhereUniqueInput
  }

  /**
   * JobDetails findUnique
   */
  export interface JobDetailsFindUniqueArgs extends JobDetailsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobDetails findUniqueOrThrow
   */
  export type JobDetailsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobDetails
     * 
    **/
    select?: JobDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobDetailsInclude | null
    /**
     * Filter, which JobDetails to fetch.
     * 
    **/
    where: JobDetailsWhereUniqueInput
  }


  /**
   * JobDetails base type for findFirst actions
   */
  export type JobDetailsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the JobDetails
     * 
    **/
    select?: JobDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobDetailsInclude | null
    /**
     * Filter, which JobDetails to fetch.
     * 
    **/
    where?: JobDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<JobDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobDetails.
     * 
    **/
    cursor?: JobDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobDetails.
     * 
    **/
    distinct?: Enumerable<JobDetailsScalarFieldEnum>
  }

  /**
   * JobDetails findFirst
   */
  export interface JobDetailsFindFirstArgs extends JobDetailsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * JobDetails findFirstOrThrow
   */
  export type JobDetailsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the JobDetails
     * 
    **/
    select?: JobDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobDetailsInclude | null
    /**
     * Filter, which JobDetails to fetch.
     * 
    **/
    where?: JobDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<JobDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobDetails.
     * 
    **/
    cursor?: JobDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobDetails.
     * 
    **/
    distinct?: Enumerable<JobDetailsScalarFieldEnum>
  }


  /**
   * JobDetails findMany
   */
  export type JobDetailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the JobDetails
     * 
    **/
    select?: JobDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobDetailsInclude | null
    /**
     * Filter, which JobDetails to fetch.
     * 
    **/
    where?: JobDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<JobDetailsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobDetails.
     * 
    **/
    cursor?: JobDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<JobDetailsScalarFieldEnum>
  }


  /**
   * JobDetails create
   */
  export type JobDetailsCreateArgs = {
    /**
     * Select specific fields to fetch from the JobDetails
     * 
    **/
    select?: JobDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobDetailsInclude | null
    /**
     * The data needed to create a JobDetails.
     * 
    **/
    data: XOR<JobDetailsCreateInput, JobDetailsUncheckedCreateInput>
  }


  /**
   * JobDetails createMany
   */
  export type JobDetailsCreateManyArgs = {
    /**
     * The data used to create many JobDetails.
     * 
    **/
    data: Enumerable<JobDetailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * JobDetails update
   */
  export type JobDetailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the JobDetails
     * 
    **/
    select?: JobDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobDetailsInclude | null
    /**
     * The data needed to update a JobDetails.
     * 
    **/
    data: XOR<JobDetailsUpdateInput, JobDetailsUncheckedUpdateInput>
    /**
     * Choose, which JobDetails to update.
     * 
    **/
    where: JobDetailsWhereUniqueInput
  }


  /**
   * JobDetails updateMany
   */
  export type JobDetailsUpdateManyArgs = {
    /**
     * The data used to update JobDetails.
     * 
    **/
    data: XOR<JobDetailsUpdateManyMutationInput, JobDetailsUncheckedUpdateManyInput>
    /**
     * Filter which JobDetails to update
     * 
    **/
    where?: JobDetailsWhereInput
  }


  /**
   * JobDetails upsert
   */
  export type JobDetailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the JobDetails
     * 
    **/
    select?: JobDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobDetailsInclude | null
    /**
     * The filter to search for the JobDetails to update in case it exists.
     * 
    **/
    where: JobDetailsWhereUniqueInput
    /**
     * In case the JobDetails found by the `where` argument doesn't exist, create a new JobDetails with this data.
     * 
    **/
    create: XOR<JobDetailsCreateInput, JobDetailsUncheckedCreateInput>
    /**
     * In case the JobDetails was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<JobDetailsUpdateInput, JobDetailsUncheckedUpdateInput>
  }


  /**
   * JobDetails delete
   */
  export type JobDetailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the JobDetails
     * 
    **/
    select?: JobDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobDetailsInclude | null
    /**
     * Filter which JobDetails to delete.
     * 
    **/
    where: JobDetailsWhereUniqueInput
  }


  /**
   * JobDetails deleteMany
   */
  export type JobDetailsDeleteManyArgs = {
    /**
     * Filter which JobDetails to delete
     * 
    **/
    where?: JobDetailsWhereInput
  }


  /**
   * JobDetails without action
   */
  export type JobDetailsArgs = {
    /**
     * Select specific fields to fetch from the JobDetails
     * 
    **/
    select?: JobDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: JobDetailsInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AddressOrderByRelevanceFieldEnum: {
    addressID: 'addressID',
    city: 'city',
    province: 'province',
    zipcode: 'zipcode',
    street: 'street',
    profileID: 'profileID',
    companyDetailsID: 'companyDetailsID'
  };

  export type AddressOrderByRelevanceFieldEnum = (typeof AddressOrderByRelevanceFieldEnum)[keyof typeof AddressOrderByRelevanceFieldEnum]


  export const AddressScalarFieldEnum: {
    addressID: 'addressID',
    city: 'city',
    province: 'province',
    zipcode: 'zipcode',
    street: 'street',
    profileID: 'profileID',
    companyDetailsID: 'companyDetailsID'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const ApplicantOrderByRelevanceFieldEnum: {
    applicantID: 'applicantID',
    id: 'id',
    email: 'email',
    jobPostID: 'jobPostID',
    interviewerID: 'interviewerID',
    endorsementID: 'endorsementID',
    notificaitonID: 'notificaitonID'
  };

  export type ApplicantOrderByRelevanceFieldEnum = (typeof ApplicantOrderByRelevanceFieldEnum)[keyof typeof ApplicantOrderByRelevanceFieldEnum]


  export const ApplicantScalarFieldEnum: {
    applicantID: 'applicantID',
    id: 'id',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    jobPostID: 'jobPostID',
    interviewerID: 'interviewerID',
    endorsementID: 'endorsementID',
    notificaitonID: 'notificaitonID'
  };

  export type ApplicantScalarFieldEnum = (typeof ApplicantScalarFieldEnum)[keyof typeof ApplicantScalarFieldEnum]


  export const CommentOrderByRelevanceFieldEnum: {
    commentID: 'commentID',
    message: 'message',
    notes: 'notes',
    endorsementID: 'endorsementID',
    userID: 'userID'
  };

  export type CommentOrderByRelevanceFieldEnum = (typeof CommentOrderByRelevanceFieldEnum)[keyof typeof CommentOrderByRelevanceFieldEnum]


  export const CommentScalarFieldEnum: {
    commentID: 'commentID',
    message: 'message',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    endorsementID: 'endorsementID',
    userID: 'userID'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CompanyDetailsOrderByRelevanceFieldEnum: {
    companyDetailsID: 'companyDetailsID',
    description: 'description',
    mission: 'mission',
    vision: 'vision',
    companyID: 'companyID'
  };

  export type CompanyDetailsOrderByRelevanceFieldEnum = (typeof CompanyDetailsOrderByRelevanceFieldEnum)[keyof typeof CompanyDetailsOrderByRelevanceFieldEnum]


  export const CompanyDetailsScalarFieldEnum: {
    companyDetailsID: 'companyDetailsID',
    description: 'description',
    mission: 'mission',
    vision: 'vision',
    companyID: 'companyID'
  };

  export type CompanyDetailsScalarFieldEnum = (typeof CompanyDetailsScalarFieldEnum)[keyof typeof CompanyDetailsScalarFieldEnum]


  export const CompanyOrderByRelevanceFieldEnum: {
    companyID: 'companyID',
    companyName: 'companyName'
  };

  export type CompanyOrderByRelevanceFieldEnum = (typeof CompanyOrderByRelevanceFieldEnum)[keyof typeof CompanyOrderByRelevanceFieldEnum]


  export const CompanyScalarFieldEnum: {
    companyID: 'companyID',
    companyName: 'companyName',
    createdAt: 'createdAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const EndorseOrderByRelevanceFieldEnum: {
    endorseID: 'endorseID',
    userID: 'userID',
    companyID: 'companyID'
  };

  export type EndorseOrderByRelevanceFieldEnum = (typeof EndorseOrderByRelevanceFieldEnum)[keyof typeof EndorseOrderByRelevanceFieldEnum]


  export const EndorseScalarFieldEnum: {
    endorseID: 'endorseID',
    endorseStatus: 'endorseStatus',
    userID: 'userID',
    createdAt: 'createdAt',
    companyID: 'companyID'
  };

  export type EndorseScalarFieldEnum = (typeof EndorseScalarFieldEnum)[keyof typeof EndorseScalarFieldEnum]


  export const EndorsementOrderByRelevanceFieldEnum: {
    endorsementID: 'endorsementID',
    Status: 'Status',
    userID: 'userID',
    companyID: 'companyID'
  };

  export type EndorsementOrderByRelevanceFieldEnum = (typeof EndorsementOrderByRelevanceFieldEnum)[keyof typeof EndorsementOrderByRelevanceFieldEnum]


  export const EndorsementScalarFieldEnum: {
    endorsementID: 'endorsementID',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userID: 'userID',
    companyID: 'companyID'
  };

  export type EndorsementScalarFieldEnum = (typeof EndorsementScalarFieldEnum)[keyof typeof EndorsementScalarFieldEnum]


  export const FeedbackOrderByRelevanceFieldEnum: {
    feedbackID: 'feedbackID',
    feedback: 'feedback',
    endorseID: 'endorseID',
    userID: 'userID',
    applicantID: 'applicantID'
  };

  export type FeedbackOrderByRelevanceFieldEnum = (typeof FeedbackOrderByRelevanceFieldEnum)[keyof typeof FeedbackOrderByRelevanceFieldEnum]


  export const FeedbackScalarFieldEnum: {
    feedbackID: 'feedbackID',
    feedback: 'feedback',
    createdAt: 'createdAt',
    endorseID: 'endorseID',
    userID: 'userID',
    applicantID: 'applicantID'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const InterviewerOrderByRelevanceFieldEnum: {
    interviewerID: 'interviewerID',
    userID: 'userID'
  };

  export type InterviewerOrderByRelevanceFieldEnum = (typeof InterviewerOrderByRelevanceFieldEnum)[keyof typeof InterviewerOrderByRelevanceFieldEnum]


  export const InterviewerScalarFieldEnum: {
    interviewerID: 'interviewerID',
    createdAt: 'createdAt',
    userID: 'userID'
  };

  export type InterviewerScalarFieldEnum = (typeof InterviewerScalarFieldEnum)[keyof typeof InterviewerScalarFieldEnum]


  export const JobDetailsOrderByRelevanceFieldEnum: {
    jobDetailsID: 'jobDetailsID',
    location: 'location',
    jobType: 'jobType',
    workType: 'workType',
    category: 'category',
    salary: 'salary',
    jobPostID: 'jobPostID'
  };

  export type JobDetailsOrderByRelevanceFieldEnum = (typeof JobDetailsOrderByRelevanceFieldEnum)[keyof typeof JobDetailsOrderByRelevanceFieldEnum]


  export const JobDetailsScalarFieldEnum: {
    jobDetailsID: 'jobDetailsID',
    location: 'location',
    jobType: 'jobType',
    workType: 'workType',
    category: 'category',
    salary: 'salary',
    jobPostID: 'jobPostID'
  };

  export type JobDetailsScalarFieldEnum = (typeof JobDetailsScalarFieldEnum)[keyof typeof JobDetailsScalarFieldEnum]


  export const JobPostOrderByRelevanceFieldEnum: {
    jobPostID: 'jobPostID',
    title: 'title',
    description: 'description',
    qualification: 'qualification',
    responsibilities: 'responsibilities',
    companyID: 'companyID',
    notificationID: 'notificationID',
    userID: 'userID'
  };

  export type JobPostOrderByRelevanceFieldEnum = (typeof JobPostOrderByRelevanceFieldEnum)[keyof typeof JobPostOrderByRelevanceFieldEnum]


  export const JobPostScalarFieldEnum: {
    jobPostID: 'jobPostID',
    title: 'title',
    description: 'description',
    qualification: 'qualification',
    responsibilities: 'responsibilities',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyID: 'companyID',
    notificationID: 'notificationID',
    userID: 'userID'
  };

  export type JobPostScalarFieldEnum = (typeof JobPostScalarFieldEnum)[keyof typeof JobPostScalarFieldEnum]


  export const LogsOrderByRelevanceFieldEnum: {
    logsID: 'logsID',
    title: 'title',
    modifiedBy: 'modifiedBy'
  };

  export type LogsOrderByRelevanceFieldEnum = (typeof LogsOrderByRelevanceFieldEnum)[keyof typeof LogsOrderByRelevanceFieldEnum]


  export const LogsScalarFieldEnum: {
    logsID: 'logsID',
    title: 'title',
    modifiedBy: 'modifiedBy',
    createdAt: 'createdAt'
  };

  export type LogsScalarFieldEnum = (typeof LogsScalarFieldEnum)[keyof typeof LogsScalarFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    notificationID: 'notificationID',
    title: 'title',
    userID: 'userID'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const NotificationScalarFieldEnum: {
    notificationID: 'notificationID',
    title: 'title',
    notificationStatus: 'notificationStatus',
    createdAt: 'createdAt',
    userID: 'userID'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ProfileOrderByRelevanceFieldEnum: {
    profileID: 'profileID',
    firstname: 'firstname',
    lastname: 'lastname',
    phone: 'phone',
    applicantID: 'applicantID',
    userID: 'userID'
  };

  export type ProfileOrderByRelevanceFieldEnum = (typeof ProfileOrderByRelevanceFieldEnum)[keyof typeof ProfileOrderByRelevanceFieldEnum]


  export const ProfileScalarFieldEnum: {
    profileID: 'profileID',
    firstname: 'firstname',
    lastname: 'lastname',
    phone: 'phone',
    birthday: 'birthday',
    applicantID: 'applicantID',
    userID: 'userID'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UploadFileOrderByRelevanceFieldEnum: {
    uploadFileID: 'uploadFileID',
    file: 'file',
    video: 'video',
    applicantID: 'applicantID'
  };

  export type UploadFileOrderByRelevanceFieldEnum = (typeof UploadFileOrderByRelevanceFieldEnum)[keyof typeof UploadFileOrderByRelevanceFieldEnum]


  export const UploadFileScalarFieldEnum: {
    uploadFileID: 'uploadFileID',
    file: 'file',
    video: 'video',
    createdAt: 'createdAt',
    applicantID: 'applicantID'
  };

  export type UploadFileScalarFieldEnum = (typeof UploadFileScalarFieldEnum)[keyof typeof UploadFileScalarFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    userID: 'userID',
    email: 'email',
    password: 'password',
    companyID: 'companyID'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const UserScalarFieldEnum: {
    userID: 'userID',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyID: 'companyID'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    userID?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    role?: EnumRoleFilter | Role
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    companyID?: StringFilter | string
    Company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    Comment?: XOR<CommentRelationFilter, CommentWhereInput> | null
    Endorse?: EndorseListRelationFilter
    Endorsement?: EndorsementListRelationFilter
    Feedback?: XOR<FeedbackRelationFilter, FeedbackWhereInput> | null
    interviewer?: InterviewerListRelationFilter
    JobPost?: JobPostListRelationFilter
    Notification?: NotificationListRelationFilter
    Profile?: XOR<ProfileRelationFilter, ProfileWhereInput> | null
    Logs?: LogsListRelationFilter
  }

  export type UserOrderByWithRelationAndSearchRelevanceInput = {
    userID?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyID?: SortOrder
    Company?: CompanyOrderByWithRelationAndSearchRelevanceInput
    Comment?: CommentOrderByWithRelationAndSearchRelevanceInput
    Endorse?: EndorseOrderByRelationAggregateInput
    Endorsement?: EndorsementOrderByRelationAggregateInput
    Feedback?: FeedbackOrderByWithRelationAndSearchRelevanceInput
    interviewer?: InterviewerOrderByRelationAggregateInput
    JobPost?: JobPostOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    Profile?: ProfileOrderByWithRelationAndSearchRelevanceInput
    Logs?: LogsOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = {
    userID?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    userID?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyID?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    userID?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    role?: EnumRoleWithAggregatesFilter | Role
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    companyID?: StringWithAggregatesFilter | string
  }

  export type LogsWhereInput = {
    AND?: Enumerable<LogsWhereInput>
    OR?: Enumerable<LogsWhereInput>
    NOT?: Enumerable<LogsWhereInput>
    logsID?: StringFilter | string
    title?: StringFilter | string
    modifiedBy?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    User?: UserListRelationFilter
  }

  export type LogsOrderByWithRelationAndSearchRelevanceInput = {
    logsID?: SortOrder
    title?: SortOrder
    modifiedBy?: SortOrder
    createdAt?: SortOrder
    User?: UserOrderByRelationAggregateInput
    _relevance?: LogsOrderByRelevanceInput
  }

  export type LogsWhereUniqueInput = {
    logsID?: string
  }

  export type LogsOrderByWithAggregationInput = {
    logsID?: SortOrder
    title?: SortOrder
    modifiedBy?: SortOrder
    createdAt?: SortOrder
    _count?: LogsCountOrderByAggregateInput
    _max?: LogsMaxOrderByAggregateInput
    _min?: LogsMinOrderByAggregateInput
  }

  export type LogsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LogsScalarWhereWithAggregatesInput>
    OR?: Enumerable<LogsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LogsScalarWhereWithAggregatesInput>
    logsID?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    modifiedBy?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    notificationID?: StringFilter | string
    title?: StringFilter | string
    notificationStatus?: EnumnotificationStatusFilter | notificationStatus
    createdAt?: DateTimeFilter | Date | string
    userID?: StringNullableFilter | string | null
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    JobPost?: XOR<JobPostRelationFilter, JobPostWhereInput> | null
    Applicant?: XOR<ApplicantRelationFilter, ApplicantWhereInput> | null
  }

  export type NotificationOrderByWithRelationAndSearchRelevanceInput = {
    notificationID?: SortOrder
    title?: SortOrder
    notificationStatus?: SortOrder
    createdAt?: SortOrder
    userID?: SortOrder
    User?: UserOrderByWithRelationAndSearchRelevanceInput
    JobPost?: JobPostOrderByWithRelationAndSearchRelevanceInput
    Applicant?: ApplicantOrderByWithRelationAndSearchRelevanceInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = {
    notificationID?: string
  }

  export type NotificationOrderByWithAggregationInput = {
    notificationID?: SortOrder
    title?: SortOrder
    notificationStatus?: SortOrder
    createdAt?: SortOrder
    userID?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    notificationID?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    notificationStatus?: EnumnotificationStatusWithAggregatesFilter | notificationStatus
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    userID?: StringNullableWithAggregatesFilter | string | null
  }

  export type ProfileWhereInput = {
    AND?: Enumerable<ProfileWhereInput>
    OR?: Enumerable<ProfileWhereInput>
    NOT?: Enumerable<ProfileWhereInput>
    profileID?: StringFilter | string
    firstname?: StringFilter | string
    lastname?: StringFilter | string
    phone?: StringFilter | string
    birthday?: DateTimeNullableFilter | Date | string | null
    applicantID?: StringNullableFilter | string | null
    userID?: StringNullableFilter | string | null
    Applicant?: XOR<ApplicantRelationFilter, ApplicantWhereInput> | null
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    Address?: XOR<AddressRelationFilter, AddressWhereInput> | null
  }

  export type ProfileOrderByWithRelationAndSearchRelevanceInput = {
    profileID?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone?: SortOrder
    birthday?: SortOrder
    applicantID?: SortOrder
    userID?: SortOrder
    Applicant?: ApplicantOrderByWithRelationAndSearchRelevanceInput
    User?: UserOrderByWithRelationAndSearchRelevanceInput
    Address?: AddressOrderByWithRelationAndSearchRelevanceInput
    _relevance?: ProfileOrderByRelevanceInput
  }

  export type ProfileWhereUniqueInput = {
    profileID?: string
    applicantID?: string
    userID?: string
  }

  export type ProfileOrderByWithAggregationInput = {
    profileID?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone?: SortOrder
    birthday?: SortOrder
    applicantID?: SortOrder
    userID?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProfileScalarWhereWithAggregatesInput>
    profileID?: StringWithAggregatesFilter | string
    firstname?: StringWithAggregatesFilter | string
    lastname?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    birthday?: DateTimeNullableWithAggregatesFilter | Date | string | null
    applicantID?: StringNullableWithAggregatesFilter | string | null
    userID?: StringNullableWithAggregatesFilter | string | null
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    addressID?: StringFilter | string
    city?: StringFilter | string
    province?: StringFilter | string
    zipcode?: StringFilter | string
    street?: StringFilter | string
    profileID?: StringNullableFilter | string | null
    companyDetailsID?: StringNullableFilter | string | null
    Company_Details?: XOR<CompanyDetailsRelationFilter, CompanyDetailsWhereInput> | null
    Profile?: XOR<ProfileRelationFilter, ProfileWhereInput> | null
  }

  export type AddressOrderByWithRelationAndSearchRelevanceInput = {
    addressID?: SortOrder
    city?: SortOrder
    province?: SortOrder
    zipcode?: SortOrder
    street?: SortOrder
    profileID?: SortOrder
    companyDetailsID?: SortOrder
    Company_Details?: CompanyDetailsOrderByWithRelationAndSearchRelevanceInput
    Profile?: ProfileOrderByWithRelationAndSearchRelevanceInput
    _relevance?: AddressOrderByRelevanceInput
  }

  export type AddressWhereUniqueInput = {
    addressID?: string
    profileID?: string
    companyDetailsID?: string
  }

  export type AddressOrderByWithAggregationInput = {
    addressID?: SortOrder
    city?: SortOrder
    province?: SortOrder
    zipcode?: SortOrder
    street?: SortOrder
    profileID?: SortOrder
    companyDetailsID?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    addressID?: StringWithAggregatesFilter | string
    city?: StringWithAggregatesFilter | string
    province?: StringWithAggregatesFilter | string
    zipcode?: StringWithAggregatesFilter | string
    street?: StringWithAggregatesFilter | string
    profileID?: StringNullableWithAggregatesFilter | string | null
    companyDetailsID?: StringNullableWithAggregatesFilter | string | null
  }

  export type CompanyWhereInput = {
    AND?: Enumerable<CompanyWhereInput>
    OR?: Enumerable<CompanyWhereInput>
    NOT?: Enumerable<CompanyWhereInput>
    companyID?: StringFilter | string
    companyName?: StringFilter | string
    details?: XOR<CompanyDetailsRelationFilter, CompanyDetailsWhereInput> | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    Endorse?: EndorseListRelationFilter
    Endorsement?: EndorsementListRelationFilter
    jobPost?: JobPostListRelationFilter
    User?: UserListRelationFilter
  }

  export type CompanyOrderByWithRelationAndSearchRelevanceInput = {
    companyID?: SortOrder
    companyName?: SortOrder
    details?: CompanyDetailsOrderByWithRelationAndSearchRelevanceInput
    createdAt?: SortOrder
    Endorse?: EndorseOrderByRelationAggregateInput
    Endorsement?: EndorsementOrderByRelationAggregateInput
    jobPost?: JobPostOrderByRelationAggregateInput
    User?: UserOrderByRelationAggregateInput
    _relevance?: CompanyOrderByRelevanceInput
  }

  export type CompanyWhereUniqueInput = {
    companyID?: string
  }

  export type CompanyOrderByWithAggregationInput = {
    companyID?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    OR?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    companyID?: StringWithAggregatesFilter | string
    companyName?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CompanyDetailsWhereInput = {
    AND?: Enumerable<CompanyDetailsWhereInput>
    OR?: Enumerable<CompanyDetailsWhereInput>
    NOT?: Enumerable<CompanyDetailsWhereInput>
    companyDetailsID?: StringFilter | string
    description?: StringFilter | string
    mission?: StringNullableFilter | string | null
    vision?: StringNullableFilter | string | null
    companyID?: StringNullableFilter | string | null
    Company?: XOR<CompanyRelationFilter, CompanyWhereInput> | null
    location?: XOR<AddressRelationFilter, AddressWhereInput> | null
  }

  export type CompanyDetailsOrderByWithRelationAndSearchRelevanceInput = {
    companyDetailsID?: SortOrder
    description?: SortOrder
    mission?: SortOrder
    vision?: SortOrder
    companyID?: SortOrder
    Company?: CompanyOrderByWithRelationAndSearchRelevanceInput
    location?: AddressOrderByWithRelationAndSearchRelevanceInput
    _relevance?: CompanyDetailsOrderByRelevanceInput
  }

  export type CompanyDetailsWhereUniqueInput = {
    companyDetailsID?: string
    companyID?: string
  }

  export type CompanyDetailsOrderByWithAggregationInput = {
    companyDetailsID?: SortOrder
    description?: SortOrder
    mission?: SortOrder
    vision?: SortOrder
    companyID?: SortOrder
    _count?: CompanyDetailsCountOrderByAggregateInput
    _max?: CompanyDetailsMaxOrderByAggregateInput
    _min?: CompanyDetailsMinOrderByAggregateInput
  }

  export type CompanyDetailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CompanyDetailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<CompanyDetailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CompanyDetailsScalarWhereWithAggregatesInput>
    companyDetailsID?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    mission?: StringNullableWithAggregatesFilter | string | null
    vision?: StringNullableWithAggregatesFilter | string | null
    companyID?: StringNullableWithAggregatesFilter | string | null
  }

  export type CommentWhereInput = {
    AND?: Enumerable<CommentWhereInput>
    OR?: Enumerable<CommentWhereInput>
    NOT?: Enumerable<CommentWhereInput>
    commentID?: StringFilter | string
    message?: StringFilter | string
    notes?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    endorsementID?: StringNullableFilter | string | null
    userID?: StringNullableFilter | string | null
    Endorsement?: XOR<EndorsementRelationFilter, EndorsementWhereInput> | null
    User?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type CommentOrderByWithRelationAndSearchRelevanceInput = {
    commentID?: SortOrder
    message?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endorsementID?: SortOrder
    userID?: SortOrder
    Endorsement?: EndorsementOrderByWithRelationAndSearchRelevanceInput
    User?: UserOrderByWithRelationAndSearchRelevanceInput
    _relevance?: CommentOrderByRelevanceInput
  }

  export type CommentWhereUniqueInput = {
    commentID?: string
    endorsementID?: string
    userID?: string
  }

  export type CommentOrderByWithAggregationInput = {
    commentID?: SortOrder
    message?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endorsementID?: SortOrder
    userID?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentScalarWhereWithAggregatesInput>
    commentID?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    notes?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    endorsementID?: StringNullableWithAggregatesFilter | string | null
    userID?: StringNullableWithAggregatesFilter | string | null
  }

  export type EndorsementWhereInput = {
    AND?: Enumerable<EndorsementWhereInput>
    OR?: Enumerable<EndorsementWhereInput>
    NOT?: Enumerable<EndorsementWhereInput>
    endorsementID?: StringFilter | string
    Status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userID?: StringNullableFilter | string | null
    companyID?: StringNullableFilter | string | null
    Company?: XOR<CompanyRelationFilter, CompanyWhereInput> | null
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    Comment?: XOR<CommentRelationFilter, CommentWhereInput> | null
    Endorse?: EndorseListRelationFilter
    Applicant?: ApplicantListRelationFilter
  }

  export type EndorsementOrderByWithRelationAndSearchRelevanceInput = {
    endorsementID?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
    companyID?: SortOrder
    Company?: CompanyOrderByWithRelationAndSearchRelevanceInput
    User?: UserOrderByWithRelationAndSearchRelevanceInput
    Comment?: CommentOrderByWithRelationAndSearchRelevanceInput
    Endorse?: EndorseOrderByRelationAggregateInput
    Applicant?: ApplicantOrderByRelationAggregateInput
    _relevance?: EndorsementOrderByRelevanceInput
  }

  export type EndorsementWhereUniqueInput = {
    endorsementID?: string
  }

  export type EndorsementOrderByWithAggregationInput = {
    endorsementID?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
    companyID?: SortOrder
    _count?: EndorsementCountOrderByAggregateInput
    _max?: EndorsementMaxOrderByAggregateInput
    _min?: EndorsementMinOrderByAggregateInput
  }

  export type EndorsementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EndorsementScalarWhereWithAggregatesInput>
    OR?: Enumerable<EndorsementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EndorsementScalarWhereWithAggregatesInput>
    endorsementID?: StringWithAggregatesFilter | string
    Status?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    userID?: StringNullableWithAggregatesFilter | string | null
    companyID?: StringNullableWithAggregatesFilter | string | null
  }

  export type EndorseWhereInput = {
    AND?: Enumerable<EndorseWhereInput>
    OR?: Enumerable<EndorseWhereInput>
    NOT?: Enumerable<EndorseWhereInput>
    endorseID?: StringFilter | string
    endorseStatus?: EnumendorseStatusFilter | endorseStatus
    userID?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    feedback?: FeedbackListRelationFilter
    Company?: XOR<CompanyRelationFilter, CompanyWhereInput> | null
    companyID?: StringNullableFilter | string | null
    Endorsement?: EndorsementListRelationFilter
  }

  export type EndorseOrderByWithRelationAndSearchRelevanceInput = {
    endorseID?: SortOrder
    endorseStatus?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationAndSearchRelevanceInput
    feedback?: FeedbackOrderByRelationAggregateInput
    Company?: CompanyOrderByWithRelationAndSearchRelevanceInput
    companyID?: SortOrder
    Endorsement?: EndorsementOrderByRelationAggregateInput
    _relevance?: EndorseOrderByRelevanceInput
  }

  export type EndorseWhereUniqueInput = {
    endorseID?: string
  }

  export type EndorseOrderByWithAggregationInput = {
    endorseID?: SortOrder
    endorseStatus?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    companyID?: SortOrder
    _count?: EndorseCountOrderByAggregateInput
    _max?: EndorseMaxOrderByAggregateInput
    _min?: EndorseMinOrderByAggregateInput
  }

  export type EndorseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EndorseScalarWhereWithAggregatesInput>
    OR?: Enumerable<EndorseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EndorseScalarWhereWithAggregatesInput>
    endorseID?: StringWithAggregatesFilter | string
    endorseStatus?: EnumendorseStatusWithAggregatesFilter | endorseStatus
    userID?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    companyID?: StringNullableWithAggregatesFilter | string | null
  }

  export type FeedbackWhereInput = {
    AND?: Enumerable<FeedbackWhereInput>
    OR?: Enumerable<FeedbackWhereInput>
    NOT?: Enumerable<FeedbackWhereInput>
    feedbackID?: StringFilter | string
    feedback?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    endorseID?: StringNullableFilter | string | null
    userID?: StringNullableFilter | string | null
    Applicant?: XOR<ApplicantRelationFilter, ApplicantWhereInput> | null
    Endorse?: XOR<EndorseRelationFilter, EndorseWhereInput> | null
    User?: XOR<UserRelationFilter, UserWhereInput> | null
    applicantID?: StringNullableFilter | string | null
  }

  export type FeedbackOrderByWithRelationAndSearchRelevanceInput = {
    feedbackID?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    endorseID?: SortOrder
    userID?: SortOrder
    Applicant?: ApplicantOrderByWithRelationAndSearchRelevanceInput
    Endorse?: EndorseOrderByWithRelationAndSearchRelevanceInput
    User?: UserOrderByWithRelationAndSearchRelevanceInput
    applicantID?: SortOrder
    _relevance?: FeedbackOrderByRelevanceInput
  }

  export type FeedbackWhereUniqueInput = {
    feedbackID?: string
    endorseID?: string
    userID?: string
  }

  export type FeedbackOrderByWithAggregationInput = {
    feedbackID?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    endorseID?: SortOrder
    userID?: SortOrder
    applicantID?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FeedbackScalarWhereWithAggregatesInput>
    OR?: Enumerable<FeedbackScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FeedbackScalarWhereWithAggregatesInput>
    feedbackID?: StringWithAggregatesFilter | string
    feedback?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    endorseID?: StringNullableWithAggregatesFilter | string | null
    userID?: StringNullableWithAggregatesFilter | string | null
    applicantID?: StringNullableWithAggregatesFilter | string | null
  }

  export type InterviewerWhereInput = {
    AND?: Enumerable<InterviewerWhereInput>
    OR?: Enumerable<InterviewerWhereInput>
    NOT?: Enumerable<InterviewerWhereInput>
    interviewerID?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userID?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Applicant?: XOR<ApplicantRelationFilter, ApplicantWhereInput> | null
  }

  export type InterviewerOrderByWithRelationAndSearchRelevanceInput = {
    interviewerID?: SortOrder
    createdAt?: SortOrder
    userID?: SortOrder
    User?: UserOrderByWithRelationAndSearchRelevanceInput
    Applicant?: ApplicantOrderByWithRelationAndSearchRelevanceInput
    _relevance?: InterviewerOrderByRelevanceInput
  }

  export type InterviewerWhereUniqueInput = {
    interviewerID?: string
  }

  export type InterviewerOrderByWithAggregationInput = {
    interviewerID?: SortOrder
    createdAt?: SortOrder
    userID?: SortOrder
    _count?: InterviewerCountOrderByAggregateInput
    _max?: InterviewerMaxOrderByAggregateInput
    _min?: InterviewerMinOrderByAggregateInput
  }

  export type InterviewerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InterviewerScalarWhereWithAggregatesInput>
    OR?: Enumerable<InterviewerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InterviewerScalarWhereWithAggregatesInput>
    interviewerID?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    userID?: StringWithAggregatesFilter | string
  }

  export type ApplicantWhereInput = {
    AND?: Enumerable<ApplicantWhereInput>
    OR?: Enumerable<ApplicantWhereInput>
    NOT?: Enumerable<ApplicantWhereInput>
    applicantID?: StringFilter | string
    id?: StringFilter | string
    email?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    status?: EnumapplicantStatusFilter | applicantStatus
    jobPostID?: StringFilter | string
    interviewerID?: StringNullableFilter | string | null
    interviewer?: XOR<InterviewerRelationFilter, InterviewerWhereInput> | null
    JobPost?: XOR<JobPostRelationFilter, JobPostWhereInput>
    Endorsement?: XOR<EndorsementRelationFilter, EndorsementWhereInput> | null
    endorsementID?: StringNullableFilter | string | null
    Profile?: XOR<ProfileRelationFilter, ProfileWhereInput> | null
    FileUpload?: XOR<UploadFileRelationFilter, UploadFileWhereInput> | null
    Notification?: XOR<NotificationRelationFilter, NotificationWhereInput> | null
    notificaitonID?: StringNullableFilter | string | null
    Feedback?: FeedbackListRelationFilter
  }

  export type ApplicantOrderByWithRelationAndSearchRelevanceInput = {
    applicantID?: SortOrder
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    jobPostID?: SortOrder
    interviewerID?: SortOrder
    interviewer?: InterviewerOrderByWithRelationAndSearchRelevanceInput
    JobPost?: JobPostOrderByWithRelationAndSearchRelevanceInput
    Endorsement?: EndorsementOrderByWithRelationAndSearchRelevanceInput
    endorsementID?: SortOrder
    Profile?: ProfileOrderByWithRelationAndSearchRelevanceInput
    FileUpload?: UploadFileOrderByWithRelationAndSearchRelevanceInput
    Notification?: NotificationOrderByWithRelationAndSearchRelevanceInput
    notificaitonID?: SortOrder
    Feedback?: FeedbackOrderByRelationAggregateInput
    _relevance?: ApplicantOrderByRelevanceInput
  }

  export type ApplicantWhereUniqueInput = {
    applicantID?: string
    id?: string
    interviewerID?: string
    notificaitonID?: string
  }

  export type ApplicantOrderByWithAggregationInput = {
    applicantID?: SortOrder
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    jobPostID?: SortOrder
    interviewerID?: SortOrder
    endorsementID?: SortOrder
    notificaitonID?: SortOrder
    _count?: ApplicantCountOrderByAggregateInput
    _max?: ApplicantMaxOrderByAggregateInput
    _min?: ApplicantMinOrderByAggregateInput
  }

  export type ApplicantScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ApplicantScalarWhereWithAggregatesInput>
    OR?: Enumerable<ApplicantScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ApplicantScalarWhereWithAggregatesInput>
    applicantID?: StringWithAggregatesFilter | string
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    status?: EnumapplicantStatusWithAggregatesFilter | applicantStatus
    jobPostID?: StringWithAggregatesFilter | string
    interviewerID?: StringNullableWithAggregatesFilter | string | null
    endorsementID?: StringNullableWithAggregatesFilter | string | null
    notificaitonID?: StringNullableWithAggregatesFilter | string | null
  }

  export type UploadFileWhereInput = {
    AND?: Enumerable<UploadFileWhereInput>
    OR?: Enumerable<UploadFileWhereInput>
    NOT?: Enumerable<UploadFileWhereInput>
    uploadFileID?: StringFilter | string
    file?: StringFilter | string
    video?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    applicantID?: StringNullableFilter | string | null
    Applicant?: XOR<ApplicantRelationFilter, ApplicantWhereInput> | null
  }

  export type UploadFileOrderByWithRelationAndSearchRelevanceInput = {
    uploadFileID?: SortOrder
    file?: SortOrder
    video?: SortOrder
    createdAt?: SortOrder
    applicantID?: SortOrder
    Applicant?: ApplicantOrderByWithRelationAndSearchRelevanceInput
    _relevance?: UploadFileOrderByRelevanceInput
  }

  export type UploadFileWhereUniqueInput = {
    uploadFileID?: string
    applicantID?: string
  }

  export type UploadFileOrderByWithAggregationInput = {
    uploadFileID?: SortOrder
    file?: SortOrder
    video?: SortOrder
    createdAt?: SortOrder
    applicantID?: SortOrder
    _count?: UploadFileCountOrderByAggregateInput
    _max?: UploadFileMaxOrderByAggregateInput
    _min?: UploadFileMinOrderByAggregateInput
  }

  export type UploadFileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UploadFileScalarWhereWithAggregatesInput>
    OR?: Enumerable<UploadFileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UploadFileScalarWhereWithAggregatesInput>
    uploadFileID?: StringWithAggregatesFilter | string
    file?: StringWithAggregatesFilter | string
    video?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    applicantID?: StringNullableWithAggregatesFilter | string | null
  }

  export type JobPostWhereInput = {
    AND?: Enumerable<JobPostWhereInput>
    OR?: Enumerable<JobPostWhereInput>
    NOT?: Enumerable<JobPostWhereInput>
    jobPostID?: StringFilter | string
    title?: StringFilter | string
    description?: StringFilter | string
    qualification?: StringFilter | string
    responsibilities?: StringFilter | string
    status?: EnumJobStatusFilter | JobStatus
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    companyID?: StringFilter | string
    notificationID?: StringNullableFilter | string | null
    userID?: StringFilter | string
    Company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    Notification?: XOR<NotificationRelationFilter, NotificationWhereInput> | null
    User?: XOR<UserRelationFilter, UserWhereInput>
    Applicants?: ApplicantListRelationFilter
    details?: XOR<JobDetailsRelationFilter, JobDetailsWhereInput> | null
  }

  export type JobPostOrderByWithRelationAndSearchRelevanceInput = {
    jobPostID?: SortOrder
    title?: SortOrder
    description?: SortOrder
    qualification?: SortOrder
    responsibilities?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyID?: SortOrder
    notificationID?: SortOrder
    userID?: SortOrder
    Company?: CompanyOrderByWithRelationAndSearchRelevanceInput
    Notification?: NotificationOrderByWithRelationAndSearchRelevanceInput
    User?: UserOrderByWithRelationAndSearchRelevanceInput
    Applicants?: ApplicantOrderByRelationAggregateInput
    details?: JobDetailsOrderByWithRelationAndSearchRelevanceInput
    _relevance?: JobPostOrderByRelevanceInput
  }

  export type JobPostWhereUniqueInput = {
    jobPostID?: string
    notificationID?: string
  }

  export type JobPostOrderByWithAggregationInput = {
    jobPostID?: SortOrder
    title?: SortOrder
    description?: SortOrder
    qualification?: SortOrder
    responsibilities?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyID?: SortOrder
    notificationID?: SortOrder
    userID?: SortOrder
    _count?: JobPostCountOrderByAggregateInput
    _max?: JobPostMaxOrderByAggregateInput
    _min?: JobPostMinOrderByAggregateInput
  }

  export type JobPostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JobPostScalarWhereWithAggregatesInput>
    OR?: Enumerable<JobPostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JobPostScalarWhereWithAggregatesInput>
    jobPostID?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    qualification?: StringWithAggregatesFilter | string
    responsibilities?: StringWithAggregatesFilter | string
    status?: EnumJobStatusWithAggregatesFilter | JobStatus
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    companyID?: StringWithAggregatesFilter | string
    notificationID?: StringNullableWithAggregatesFilter | string | null
    userID?: StringWithAggregatesFilter | string
  }

  export type JobDetailsWhereInput = {
    AND?: Enumerable<JobDetailsWhereInput>
    OR?: Enumerable<JobDetailsWhereInput>
    NOT?: Enumerable<JobDetailsWhereInput>
    jobDetailsID?: StringFilter | string
    location?: StringNullableListFilter
    jobType?: StringNullableListFilter
    workType?: StringNullableListFilter
    category?: StringFilter | string
    salary?: StringFilter | string
    jobPostID?: StringNullableFilter | string | null
    JobPost?: XOR<JobPostRelationFilter, JobPostWhereInput> | null
  }

  export type JobDetailsOrderByWithRelationAndSearchRelevanceInput = {
    jobDetailsID?: SortOrder
    location?: SortOrder
    jobType?: SortOrder
    workType?: SortOrder
    category?: SortOrder
    salary?: SortOrder
    jobPostID?: SortOrder
    JobPost?: JobPostOrderByWithRelationAndSearchRelevanceInput
    _relevance?: JobDetailsOrderByRelevanceInput
  }

  export type JobDetailsWhereUniqueInput = {
    jobDetailsID?: string
    jobPostID?: string
  }

  export type JobDetailsOrderByWithAggregationInput = {
    jobDetailsID?: SortOrder
    location?: SortOrder
    jobType?: SortOrder
    workType?: SortOrder
    category?: SortOrder
    salary?: SortOrder
    jobPostID?: SortOrder
    _count?: JobDetailsCountOrderByAggregateInput
    _max?: JobDetailsMaxOrderByAggregateInput
    _min?: JobDetailsMinOrderByAggregateInput
  }

  export type JobDetailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JobDetailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<JobDetailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JobDetailsScalarWhereWithAggregatesInput>
    jobDetailsID?: StringWithAggregatesFilter | string
    location?: StringNullableListFilter
    jobType?: StringNullableListFilter
    workType?: StringNullableListFilter
    category?: StringWithAggregatesFilter | string
    salary?: StringWithAggregatesFilter | string
    jobPostID?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserCreateInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutUserInput
    Comment?: CommentCreateNestedOneWithoutUserInput
    Endorse?: EndorseCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementCreateNestedManyWithoutUserInput
    Feedback?: FeedbackCreateNestedOneWithoutUserInput
    interviewer?: InterviewerCreateNestedManyWithoutUserInput
    JobPost?: JobPostCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedOneWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    Comment?: CommentUncheckedCreateNestedOneWithoutUserInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutUserInput
    Feedback?: FeedbackUncheckedCreateNestedOneWithoutUserInput
    interviewer?: InterviewerUncheckedCreateNestedManyWithoutUserInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutUserNestedInput
    Comment?: CommentUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateOneWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    Comment?: CommentUncheckedUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUncheckedUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUncheckedUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
  }

  export type UserUpdateManyMutationInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
  }

  export type LogsCreateInput = {
    logsID?: string
    title: string
    modifiedBy: string
    createdAt: Date | string
    User?: UserCreateNestedManyWithoutLogsInput
  }

  export type LogsUncheckedCreateInput = {
    logsID?: string
    title: string
    modifiedBy: string
    createdAt: Date | string
    User?: UserUncheckedCreateNestedManyWithoutLogsInput
  }

  export type LogsUpdateInput = {
    logsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    modifiedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateManyWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateInput = {
    logsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    modifiedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUncheckedUpdateManyWithoutLogsNestedInput
  }

  export type LogsCreateManyInput = {
    logsID?: string
    title: string
    modifiedBy: string
    createdAt: Date | string
  }

  export type LogsUpdateManyMutationInput = {
    logsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    modifiedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUncheckedUpdateManyInput = {
    logsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    modifiedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    notificationID?: string
    title: string
    notificationStatus?: notificationStatus
    createdAt: Date | string
    User?: UserCreateNestedOneWithoutNotificationInput
    JobPost?: JobPostCreateNestedOneWithoutNotificationInput
    Applicant?: ApplicantCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    notificationID?: string
    title: string
    notificationStatus?: notificationStatus
    createdAt: Date | string
    userID?: string | null
    JobPost?: JobPostUncheckedCreateNestedOneWithoutNotificationInput
    Applicant?: ApplicantUncheckedCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    notificationID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notificationStatus?: EnumnotificationStatusFieldUpdateOperationsInput | notificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutNotificationNestedInput
    JobPost?: JobPostUpdateOneWithoutNotificationNestedInput
    Applicant?: ApplicantUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    notificationID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notificationStatus?: EnumnotificationStatusFieldUpdateOperationsInput | notificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    JobPost?: JobPostUncheckedUpdateOneWithoutNotificationNestedInput
    Applicant?: ApplicantUncheckedUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    notificationID?: string
    title: string
    notificationStatus?: notificationStatus
    createdAt: Date | string
    userID?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    notificationID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notificationStatus?: EnumnotificationStatusFieldUpdateOperationsInput | notificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    notificationID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notificationStatus?: EnumnotificationStatusFieldUpdateOperationsInput | notificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileCreateInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    birthday?: Date | string | null
    Applicant?: ApplicantCreateNestedOneWithoutProfileInput
    User?: UserCreateNestedOneWithoutProfileInput
    Address?: AddressCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    birthday?: Date | string | null
    applicantID?: string | null
    userID?: string | null
    Address?: AddressUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Applicant?: ApplicantUpdateOneWithoutProfileNestedInput
    User?: UserUpdateOneWithoutProfileNestedInput
    Address?: AddressUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicantID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    birthday?: Date | string | null
    applicantID?: string | null
    userID?: string | null
  }

  export type ProfileUpdateManyMutationInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfileUncheckedUpdateManyInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicantID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressCreateInput = {
    addressID?: string
    city: string
    province: string
    zipcode: string
    street: string
    Company_Details?: CompanyDetailsCreateNestedOneWithoutLocationInput
    Profile?: ProfileCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    addressID?: string
    city: string
    province: string
    zipcode: string
    street: string
    profileID?: string | null
    companyDetailsID?: string | null
  }

  export type AddressUpdateInput = {
    addressID?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    Company_Details?: CompanyDetailsUpdateOneWithoutLocationNestedInput
    Profile?: ProfileUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    addressID?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    profileID?: NullableStringFieldUpdateOperationsInput | string | null
    companyDetailsID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressCreateManyInput = {
    addressID?: string
    city: string
    province: string
    zipcode: string
    street: string
    profileID?: string | null
    companyDetailsID?: string | null
  }

  export type AddressUpdateManyMutationInput = {
    addressID?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    addressID?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    profileID?: NullableStringFieldUpdateOperationsInput | string | null
    companyDetailsID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyCreateInput = {
    companyID?: string
    companyName: string
    details?: CompanyDetailsCreateNestedOneWithoutCompanyInput
    createdAt?: Date | string | null
    Endorse?: EndorseCreateNestedManyWithoutCompanyInput
    Endorsement?: EndorsementCreateNestedManyWithoutCompanyInput
    jobPost?: JobPostCreateNestedManyWithoutCompanyInput
    User?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    companyID?: string
    companyName: string
    details?: CompanyDetailsUncheckedCreateNestedOneWithoutCompanyInput
    createdAt?: Date | string | null
    Endorse?: EndorseUncheckedCreateNestedManyWithoutCompanyInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutCompanyInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutCompanyInput
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    details?: CompanyDetailsUpdateOneWithoutCompanyNestedInput
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorse?: EndorseUpdateManyWithoutCompanyNestedInput
    Endorsement?: EndorsementUpdateManyWithoutCompanyNestedInput
    jobPost?: JobPostUpdateManyWithoutCompanyNestedInput
    User?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    details?: CompanyDetailsUncheckedUpdateOneWithoutCompanyNestedInput
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorse?: EndorseUncheckedUpdateManyWithoutCompanyNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutCompanyNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutCompanyNestedInput
    User?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    companyID?: string
    companyName: string
    createdAt?: Date | string | null
  }

  export type CompanyUpdateManyMutationInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyUncheckedUpdateManyInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompanyDetailsCreateInput = {
    companyDetailsID?: string
    description: string
    mission?: string | null
    vision?: string | null
    Company?: CompanyCreateNestedOneWithoutDetailsInput
    location?: AddressCreateNestedOneWithoutCompany_DetailsInput
  }

  export type CompanyDetailsUncheckedCreateInput = {
    companyDetailsID?: string
    description: string
    mission?: string | null
    vision?: string | null
    companyID?: string | null
    location?: AddressUncheckedCreateNestedOneWithoutCompany_DetailsInput
  }

  export type CompanyDetailsUpdateInput = {
    companyDetailsID?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mission?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    Company?: CompanyUpdateOneWithoutDetailsNestedInput
    location?: AddressUpdateOneWithoutCompany_DetailsNestedInput
  }

  export type CompanyDetailsUncheckedUpdateInput = {
    companyDetailsID?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mission?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
    location?: AddressUncheckedUpdateOneWithoutCompany_DetailsNestedInput
  }

  export type CompanyDetailsCreateManyInput = {
    companyDetailsID?: string
    description: string
    mission?: string | null
    vision?: string | null
    companyID?: string | null
  }

  export type CompanyDetailsUpdateManyMutationInput = {
    companyDetailsID?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mission?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyDetailsUncheckedUpdateManyInput = {
    companyDetailsID?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mission?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateInput = {
    commentID?: string
    message: string
    notes: string
    createdAt: Date | string
    updatedAt: Date | string
    Endorsement?: EndorsementCreateNestedOneWithoutCommentInput
    User?: UserCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    commentID?: string
    message: string
    notes: string
    createdAt: Date | string
    updatedAt: Date | string
    endorsementID?: string | null
    userID?: string | null
  }

  export type CommentUpdateInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Endorsement?: EndorsementUpdateOneWithoutCommentNestedInput
    User?: UserUpdateOneWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateManyInput = {
    commentID?: string
    message: string
    notes: string
    createdAt: Date | string
    updatedAt: Date | string
    endorsementID?: string | null
    userID?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EndorsementCreateInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    Company?: CompanyCreateNestedOneWithoutEndorsementInput
    User?: UserCreateNestedOneWithoutEndorsementInput
    Comment?: CommentCreateNestedOneWithoutEndorsementInput
    Endorse?: EndorseCreateNestedManyWithoutEndorsementInput
    Applicant?: ApplicantCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementUncheckedCreateInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    userID?: string | null
    companyID?: string | null
    Comment?: CommentUncheckedCreateNestedOneWithoutEndorsementInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutEndorsementInput
    Applicant?: ApplicantUncheckedCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementUpdateInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneWithoutEndorsementNestedInput
    User?: UserUpdateOneWithoutEndorsementNestedInput
    Comment?: CommentUpdateOneWithoutEndorsementNestedInput
    Endorse?: EndorseUpdateManyWithoutEndorsementNestedInput
    Applicant?: ApplicantUpdateManyWithoutEndorsementNestedInput
  }

  export type EndorsementUncheckedUpdateInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUncheckedUpdateOneWithoutEndorsementNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutEndorsementNestedInput
    Applicant?: ApplicantUncheckedUpdateManyWithoutEndorsementNestedInput
  }

  export type EndorsementCreateManyInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    userID?: string | null
    companyID?: string | null
  }

  export type EndorsementUpdateManyMutationInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EndorsementUncheckedUpdateManyInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EndorseCreateInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    createdAt: Date | string
    User: UserCreateNestedOneWithoutEndorseInput
    feedback?: FeedbackCreateNestedManyWithoutEndorseInput
    Company?: CompanyCreateNestedOneWithoutEndorseInput
    Endorsement?: EndorsementCreateNestedManyWithoutEndorseInput
  }

  export type EndorseUncheckedCreateInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    userID: string
    createdAt: Date | string
    feedback?: FeedbackUncheckedCreateNestedManyWithoutEndorseInput
    companyID?: string | null
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutEndorseInput
  }

  export type EndorseUpdateInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutEndorseNestedInput
    feedback?: FeedbackUpdateManyWithoutEndorseNestedInput
    Company?: CompanyUpdateOneWithoutEndorseNestedInput
    Endorsement?: EndorsementUpdateManyWithoutEndorseNestedInput
  }

  export type EndorseUncheckedUpdateInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateManyWithoutEndorseNestedInput
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
    Endorsement?: EndorsementUncheckedUpdateManyWithoutEndorseNestedInput
  }

  export type EndorseCreateManyInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    userID: string
    createdAt: Date | string
    companyID?: string | null
  }

  export type EndorseUpdateManyMutationInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EndorseUncheckedUpdateManyInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackCreateInput = {
    feedbackID?: string
    feedback: string
    createdAt: Date | string
    Applicant?: ApplicantCreateNestedOneWithoutFeedbackInput
    Endorse?: EndorseCreateNestedOneWithoutFeedbackInput
    User?: UserCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    feedbackID?: string
    feedback: string
    createdAt: Date | string
    endorseID?: string | null
    userID?: string | null
    applicantID?: string | null
  }

  export type FeedbackUpdateInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Applicant?: ApplicantUpdateOneWithoutFeedbackNestedInput
    Endorse?: EndorseUpdateOneWithoutFeedbackNestedInput
    User?: UserUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endorseID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    applicantID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackCreateManyInput = {
    feedbackID?: string
    feedback: string
    createdAt: Date | string
    endorseID?: string | null
    userID?: string | null
    applicantID?: string | null
  }

  export type FeedbackUpdateManyMutationInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endorseID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    applicantID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InterviewerCreateInput = {
    interviewerID?: string
    createdAt: Date | string
    User: UserCreateNestedOneWithoutInterviewerInput
    Applicant?: ApplicantCreateNestedOneWithoutInterviewerInput
  }

  export type InterviewerUncheckedCreateInput = {
    interviewerID?: string
    createdAt: Date | string
    userID: string
    Applicant?: ApplicantUncheckedCreateNestedOneWithoutInterviewerInput
  }

  export type InterviewerUpdateInput = {
    interviewerID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutInterviewerNestedInput
    Applicant?: ApplicantUpdateOneWithoutInterviewerNestedInput
  }

  export type InterviewerUncheckedUpdateInput = {
    interviewerID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: StringFieldUpdateOperationsInput | string
    Applicant?: ApplicantUncheckedUpdateOneWithoutInterviewerNestedInput
  }

  export type InterviewerCreateManyInput = {
    interviewerID?: string
    createdAt: Date | string
    userID: string
  }

  export type InterviewerUpdateManyMutationInput = {
    interviewerID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewerUncheckedUpdateManyInput = {
    interviewerID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: StringFieldUpdateOperationsInput | string
  }

  export type ApplicantCreateInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    interviewer?: InterviewerCreateNestedOneWithoutApplicantInput
    JobPost: JobPostCreateNestedOneWithoutApplicantsInput
    Endorsement?: EndorsementCreateNestedOneWithoutApplicantInput
    Profile?: ProfileCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileCreateNestedOneWithoutApplicantInput
    Notification?: NotificationCreateNestedOneWithoutApplicantInput
    Feedback?: FeedbackCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    jobPostID: string
    interviewerID?: string | null
    endorsementID?: string | null
    Profile?: ProfileUncheckedCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileUncheckedCreateNestedOneWithoutApplicantInput
    notificaitonID?: string | null
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUpdateInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    interviewer?: InterviewerUpdateOneWithoutApplicantNestedInput
    JobPost?: JobPostUpdateOneRequiredWithoutApplicantsNestedInput
    Endorsement?: EndorsementUpdateOneWithoutApplicantNestedInput
    Profile?: ProfileUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUpdateOneWithoutApplicantNestedInput
    Notification?: NotificationUpdateOneWithoutApplicantNestedInput
    Feedback?: FeedbackUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    jobPostID?: StringFieldUpdateOperationsInput | string
    interviewerID?: NullableStringFieldUpdateOperationsInput | string | null
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
    Profile?: ProfileUncheckedUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUncheckedUpdateOneWithoutApplicantNestedInput
    notificaitonID?: NullableStringFieldUpdateOperationsInput | string | null
    Feedback?: FeedbackUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantCreateManyInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    jobPostID: string
    interviewerID?: string | null
    endorsementID?: string | null
    notificaitonID?: string | null
  }

  export type ApplicantUpdateManyMutationInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
  }

  export type ApplicantUncheckedUpdateManyInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    jobPostID?: StringFieldUpdateOperationsInput | string
    interviewerID?: NullableStringFieldUpdateOperationsInput | string | null
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
    notificaitonID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UploadFileCreateInput = {
    uploadFileID?: string
    file: string
    video: string
    createdAt: Date | string
    Applicant?: ApplicantCreateNestedOneWithoutFileUploadInput
  }

  export type UploadFileUncheckedCreateInput = {
    uploadFileID?: string
    file: string
    video: string
    createdAt: Date | string
    applicantID?: string | null
  }

  export type UploadFileUpdateInput = {
    uploadFileID?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Applicant?: ApplicantUpdateOneWithoutFileUploadNestedInput
  }

  export type UploadFileUncheckedUpdateInput = {
    uploadFileID?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UploadFileCreateManyInput = {
    uploadFileID?: string
    file: string
    video: string
    createdAt: Date | string
    applicantID?: string | null
  }

  export type UploadFileUpdateManyMutationInput = {
    uploadFileID?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadFileUncheckedUpdateManyInput = {
    uploadFileID?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicantID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobPostCreateInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutJobPostInput
    Notification?: NotificationCreateNestedOneWithoutJobPostInput
    User: UserCreateNestedOneWithoutJobPostInput
    Applicants?: ApplicantCreateNestedManyWithoutJobPostInput
    details?: JobDetailsCreateNestedOneWithoutJobPostInput
  }

  export type JobPostUncheckedCreateInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    notificationID?: string | null
    userID: string
    Applicants?: ApplicantUncheckedCreateNestedManyWithoutJobPostInput
    details?: JobDetailsUncheckedCreateNestedOneWithoutJobPostInput
  }

  export type JobPostUpdateInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutJobPostNestedInput
    Notification?: NotificationUpdateOneWithoutJobPostNestedInput
    User?: UserUpdateOneRequiredWithoutJobPostNestedInput
    Applicants?: ApplicantUpdateManyWithoutJobPostNestedInput
    details?: JobDetailsUpdateOneWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    notificationID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: StringFieldUpdateOperationsInput | string
    Applicants?: ApplicantUncheckedUpdateManyWithoutJobPostNestedInput
    details?: JobDetailsUncheckedUpdateOneWithoutJobPostNestedInput
  }

  export type JobPostCreateManyInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    notificationID?: string | null
    userID: string
  }

  export type JobPostUpdateManyMutationInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPostUncheckedUpdateManyInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    notificationID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: StringFieldUpdateOperationsInput | string
  }

  export type JobDetailsCreateInput = {
    jobDetailsID?: string
    location?: JobDetailsCreatelocationInput | Enumerable<string>
    jobType?: JobDetailsCreatejobTypeInput | Enumerable<string>
    workType?: JobDetailsCreateworkTypeInput | Enumerable<string>
    category: string
    salary: string
    JobPost?: JobPostCreateNestedOneWithoutDetailsInput
  }

  export type JobDetailsUncheckedCreateInput = {
    jobDetailsID?: string
    location?: JobDetailsCreatelocationInput | Enumerable<string>
    jobType?: JobDetailsCreatejobTypeInput | Enumerable<string>
    workType?: JobDetailsCreateworkTypeInput | Enumerable<string>
    category: string
    salary: string
    jobPostID?: string | null
  }

  export type JobDetailsUpdateInput = {
    jobDetailsID?: StringFieldUpdateOperationsInput | string
    location?: JobDetailsUpdatelocationInput | Enumerable<string>
    jobType?: JobDetailsUpdatejobTypeInput | Enumerable<string>
    workType?: JobDetailsUpdateworkTypeInput | Enumerable<string>
    category?: StringFieldUpdateOperationsInput | string
    salary?: StringFieldUpdateOperationsInput | string
    JobPost?: JobPostUpdateOneWithoutDetailsNestedInput
  }

  export type JobDetailsUncheckedUpdateInput = {
    jobDetailsID?: StringFieldUpdateOperationsInput | string
    location?: JobDetailsUpdatelocationInput | Enumerable<string>
    jobType?: JobDetailsUpdatejobTypeInput | Enumerable<string>
    workType?: JobDetailsUpdateworkTypeInput | Enumerable<string>
    category?: StringFieldUpdateOperationsInput | string
    salary?: StringFieldUpdateOperationsInput | string
    jobPostID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobDetailsCreateManyInput = {
    jobDetailsID?: string
    location?: JobDetailsCreatelocationInput | Enumerable<string>
    jobType?: JobDetailsCreatejobTypeInput | Enumerable<string>
    workType?: JobDetailsCreateworkTypeInput | Enumerable<string>
    category: string
    salary: string
    jobPostID?: string | null
  }

  export type JobDetailsUpdateManyMutationInput = {
    jobDetailsID?: StringFieldUpdateOperationsInput | string
    location?: JobDetailsUpdatelocationInput | Enumerable<string>
    jobType?: JobDetailsUpdatejobTypeInput | Enumerable<string>
    workType?: JobDetailsUpdateworkTypeInput | Enumerable<string>
    category?: StringFieldUpdateOperationsInput | string
    salary?: StringFieldUpdateOperationsInput | string
  }

  export type JobDetailsUncheckedUpdateManyInput = {
    jobDetailsID?: StringFieldUpdateOperationsInput | string
    location?: JobDetailsUpdatelocationInput | Enumerable<string>
    jobType?: JobDetailsUpdatejobTypeInput | Enumerable<string>
    workType?: JobDetailsUpdateworkTypeInput | Enumerable<string>
    category?: StringFieldUpdateOperationsInput | string
    salary?: StringFieldUpdateOperationsInput | string
    jobPostID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type EndorseListRelationFilter = {
    every?: EndorseWhereInput
    some?: EndorseWhereInput
    none?: EndorseWhereInput
  }

  export type EndorsementListRelationFilter = {
    every?: EndorsementWhereInput
    some?: EndorsementWhereInput
    none?: EndorsementWhereInput
  }

  export type FeedbackRelationFilter = {
    is?: FeedbackWhereInput | null
    isNot?: FeedbackWhereInput | null
  }

  export type InterviewerListRelationFilter = {
    every?: InterviewerWhereInput
    some?: InterviewerWhereInput
    none?: InterviewerWhereInput
  }

  export type JobPostListRelationFilter = {
    every?: JobPostWhereInput
    some?: JobPostWhereInput
    none?: JobPostWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type LogsListRelationFilter = {
    every?: LogsWhereInput
    some?: LogsWhereInput
    none?: LogsWhereInput
  }

  export type EndorseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EndorsementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: Enumerable<UserOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    userID?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyID?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    userID?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyID?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    userID?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyID?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogsOrderByRelevanceInput = {
    fields: Enumerable<LogsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type LogsCountOrderByAggregateInput = {
    logsID?: SortOrder
    title?: SortOrder
    modifiedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type LogsMaxOrderByAggregateInput = {
    logsID?: SortOrder
    title?: SortOrder
    modifiedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type LogsMinOrderByAggregateInput = {
    logsID?: SortOrder
    title?: SortOrder
    modifiedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumnotificationStatusFilter = {
    equals?: notificationStatus
    in?: Enumerable<notificationStatus>
    notIn?: Enumerable<notificationStatus>
    not?: NestedEnumnotificationStatusFilter | notificationStatus
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type JobPostRelationFilter = {
    is?: JobPostWhereInput | null
    isNot?: JobPostWhereInput | null
  }

  export type ApplicantRelationFilter = {
    is?: ApplicantWhereInput | null
    isNot?: ApplicantWhereInput | null
  }

  export type NotificationOrderByRelevanceInput = {
    fields: Enumerable<NotificationOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    notificationID?: SortOrder
    title?: SortOrder
    notificationStatus?: SortOrder
    createdAt?: SortOrder
    userID?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    notificationID?: SortOrder
    title?: SortOrder
    notificationStatus?: SortOrder
    createdAt?: SortOrder
    userID?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    notificationID?: SortOrder
    title?: SortOrder
    notificationStatus?: SortOrder
    createdAt?: SortOrder
    userID?: SortOrder
  }

  export type EnumnotificationStatusWithAggregatesFilter = {
    equals?: notificationStatus
    in?: Enumerable<notificationStatus>
    notIn?: Enumerable<notificationStatus>
    not?: NestedEnumnotificationStatusWithAggregatesFilter | notificationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumnotificationStatusFilter
    _max?: NestedEnumnotificationStatusFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type AddressRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type ProfileOrderByRelevanceInput = {
    fields: Enumerable<ProfileOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ProfileCountOrderByAggregateInput = {
    profileID?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone?: SortOrder
    birthday?: SortOrder
    applicantID?: SortOrder
    userID?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    profileID?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone?: SortOrder
    birthday?: SortOrder
    applicantID?: SortOrder
    userID?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    profileID?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    phone?: SortOrder
    birthday?: SortOrder
    applicantID?: SortOrder
    userID?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type CompanyDetailsRelationFilter = {
    is?: CompanyDetailsWhereInput | null
    isNot?: CompanyDetailsWhereInput | null
  }

  export type AddressOrderByRelevanceInput = {
    fields: Enumerable<AddressOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type AddressCountOrderByAggregateInput = {
    addressID?: SortOrder
    city?: SortOrder
    province?: SortOrder
    zipcode?: SortOrder
    street?: SortOrder
    profileID?: SortOrder
    companyDetailsID?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    addressID?: SortOrder
    city?: SortOrder
    province?: SortOrder
    zipcode?: SortOrder
    street?: SortOrder
    profileID?: SortOrder
    companyDetailsID?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    addressID?: SortOrder
    city?: SortOrder
    province?: SortOrder
    zipcode?: SortOrder
    street?: SortOrder
    profileID?: SortOrder
    companyDetailsID?: SortOrder
  }

  export type CompanyOrderByRelevanceInput = {
    fields: Enumerable<CompanyOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CompanyCountOrderByAggregateInput = {
    companyID?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    companyID?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    companyID?: SortOrder
    companyName?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyDetailsOrderByRelevanceInput = {
    fields: Enumerable<CompanyDetailsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CompanyDetailsCountOrderByAggregateInput = {
    companyDetailsID?: SortOrder
    description?: SortOrder
    mission?: SortOrder
    vision?: SortOrder
    companyID?: SortOrder
  }

  export type CompanyDetailsMaxOrderByAggregateInput = {
    companyDetailsID?: SortOrder
    description?: SortOrder
    mission?: SortOrder
    vision?: SortOrder
    companyID?: SortOrder
  }

  export type CompanyDetailsMinOrderByAggregateInput = {
    companyDetailsID?: SortOrder
    description?: SortOrder
    mission?: SortOrder
    vision?: SortOrder
    companyID?: SortOrder
  }

  export type EndorsementRelationFilter = {
    is?: EndorsementWhereInput | null
    isNot?: EndorsementWhereInput | null
  }

  export type CommentOrderByRelevanceInput = {
    fields: Enumerable<CommentOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type CommentCountOrderByAggregateInput = {
    commentID?: SortOrder
    message?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endorsementID?: SortOrder
    userID?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    commentID?: SortOrder
    message?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endorsementID?: SortOrder
    userID?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    commentID?: SortOrder
    message?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    endorsementID?: SortOrder
    userID?: SortOrder
  }

  export type ApplicantListRelationFilter = {
    every?: ApplicantWhereInput
    some?: ApplicantWhereInput
    none?: ApplicantWhereInput
  }

  export type ApplicantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EndorsementOrderByRelevanceInput = {
    fields: Enumerable<EndorsementOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type EndorsementCountOrderByAggregateInput = {
    endorsementID?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
    companyID?: SortOrder
  }

  export type EndorsementMaxOrderByAggregateInput = {
    endorsementID?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
    companyID?: SortOrder
  }

  export type EndorsementMinOrderByAggregateInput = {
    endorsementID?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userID?: SortOrder
    companyID?: SortOrder
  }

  export type EnumendorseStatusFilter = {
    equals?: endorseStatus
    in?: Enumerable<endorseStatus>
    notIn?: Enumerable<endorseStatus>
    not?: NestedEnumendorseStatusFilter | endorseStatus
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EndorseOrderByRelevanceInput = {
    fields: Enumerable<EndorseOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type EndorseCountOrderByAggregateInput = {
    endorseID?: SortOrder
    endorseStatus?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    companyID?: SortOrder
  }

  export type EndorseMaxOrderByAggregateInput = {
    endorseID?: SortOrder
    endorseStatus?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    companyID?: SortOrder
  }

  export type EndorseMinOrderByAggregateInput = {
    endorseID?: SortOrder
    endorseStatus?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    companyID?: SortOrder
  }

  export type EnumendorseStatusWithAggregatesFilter = {
    equals?: endorseStatus
    in?: Enumerable<endorseStatus>
    notIn?: Enumerable<endorseStatus>
    not?: NestedEnumendorseStatusWithAggregatesFilter | endorseStatus
    _count?: NestedIntFilter
    _min?: NestedEnumendorseStatusFilter
    _max?: NestedEnumendorseStatusFilter
  }

  export type EndorseRelationFilter = {
    is?: EndorseWhereInput | null
    isNot?: EndorseWhereInput | null
  }

  export type FeedbackOrderByRelevanceInput = {
    fields: Enumerable<FeedbackOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type FeedbackCountOrderByAggregateInput = {
    feedbackID?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    endorseID?: SortOrder
    userID?: SortOrder
    applicantID?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    feedbackID?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    endorseID?: SortOrder
    userID?: SortOrder
    applicantID?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    feedbackID?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    endorseID?: SortOrder
    userID?: SortOrder
    applicantID?: SortOrder
  }

  export type InterviewerOrderByRelevanceInput = {
    fields: Enumerable<InterviewerOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type InterviewerCountOrderByAggregateInput = {
    interviewerID?: SortOrder
    createdAt?: SortOrder
    userID?: SortOrder
  }

  export type InterviewerMaxOrderByAggregateInput = {
    interviewerID?: SortOrder
    createdAt?: SortOrder
    userID?: SortOrder
  }

  export type InterviewerMinOrderByAggregateInput = {
    interviewerID?: SortOrder
    createdAt?: SortOrder
    userID?: SortOrder
  }

  export type EnumapplicantStatusFilter = {
    equals?: applicantStatus
    in?: Enumerable<applicantStatus>
    notIn?: Enumerable<applicantStatus>
    not?: NestedEnumapplicantStatusFilter | applicantStatus
  }

  export type InterviewerRelationFilter = {
    is?: InterviewerWhereInput | null
    isNot?: InterviewerWhereInput | null
  }

  export type UploadFileRelationFilter = {
    is?: UploadFileWhereInput | null
    isNot?: UploadFileWhereInput | null
  }

  export type NotificationRelationFilter = {
    is?: NotificationWhereInput | null
    isNot?: NotificationWhereInput | null
  }

  export type ApplicantOrderByRelevanceInput = {
    fields: Enumerable<ApplicantOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type ApplicantCountOrderByAggregateInput = {
    applicantID?: SortOrder
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    jobPostID?: SortOrder
    interviewerID?: SortOrder
    endorsementID?: SortOrder
    notificaitonID?: SortOrder
  }

  export type ApplicantMaxOrderByAggregateInput = {
    applicantID?: SortOrder
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    jobPostID?: SortOrder
    interviewerID?: SortOrder
    endorsementID?: SortOrder
    notificaitonID?: SortOrder
  }

  export type ApplicantMinOrderByAggregateInput = {
    applicantID?: SortOrder
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    jobPostID?: SortOrder
    interviewerID?: SortOrder
    endorsementID?: SortOrder
    notificaitonID?: SortOrder
  }

  export type EnumapplicantStatusWithAggregatesFilter = {
    equals?: applicantStatus
    in?: Enumerable<applicantStatus>
    notIn?: Enumerable<applicantStatus>
    not?: NestedEnumapplicantStatusWithAggregatesFilter | applicantStatus
    _count?: NestedIntFilter
    _min?: NestedEnumapplicantStatusFilter
    _max?: NestedEnumapplicantStatusFilter
  }

  export type UploadFileOrderByRelevanceInput = {
    fields: Enumerable<UploadFileOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type UploadFileCountOrderByAggregateInput = {
    uploadFileID?: SortOrder
    file?: SortOrder
    video?: SortOrder
    createdAt?: SortOrder
    applicantID?: SortOrder
  }

  export type UploadFileMaxOrderByAggregateInput = {
    uploadFileID?: SortOrder
    file?: SortOrder
    video?: SortOrder
    createdAt?: SortOrder
    applicantID?: SortOrder
  }

  export type UploadFileMinOrderByAggregateInput = {
    uploadFileID?: SortOrder
    file?: SortOrder
    video?: SortOrder
    createdAt?: SortOrder
    applicantID?: SortOrder
  }

  export type EnumJobStatusFilter = {
    equals?: JobStatus
    in?: Enumerable<JobStatus>
    notIn?: Enumerable<JobStatus>
    not?: NestedEnumJobStatusFilter | JobStatus
  }

  export type JobDetailsRelationFilter = {
    is?: JobDetailsWhereInput | null
    isNot?: JobDetailsWhereInput | null
  }

  export type JobPostOrderByRelevanceInput = {
    fields: Enumerable<JobPostOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type JobPostCountOrderByAggregateInput = {
    jobPostID?: SortOrder
    title?: SortOrder
    description?: SortOrder
    qualification?: SortOrder
    responsibilities?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyID?: SortOrder
    notificationID?: SortOrder
    userID?: SortOrder
  }

  export type JobPostMaxOrderByAggregateInput = {
    jobPostID?: SortOrder
    title?: SortOrder
    description?: SortOrder
    qualification?: SortOrder
    responsibilities?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyID?: SortOrder
    notificationID?: SortOrder
    userID?: SortOrder
  }

  export type JobPostMinOrderByAggregateInput = {
    jobPostID?: SortOrder
    title?: SortOrder
    description?: SortOrder
    qualification?: SortOrder
    responsibilities?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyID?: SortOrder
    notificationID?: SortOrder
    userID?: SortOrder
  }

  export type EnumJobStatusWithAggregatesFilter = {
    equals?: JobStatus
    in?: Enumerable<JobStatus>
    notIn?: Enumerable<JobStatus>
    not?: NestedEnumJobStatusWithAggregatesFilter | JobStatus
    _count?: NestedIntFilter
    _min?: NestedEnumJobStatusFilter
    _max?: NestedEnumJobStatusFilter
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type JobDetailsOrderByRelevanceInput = {
    fields: Enumerable<JobDetailsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type JobDetailsCountOrderByAggregateInput = {
    jobDetailsID?: SortOrder
    location?: SortOrder
    jobType?: SortOrder
    workType?: SortOrder
    category?: SortOrder
    salary?: SortOrder
    jobPostID?: SortOrder
  }

  export type JobDetailsMaxOrderByAggregateInput = {
    jobDetailsID?: SortOrder
    category?: SortOrder
    salary?: SortOrder
    jobPostID?: SortOrder
  }

  export type JobDetailsMinOrderByAggregateInput = {
    jobDetailsID?: SortOrder
    category?: SortOrder
    salary?: SortOrder
    jobPostID?: SortOrder
  }

  export type CompanyCreateNestedOneWithoutUserInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput
    connect?: CompanyWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput
    connect?: CommentWhereUniqueInput
  }

  export type EndorseCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutUserInput>, Enumerable<EndorseUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutUserInput>
    createMany?: EndorseCreateManyUserInputEnvelope
    connect?: Enumerable<EndorseWhereUniqueInput>
  }

  export type EndorsementCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutUserInput>, Enumerable<EndorsementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutUserInput>
    createMany?: EndorsementCreateManyUserInputEnvelope
    connect?: Enumerable<EndorsementWhereUniqueInput>
  }

  export type FeedbackCreateNestedOneWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput
    connect?: FeedbackWhereUniqueInput
  }

  export type InterviewerCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<InterviewerCreateWithoutUserInput>, Enumerable<InterviewerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InterviewerCreateOrConnectWithoutUserInput>
    createMany?: InterviewerCreateManyUserInputEnvelope
    connect?: Enumerable<InterviewerWhereUniqueInput>
  }

  export type JobPostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<JobPostCreateWithoutUserInput>, Enumerable<JobPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<JobPostCreateOrConnectWithoutUserInput>
    createMany?: JobPostCreateManyUserInputEnvelope
    connect?: Enumerable<JobPostWhereUniqueInput>
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type LogsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LogsCreateWithoutUserInput>, Enumerable<LogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LogsCreateOrConnectWithoutUserInput>
    connect?: Enumerable<LogsWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput
    connect?: CommentWhereUniqueInput
  }

  export type EndorseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutUserInput>, Enumerable<EndorseUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutUserInput>
    createMany?: EndorseCreateManyUserInputEnvelope
    connect?: Enumerable<EndorseWhereUniqueInput>
  }

  export type EndorsementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutUserInput>, Enumerable<EndorsementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutUserInput>
    createMany?: EndorsementCreateManyUserInputEnvelope
    connect?: Enumerable<EndorsementWhereUniqueInput>
  }

  export type FeedbackUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput
    connect?: FeedbackWhereUniqueInput
  }

  export type InterviewerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<InterviewerCreateWithoutUserInput>, Enumerable<InterviewerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InterviewerCreateOrConnectWithoutUserInput>
    createMany?: InterviewerCreateManyUserInputEnvelope
    connect?: Enumerable<InterviewerWhereUniqueInput>
  }

  export type JobPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<JobPostCreateWithoutUserInput>, Enumerable<JobPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<JobPostCreateOrConnectWithoutUserInput>
    createMany?: JobPostCreateManyUserInputEnvelope
    connect?: Enumerable<JobPostWhereUniqueInput>
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type LogsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LogsCreateWithoutUserInput>, Enumerable<LogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LogsCreateOrConnectWithoutUserInput>
    connect?: Enumerable<LogsWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CompanyUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUserInput
    upsert?: CompanyUpsertWithoutUserInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutUserInput, CompanyUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateOneWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput
    upsert?: CommentUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type EndorseUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutUserInput>, Enumerable<EndorseUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EndorseUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EndorseCreateManyUserInputEnvelope
    set?: Enumerable<EndorseWhereUniqueInput>
    disconnect?: Enumerable<EndorseWhereUniqueInput>
    delete?: Enumerable<EndorseWhereUniqueInput>
    connect?: Enumerable<EndorseWhereUniqueInput>
    update?: Enumerable<EndorseUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EndorseUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EndorseScalarWhereInput>
  }

  export type EndorsementUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutUserInput>, Enumerable<EndorsementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EndorsementUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EndorsementCreateManyUserInputEnvelope
    set?: Enumerable<EndorsementWhereUniqueInput>
    disconnect?: Enumerable<EndorsementWhereUniqueInput>
    delete?: Enumerable<EndorsementWhereUniqueInput>
    connect?: Enumerable<EndorsementWhereUniqueInput>
    update?: Enumerable<EndorsementUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EndorsementUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EndorsementScalarWhereInput>
  }

  export type FeedbackUpdateOneWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput
    upsert?: FeedbackUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: FeedbackWhereUniqueInput
    update?: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
  }

  export type InterviewerUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<InterviewerCreateWithoutUserInput>, Enumerable<InterviewerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InterviewerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<InterviewerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: InterviewerCreateManyUserInputEnvelope
    set?: Enumerable<InterviewerWhereUniqueInput>
    disconnect?: Enumerable<InterviewerWhereUniqueInput>
    delete?: Enumerable<InterviewerWhereUniqueInput>
    connect?: Enumerable<InterviewerWhereUniqueInput>
    update?: Enumerable<InterviewerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<InterviewerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<InterviewerScalarWhereInput>
  }

  export type JobPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<JobPostCreateWithoutUserInput>, Enumerable<JobPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<JobPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<JobPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: JobPostCreateManyUserInputEnvelope
    set?: Enumerable<JobPostWhereUniqueInput>
    disconnect?: Enumerable<JobPostWhereUniqueInput>
    delete?: Enumerable<JobPostWhereUniqueInput>
    connect?: Enumerable<JobPostWhereUniqueInput>
    update?: Enumerable<JobPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<JobPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<JobPostScalarWhereInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type LogsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LogsCreateWithoutUserInput>, Enumerable<LogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LogsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LogsUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<LogsWhereUniqueInput>
    disconnect?: Enumerable<LogsWhereUniqueInput>
    delete?: Enumerable<LogsWhereUniqueInput>
    connect?: Enumerable<LogsWhereUniqueInput>
    update?: Enumerable<LogsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LogsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LogsScalarWhereInput>
  }

  export type CommentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput
    upsert?: CommentUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type EndorseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutUserInput>, Enumerable<EndorseUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EndorseUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EndorseCreateManyUserInputEnvelope
    set?: Enumerable<EndorseWhereUniqueInput>
    disconnect?: Enumerable<EndorseWhereUniqueInput>
    delete?: Enumerable<EndorseWhereUniqueInput>
    connect?: Enumerable<EndorseWhereUniqueInput>
    update?: Enumerable<EndorseUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EndorseUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EndorseScalarWhereInput>
  }

  export type EndorsementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutUserInput>, Enumerable<EndorsementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<EndorsementUpsertWithWhereUniqueWithoutUserInput>
    createMany?: EndorsementCreateManyUserInputEnvelope
    set?: Enumerable<EndorsementWhereUniqueInput>
    disconnect?: Enumerable<EndorsementWhereUniqueInput>
    delete?: Enumerable<EndorsementWhereUniqueInput>
    connect?: Enumerable<EndorsementWhereUniqueInput>
    update?: Enumerable<EndorsementUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<EndorsementUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<EndorsementScalarWhereInput>
  }

  export type FeedbackUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput
    upsert?: FeedbackUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: FeedbackWhereUniqueInput
    update?: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
  }

  export type InterviewerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<InterviewerCreateWithoutUserInput>, Enumerable<InterviewerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<InterviewerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<InterviewerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: InterviewerCreateManyUserInputEnvelope
    set?: Enumerable<InterviewerWhereUniqueInput>
    disconnect?: Enumerable<InterviewerWhereUniqueInput>
    delete?: Enumerable<InterviewerWhereUniqueInput>
    connect?: Enumerable<InterviewerWhereUniqueInput>
    update?: Enumerable<InterviewerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<InterviewerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<InterviewerScalarWhereInput>
  }

  export type JobPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<JobPostCreateWithoutUserInput>, Enumerable<JobPostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<JobPostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<JobPostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: JobPostCreateManyUserInputEnvelope
    set?: Enumerable<JobPostWhereUniqueInput>
    disconnect?: Enumerable<JobPostWhereUniqueInput>
    delete?: Enumerable<JobPostWhereUniqueInput>
    connect?: Enumerable<JobPostWhereUniqueInput>
    update?: Enumerable<JobPostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<JobPostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<JobPostScalarWhereInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutUserInput>, Enumerable<NotificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutUserInput>
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type LogsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LogsCreateWithoutUserInput>, Enumerable<LogsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LogsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LogsUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<LogsWhereUniqueInput>
    disconnect?: Enumerable<LogsWhereUniqueInput>
    delete?: Enumerable<LogsWhereUniqueInput>
    connect?: Enumerable<LogsWhereUniqueInput>
    update?: Enumerable<LogsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LogsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LogsScalarWhereInput>
  }

  export type UserCreateNestedManyWithoutLogsInput = {
    create?: XOR<Enumerable<UserCreateWithoutLogsInput>, Enumerable<UserUncheckedCreateWithoutLogsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLogsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutLogsInput = {
    create?: XOR<Enumerable<UserCreateWithoutLogsInput>, Enumerable<UserUncheckedCreateWithoutLogsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLogsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUpdateManyWithoutLogsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutLogsInput>, Enumerable<UserUncheckedCreateWithoutLogsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLogsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutLogsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutLogsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutLogsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutLogsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutLogsInput>, Enumerable<UserUncheckedCreateWithoutLogsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLogsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutLogsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutLogsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutLogsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type JobPostCreateNestedOneWithoutNotificationInput = {
    create?: XOR<JobPostCreateWithoutNotificationInput, JobPostUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutNotificationInput
    connect?: JobPostWhereUniqueInput
  }

  export type ApplicantCreateNestedOneWithoutNotificationInput = {
    create?: XOR<ApplicantCreateWithoutNotificationInput, ApplicantUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutNotificationInput
    connect?: ApplicantWhereUniqueInput
  }

  export type JobPostUncheckedCreateNestedOneWithoutNotificationInput = {
    create?: XOR<JobPostCreateWithoutNotificationInput, JobPostUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutNotificationInput
    connect?: JobPostWhereUniqueInput
  }

  export type ApplicantUncheckedCreateNestedOneWithoutNotificationInput = {
    create?: XOR<ApplicantCreateWithoutNotificationInput, ApplicantUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutNotificationInput
    connect?: ApplicantWhereUniqueInput
  }

  export type EnumnotificationStatusFieldUpdateOperationsInput = {
    set?: notificationStatus
  }

  export type UserUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type JobPostUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<JobPostCreateWithoutNotificationInput, JobPostUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutNotificationInput
    upsert?: JobPostUpsertWithoutNotificationInput
    disconnect?: boolean
    delete?: boolean
    connect?: JobPostWhereUniqueInput
    update?: XOR<JobPostUpdateWithoutNotificationInput, JobPostUncheckedUpdateWithoutNotificationInput>
  }

  export type ApplicantUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<ApplicantCreateWithoutNotificationInput, ApplicantUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutNotificationInput
    upsert?: ApplicantUpsertWithoutNotificationInput
    disconnect?: boolean
    delete?: boolean
    connect?: ApplicantWhereUniqueInput
    update?: XOR<ApplicantUpdateWithoutNotificationInput, ApplicantUncheckedUpdateWithoutNotificationInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type JobPostUncheckedUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<JobPostCreateWithoutNotificationInput, JobPostUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutNotificationInput
    upsert?: JobPostUpsertWithoutNotificationInput
    disconnect?: boolean
    delete?: boolean
    connect?: JobPostWhereUniqueInput
    update?: XOR<JobPostUpdateWithoutNotificationInput, JobPostUncheckedUpdateWithoutNotificationInput>
  }

  export type ApplicantUncheckedUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<ApplicantCreateWithoutNotificationInput, ApplicantUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutNotificationInput
    upsert?: ApplicantUpsertWithoutNotificationInput
    disconnect?: boolean
    delete?: boolean
    connect?: ApplicantWhereUniqueInput
    update?: XOR<ApplicantUpdateWithoutNotificationInput, ApplicantUncheckedUpdateWithoutNotificationInput>
  }

  export type ApplicantCreateNestedOneWithoutProfileInput = {
    create?: XOR<ApplicantCreateWithoutProfileInput, ApplicantUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutProfileInput
    connect?: ApplicantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutProfileInput = {
    create?: XOR<AddressCreateWithoutProfileInput, AddressUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AddressCreateOrConnectWithoutProfileInput
    connect?: AddressWhereUniqueInput
  }

  export type AddressUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<AddressCreateWithoutProfileInput, AddressUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AddressCreateOrConnectWithoutProfileInput
    connect?: AddressWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ApplicantUpdateOneWithoutProfileNestedInput = {
    create?: XOR<ApplicantCreateWithoutProfileInput, ApplicantUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutProfileInput
    upsert?: ApplicantUpsertWithoutProfileInput
    disconnect?: boolean
    delete?: boolean
    connect?: ApplicantWhereUniqueInput
    update?: XOR<ApplicantUpdateWithoutProfileInput, ApplicantUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateOneWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type AddressUpdateOneWithoutProfileNestedInput = {
    create?: XOR<AddressCreateWithoutProfileInput, AddressUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AddressCreateOrConnectWithoutProfileInput
    upsert?: AddressUpsertWithoutProfileInput
    disconnect?: boolean
    delete?: boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutProfileInput, AddressUncheckedUpdateWithoutProfileInput>
  }

  export type AddressUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<AddressCreateWithoutProfileInput, AddressUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AddressCreateOrConnectWithoutProfileInput
    upsert?: AddressUpsertWithoutProfileInput
    disconnect?: boolean
    delete?: boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutProfileInput, AddressUncheckedUpdateWithoutProfileInput>
  }

  export type CompanyDetailsCreateNestedOneWithoutLocationInput = {
    create?: XOR<CompanyDetailsCreateWithoutLocationInput, CompanyDetailsUncheckedCreateWithoutLocationInput>
    connectOrCreate?: CompanyDetailsCreateOrConnectWithoutLocationInput
    connect?: CompanyDetailsWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutAddressInput = {
    create?: XOR<ProfileCreateWithoutAddressInput, ProfileUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAddressInput
    connect?: ProfileWhereUniqueInput
  }

  export type CompanyDetailsUpdateOneWithoutLocationNestedInput = {
    create?: XOR<CompanyDetailsCreateWithoutLocationInput, CompanyDetailsUncheckedCreateWithoutLocationInput>
    connectOrCreate?: CompanyDetailsCreateOrConnectWithoutLocationInput
    upsert?: CompanyDetailsUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyDetailsWhereUniqueInput
    update?: XOR<CompanyDetailsUpdateWithoutLocationInput, CompanyDetailsUncheckedUpdateWithoutLocationInput>
  }

  export type ProfileUpdateOneWithoutAddressNestedInput = {
    create?: XOR<ProfileCreateWithoutAddressInput, ProfileUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAddressInput
    upsert?: ProfileUpsertWithoutAddressInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutAddressInput, ProfileUncheckedUpdateWithoutAddressInput>
  }

  export type CompanyDetailsCreateNestedOneWithoutCompanyInput = {
    create?: XOR<CompanyDetailsCreateWithoutCompanyInput, CompanyDetailsUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: CompanyDetailsCreateOrConnectWithoutCompanyInput
    connect?: CompanyDetailsWhereUniqueInput
  }

  export type EndorseCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutCompanyInput>, Enumerable<EndorseUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutCompanyInput>
    createMany?: EndorseCreateManyCompanyInputEnvelope
    connect?: Enumerable<EndorseWhereUniqueInput>
  }

  export type EndorsementCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutCompanyInput>, Enumerable<EndorsementUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutCompanyInput>
    createMany?: EndorsementCreateManyCompanyInputEnvelope
    connect?: Enumerable<EndorsementWhereUniqueInput>
  }

  export type JobPostCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<JobPostCreateWithoutCompanyInput>, Enumerable<JobPostUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<JobPostCreateOrConnectWithoutCompanyInput>
    createMany?: JobPostCreateManyCompanyInputEnvelope
    connect?: Enumerable<JobPostWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type CompanyDetailsUncheckedCreateNestedOneWithoutCompanyInput = {
    create?: XOR<CompanyDetailsCreateWithoutCompanyInput, CompanyDetailsUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: CompanyDetailsCreateOrConnectWithoutCompanyInput
    connect?: CompanyDetailsWhereUniqueInput
  }

  export type EndorseUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutCompanyInput>, Enumerable<EndorseUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutCompanyInput>
    createMany?: EndorseCreateManyCompanyInputEnvelope
    connect?: Enumerable<EndorseWhereUniqueInput>
  }

  export type EndorsementUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutCompanyInput>, Enumerable<EndorsementUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutCompanyInput>
    createMany?: EndorsementCreateManyCompanyInputEnvelope
    connect?: Enumerable<EndorsementWhereUniqueInput>
  }

  export type JobPostUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<JobPostCreateWithoutCompanyInput>, Enumerable<JobPostUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<JobPostCreateOrConnectWithoutCompanyInput>
    createMany?: JobPostCreateManyCompanyInputEnvelope
    connect?: Enumerable<JobPostWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type CompanyDetailsUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<CompanyDetailsCreateWithoutCompanyInput, CompanyDetailsUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: CompanyDetailsCreateOrConnectWithoutCompanyInput
    upsert?: CompanyDetailsUpsertWithoutCompanyInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyDetailsWhereUniqueInput
    update?: XOR<CompanyDetailsUpdateWithoutCompanyInput, CompanyDetailsUncheckedUpdateWithoutCompanyInput>
  }

  export type EndorseUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutCompanyInput>, Enumerable<EndorseUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<EndorseUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: EndorseCreateManyCompanyInputEnvelope
    set?: Enumerable<EndorseWhereUniqueInput>
    disconnect?: Enumerable<EndorseWhereUniqueInput>
    delete?: Enumerable<EndorseWhereUniqueInput>
    connect?: Enumerable<EndorseWhereUniqueInput>
    update?: Enumerable<EndorseUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<EndorseUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<EndorseScalarWhereInput>
  }

  export type EndorsementUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutCompanyInput>, Enumerable<EndorsementUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<EndorsementUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: EndorsementCreateManyCompanyInputEnvelope
    set?: Enumerable<EndorsementWhereUniqueInput>
    disconnect?: Enumerable<EndorsementWhereUniqueInput>
    delete?: Enumerable<EndorsementWhereUniqueInput>
    connect?: Enumerable<EndorsementWhereUniqueInput>
    update?: Enumerable<EndorsementUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<EndorsementUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<EndorsementScalarWhereInput>
  }

  export type JobPostUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<JobPostCreateWithoutCompanyInput>, Enumerable<JobPostUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<JobPostCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<JobPostUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: JobPostCreateManyCompanyInputEnvelope
    set?: Enumerable<JobPostWhereUniqueInput>
    disconnect?: Enumerable<JobPostWhereUniqueInput>
    delete?: Enumerable<JobPostWhereUniqueInput>
    connect?: Enumerable<JobPostWhereUniqueInput>
    update?: Enumerable<JobPostUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<JobPostUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<JobPostScalarWhereInput>
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type CompanyDetailsUncheckedUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<CompanyDetailsCreateWithoutCompanyInput, CompanyDetailsUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: CompanyDetailsCreateOrConnectWithoutCompanyInput
    upsert?: CompanyDetailsUpsertWithoutCompanyInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyDetailsWhereUniqueInput
    update?: XOR<CompanyDetailsUpdateWithoutCompanyInput, CompanyDetailsUncheckedUpdateWithoutCompanyInput>
  }

  export type EndorseUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutCompanyInput>, Enumerable<EndorseUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<EndorseUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: EndorseCreateManyCompanyInputEnvelope
    set?: Enumerable<EndorseWhereUniqueInput>
    disconnect?: Enumerable<EndorseWhereUniqueInput>
    delete?: Enumerable<EndorseWhereUniqueInput>
    connect?: Enumerable<EndorseWhereUniqueInput>
    update?: Enumerable<EndorseUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<EndorseUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<EndorseScalarWhereInput>
  }

  export type EndorsementUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutCompanyInput>, Enumerable<EndorsementUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<EndorsementUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: EndorsementCreateManyCompanyInputEnvelope
    set?: Enumerable<EndorsementWhereUniqueInput>
    disconnect?: Enumerable<EndorsementWhereUniqueInput>
    delete?: Enumerable<EndorsementWhereUniqueInput>
    connect?: Enumerable<EndorsementWhereUniqueInput>
    update?: Enumerable<EndorsementUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<EndorsementUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<EndorsementScalarWhereInput>
  }

  export type JobPostUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<JobPostCreateWithoutCompanyInput>, Enumerable<JobPostUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<JobPostCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<JobPostUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: JobPostCreateManyCompanyInputEnvelope
    set?: Enumerable<JobPostWhereUniqueInput>
    disconnect?: Enumerable<JobPostWhereUniqueInput>
    delete?: Enumerable<JobPostWhereUniqueInput>
    connect?: Enumerable<JobPostWhereUniqueInput>
    update?: Enumerable<JobPostUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<JobPostUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<JobPostScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type CompanyCreateNestedOneWithoutDetailsInput = {
    create?: XOR<CompanyCreateWithoutDetailsInput, CompanyUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDetailsInput
    connect?: CompanyWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutCompany_DetailsInput = {
    create?: XOR<AddressCreateWithoutCompany_DetailsInput, AddressUncheckedCreateWithoutCompany_DetailsInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCompany_DetailsInput
    connect?: AddressWhereUniqueInput
  }

  export type AddressUncheckedCreateNestedOneWithoutCompany_DetailsInput = {
    create?: XOR<AddressCreateWithoutCompany_DetailsInput, AddressUncheckedCreateWithoutCompany_DetailsInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCompany_DetailsInput
    connect?: AddressWhereUniqueInput
  }

  export type CompanyUpdateOneWithoutDetailsNestedInput = {
    create?: XOR<CompanyCreateWithoutDetailsInput, CompanyUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDetailsInput
    upsert?: CompanyUpsertWithoutDetailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutDetailsInput, CompanyUncheckedUpdateWithoutDetailsInput>
  }

  export type AddressUpdateOneWithoutCompany_DetailsNestedInput = {
    create?: XOR<AddressCreateWithoutCompany_DetailsInput, AddressUncheckedCreateWithoutCompany_DetailsInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCompany_DetailsInput
    upsert?: AddressUpsertWithoutCompany_DetailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutCompany_DetailsInput, AddressUncheckedUpdateWithoutCompany_DetailsInput>
  }

  export type AddressUncheckedUpdateOneWithoutCompany_DetailsNestedInput = {
    create?: XOR<AddressCreateWithoutCompany_DetailsInput, AddressUncheckedCreateWithoutCompany_DetailsInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCompany_DetailsInput
    upsert?: AddressUpsertWithoutCompany_DetailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutCompany_DetailsInput, AddressUncheckedUpdateWithoutCompany_DetailsInput>
  }

  export type EndorsementCreateNestedOneWithoutCommentInput = {
    create?: XOR<EndorsementCreateWithoutCommentInput, EndorsementUncheckedCreateWithoutCommentInput>
    connectOrCreate?: EndorsementCreateOrConnectWithoutCommentInput
    connect?: EndorsementWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    connect?: UserWhereUniqueInput
  }

  export type EndorsementUpdateOneWithoutCommentNestedInput = {
    create?: XOR<EndorsementCreateWithoutCommentInput, EndorsementUncheckedCreateWithoutCommentInput>
    connectOrCreate?: EndorsementCreateOrConnectWithoutCommentInput
    upsert?: EndorsementUpsertWithoutCommentInput
    disconnect?: boolean
    delete?: boolean
    connect?: EndorsementWhereUniqueInput
    update?: XOR<EndorsementUpdateWithoutCommentInput, EndorsementUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateOneWithoutCommentNestedInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    upsert?: UserUpsertWithoutCommentInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
  }

  export type CompanyCreateNestedOneWithoutEndorsementInput = {
    create?: XOR<CompanyCreateWithoutEndorsementInput, CompanyUncheckedCreateWithoutEndorsementInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEndorsementInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEndorsementInput = {
    create?: XOR<UserCreateWithoutEndorsementInput, UserUncheckedCreateWithoutEndorsementInput>
    connectOrCreate?: UserCreateOrConnectWithoutEndorsementInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutEndorsementInput = {
    create?: XOR<CommentCreateWithoutEndorsementInput, CommentUncheckedCreateWithoutEndorsementInput>
    connectOrCreate?: CommentCreateOrConnectWithoutEndorsementInput
    connect?: CommentWhereUniqueInput
  }

  export type EndorseCreateNestedManyWithoutEndorsementInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutEndorsementInput>, Enumerable<EndorseUncheckedCreateWithoutEndorsementInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutEndorsementInput>
    connect?: Enumerable<EndorseWhereUniqueInput>
  }

  export type ApplicantCreateNestedManyWithoutEndorsementInput = {
    create?: XOR<Enumerable<ApplicantCreateWithoutEndorsementInput>, Enumerable<ApplicantUncheckedCreateWithoutEndorsementInput>>
    connectOrCreate?: Enumerable<ApplicantCreateOrConnectWithoutEndorsementInput>
    createMany?: ApplicantCreateManyEndorsementInputEnvelope
    connect?: Enumerable<ApplicantWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedOneWithoutEndorsementInput = {
    create?: XOR<CommentCreateWithoutEndorsementInput, CommentUncheckedCreateWithoutEndorsementInput>
    connectOrCreate?: CommentCreateOrConnectWithoutEndorsementInput
    connect?: CommentWhereUniqueInput
  }

  export type EndorseUncheckedCreateNestedManyWithoutEndorsementInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutEndorsementInput>, Enumerable<EndorseUncheckedCreateWithoutEndorsementInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutEndorsementInput>
    connect?: Enumerable<EndorseWhereUniqueInput>
  }

  export type ApplicantUncheckedCreateNestedManyWithoutEndorsementInput = {
    create?: XOR<Enumerable<ApplicantCreateWithoutEndorsementInput>, Enumerable<ApplicantUncheckedCreateWithoutEndorsementInput>>
    connectOrCreate?: Enumerable<ApplicantCreateOrConnectWithoutEndorsementInput>
    createMany?: ApplicantCreateManyEndorsementInputEnvelope
    connect?: Enumerable<ApplicantWhereUniqueInput>
  }

  export type CompanyUpdateOneWithoutEndorsementNestedInput = {
    create?: XOR<CompanyCreateWithoutEndorsementInput, CompanyUncheckedCreateWithoutEndorsementInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEndorsementInput
    upsert?: CompanyUpsertWithoutEndorsementInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutEndorsementInput, CompanyUncheckedUpdateWithoutEndorsementInput>
  }

  export type UserUpdateOneWithoutEndorsementNestedInput = {
    create?: XOR<UserCreateWithoutEndorsementInput, UserUncheckedCreateWithoutEndorsementInput>
    connectOrCreate?: UserCreateOrConnectWithoutEndorsementInput
    upsert?: UserUpsertWithoutEndorsementInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutEndorsementInput, UserUncheckedUpdateWithoutEndorsementInput>
  }

  export type CommentUpdateOneWithoutEndorsementNestedInput = {
    create?: XOR<CommentCreateWithoutEndorsementInput, CommentUncheckedCreateWithoutEndorsementInput>
    connectOrCreate?: CommentCreateOrConnectWithoutEndorsementInput
    upsert?: CommentUpsertWithoutEndorsementInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<CommentUpdateWithoutEndorsementInput, CommentUncheckedUpdateWithoutEndorsementInput>
  }

  export type EndorseUpdateManyWithoutEndorsementNestedInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutEndorsementInput>, Enumerable<EndorseUncheckedCreateWithoutEndorsementInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutEndorsementInput>
    upsert?: Enumerable<EndorseUpsertWithWhereUniqueWithoutEndorsementInput>
    set?: Enumerable<EndorseWhereUniqueInput>
    disconnect?: Enumerable<EndorseWhereUniqueInput>
    delete?: Enumerable<EndorseWhereUniqueInput>
    connect?: Enumerable<EndorseWhereUniqueInput>
    update?: Enumerable<EndorseUpdateWithWhereUniqueWithoutEndorsementInput>
    updateMany?: Enumerable<EndorseUpdateManyWithWhereWithoutEndorsementInput>
    deleteMany?: Enumerable<EndorseScalarWhereInput>
  }

  export type ApplicantUpdateManyWithoutEndorsementNestedInput = {
    create?: XOR<Enumerable<ApplicantCreateWithoutEndorsementInput>, Enumerable<ApplicantUncheckedCreateWithoutEndorsementInput>>
    connectOrCreate?: Enumerable<ApplicantCreateOrConnectWithoutEndorsementInput>
    upsert?: Enumerable<ApplicantUpsertWithWhereUniqueWithoutEndorsementInput>
    createMany?: ApplicantCreateManyEndorsementInputEnvelope
    set?: Enumerable<ApplicantWhereUniqueInput>
    disconnect?: Enumerable<ApplicantWhereUniqueInput>
    delete?: Enumerable<ApplicantWhereUniqueInput>
    connect?: Enumerable<ApplicantWhereUniqueInput>
    update?: Enumerable<ApplicantUpdateWithWhereUniqueWithoutEndorsementInput>
    updateMany?: Enumerable<ApplicantUpdateManyWithWhereWithoutEndorsementInput>
    deleteMany?: Enumerable<ApplicantScalarWhereInput>
  }

  export type CommentUncheckedUpdateOneWithoutEndorsementNestedInput = {
    create?: XOR<CommentCreateWithoutEndorsementInput, CommentUncheckedCreateWithoutEndorsementInput>
    connectOrCreate?: CommentCreateOrConnectWithoutEndorsementInput
    upsert?: CommentUpsertWithoutEndorsementInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<CommentUpdateWithoutEndorsementInput, CommentUncheckedUpdateWithoutEndorsementInput>
  }

  export type EndorseUncheckedUpdateManyWithoutEndorsementNestedInput = {
    create?: XOR<Enumerable<EndorseCreateWithoutEndorsementInput>, Enumerable<EndorseUncheckedCreateWithoutEndorsementInput>>
    connectOrCreate?: Enumerable<EndorseCreateOrConnectWithoutEndorsementInput>
    upsert?: Enumerable<EndorseUpsertWithWhereUniqueWithoutEndorsementInput>
    set?: Enumerable<EndorseWhereUniqueInput>
    disconnect?: Enumerable<EndorseWhereUniqueInput>
    delete?: Enumerable<EndorseWhereUniqueInput>
    connect?: Enumerable<EndorseWhereUniqueInput>
    update?: Enumerable<EndorseUpdateWithWhereUniqueWithoutEndorsementInput>
    updateMany?: Enumerable<EndorseUpdateManyWithWhereWithoutEndorsementInput>
    deleteMany?: Enumerable<EndorseScalarWhereInput>
  }

  export type ApplicantUncheckedUpdateManyWithoutEndorsementNestedInput = {
    create?: XOR<Enumerable<ApplicantCreateWithoutEndorsementInput>, Enumerable<ApplicantUncheckedCreateWithoutEndorsementInput>>
    connectOrCreate?: Enumerable<ApplicantCreateOrConnectWithoutEndorsementInput>
    upsert?: Enumerable<ApplicantUpsertWithWhereUniqueWithoutEndorsementInput>
    createMany?: ApplicantCreateManyEndorsementInputEnvelope
    set?: Enumerable<ApplicantWhereUniqueInput>
    disconnect?: Enumerable<ApplicantWhereUniqueInput>
    delete?: Enumerable<ApplicantWhereUniqueInput>
    connect?: Enumerable<ApplicantWhereUniqueInput>
    update?: Enumerable<ApplicantUpdateWithWhereUniqueWithoutEndorsementInput>
    updateMany?: Enumerable<ApplicantUpdateManyWithWhereWithoutEndorsementInput>
    deleteMany?: Enumerable<ApplicantScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutEndorseInput = {
    create?: XOR<UserCreateWithoutEndorseInput, UserUncheckedCreateWithoutEndorseInput>
    connectOrCreate?: UserCreateOrConnectWithoutEndorseInput
    connect?: UserWhereUniqueInput
  }

  export type FeedbackCreateNestedManyWithoutEndorseInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutEndorseInput>, Enumerable<FeedbackUncheckedCreateWithoutEndorseInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutEndorseInput>
    createMany?: FeedbackCreateManyEndorseInputEnvelope
    connect?: Enumerable<FeedbackWhereUniqueInput>
  }

  export type CompanyCreateNestedOneWithoutEndorseInput = {
    create?: XOR<CompanyCreateWithoutEndorseInput, CompanyUncheckedCreateWithoutEndorseInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEndorseInput
    connect?: CompanyWhereUniqueInput
  }

  export type EndorsementCreateNestedManyWithoutEndorseInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutEndorseInput>, Enumerable<EndorsementUncheckedCreateWithoutEndorseInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutEndorseInput>
    connect?: Enumerable<EndorsementWhereUniqueInput>
  }

  export type FeedbackUncheckedCreateNestedManyWithoutEndorseInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutEndorseInput>, Enumerable<FeedbackUncheckedCreateWithoutEndorseInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutEndorseInput>
    createMany?: FeedbackCreateManyEndorseInputEnvelope
    connect?: Enumerable<FeedbackWhereUniqueInput>
  }

  export type EndorsementUncheckedCreateNestedManyWithoutEndorseInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutEndorseInput>, Enumerable<EndorsementUncheckedCreateWithoutEndorseInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutEndorseInput>
    connect?: Enumerable<EndorsementWhereUniqueInput>
  }

  export type EnumendorseStatusFieldUpdateOperationsInput = {
    set?: endorseStatus
  }

  export type UserUpdateOneRequiredWithoutEndorseNestedInput = {
    create?: XOR<UserCreateWithoutEndorseInput, UserUncheckedCreateWithoutEndorseInput>
    connectOrCreate?: UserCreateOrConnectWithoutEndorseInput
    upsert?: UserUpsertWithoutEndorseInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutEndorseInput, UserUncheckedUpdateWithoutEndorseInput>
  }

  export type FeedbackUpdateManyWithoutEndorseNestedInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutEndorseInput>, Enumerable<FeedbackUncheckedCreateWithoutEndorseInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutEndorseInput>
    upsert?: Enumerable<FeedbackUpsertWithWhereUniqueWithoutEndorseInput>
    createMany?: FeedbackCreateManyEndorseInputEnvelope
    set?: Enumerable<FeedbackWhereUniqueInput>
    disconnect?: Enumerable<FeedbackWhereUniqueInput>
    delete?: Enumerable<FeedbackWhereUniqueInput>
    connect?: Enumerable<FeedbackWhereUniqueInput>
    update?: Enumerable<FeedbackUpdateWithWhereUniqueWithoutEndorseInput>
    updateMany?: Enumerable<FeedbackUpdateManyWithWhereWithoutEndorseInput>
    deleteMany?: Enumerable<FeedbackScalarWhereInput>
  }

  export type CompanyUpdateOneWithoutEndorseNestedInput = {
    create?: XOR<CompanyCreateWithoutEndorseInput, CompanyUncheckedCreateWithoutEndorseInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEndorseInput
    upsert?: CompanyUpsertWithoutEndorseInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutEndorseInput, CompanyUncheckedUpdateWithoutEndorseInput>
  }

  export type EndorsementUpdateManyWithoutEndorseNestedInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutEndorseInput>, Enumerable<EndorsementUncheckedCreateWithoutEndorseInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutEndorseInput>
    upsert?: Enumerable<EndorsementUpsertWithWhereUniqueWithoutEndorseInput>
    set?: Enumerable<EndorsementWhereUniqueInput>
    disconnect?: Enumerable<EndorsementWhereUniqueInput>
    delete?: Enumerable<EndorsementWhereUniqueInput>
    connect?: Enumerable<EndorsementWhereUniqueInput>
    update?: Enumerable<EndorsementUpdateWithWhereUniqueWithoutEndorseInput>
    updateMany?: Enumerable<EndorsementUpdateManyWithWhereWithoutEndorseInput>
    deleteMany?: Enumerable<EndorsementScalarWhereInput>
  }

  export type FeedbackUncheckedUpdateManyWithoutEndorseNestedInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutEndorseInput>, Enumerable<FeedbackUncheckedCreateWithoutEndorseInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutEndorseInput>
    upsert?: Enumerable<FeedbackUpsertWithWhereUniqueWithoutEndorseInput>
    createMany?: FeedbackCreateManyEndorseInputEnvelope
    set?: Enumerable<FeedbackWhereUniqueInput>
    disconnect?: Enumerable<FeedbackWhereUniqueInput>
    delete?: Enumerable<FeedbackWhereUniqueInput>
    connect?: Enumerable<FeedbackWhereUniqueInput>
    update?: Enumerable<FeedbackUpdateWithWhereUniqueWithoutEndorseInput>
    updateMany?: Enumerable<FeedbackUpdateManyWithWhereWithoutEndorseInput>
    deleteMany?: Enumerable<FeedbackScalarWhereInput>
  }

  export type EndorsementUncheckedUpdateManyWithoutEndorseNestedInput = {
    create?: XOR<Enumerable<EndorsementCreateWithoutEndorseInput>, Enumerable<EndorsementUncheckedCreateWithoutEndorseInput>>
    connectOrCreate?: Enumerable<EndorsementCreateOrConnectWithoutEndorseInput>
    upsert?: Enumerable<EndorsementUpsertWithWhereUniqueWithoutEndorseInput>
    set?: Enumerable<EndorsementWhereUniqueInput>
    disconnect?: Enumerable<EndorsementWhereUniqueInput>
    delete?: Enumerable<EndorsementWhereUniqueInput>
    connect?: Enumerable<EndorsementWhereUniqueInput>
    update?: Enumerable<EndorsementUpdateWithWhereUniqueWithoutEndorseInput>
    updateMany?: Enumerable<EndorsementUpdateManyWithWhereWithoutEndorseInput>
    deleteMany?: Enumerable<EndorsementScalarWhereInput>
  }

  export type ApplicantCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<ApplicantCreateWithoutFeedbackInput, ApplicantUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutFeedbackInput
    connect?: ApplicantWhereUniqueInput
  }

  export type EndorseCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<EndorseCreateWithoutFeedbackInput, EndorseUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: EndorseCreateOrConnectWithoutFeedbackInput
    connect?: EndorseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackInput
    connect?: UserWhereUniqueInput
  }

  export type ApplicantUpdateOneWithoutFeedbackNestedInput = {
    create?: XOR<ApplicantCreateWithoutFeedbackInput, ApplicantUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutFeedbackInput
    upsert?: ApplicantUpsertWithoutFeedbackInput
    disconnect?: boolean
    delete?: boolean
    connect?: ApplicantWhereUniqueInput
    update?: XOR<ApplicantUpdateWithoutFeedbackInput, ApplicantUncheckedUpdateWithoutFeedbackInput>
  }

  export type EndorseUpdateOneWithoutFeedbackNestedInput = {
    create?: XOR<EndorseCreateWithoutFeedbackInput, EndorseUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: EndorseCreateOrConnectWithoutFeedbackInput
    upsert?: EndorseUpsertWithoutFeedbackInput
    disconnect?: boolean
    delete?: boolean
    connect?: EndorseWhereUniqueInput
    update?: XOR<EndorseUpdateWithoutFeedbackInput, EndorseUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserUpdateOneWithoutFeedbackNestedInput = {
    create?: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbackInput
    upsert?: UserUpsertWithoutFeedbackInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFeedbackInput, UserUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserCreateNestedOneWithoutInterviewerInput = {
    create?: XOR<UserCreateWithoutInterviewerInput, UserUncheckedCreateWithoutInterviewerInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewerInput
    connect?: UserWhereUniqueInput
  }

  export type ApplicantCreateNestedOneWithoutInterviewerInput = {
    create?: XOR<ApplicantCreateWithoutInterviewerInput, ApplicantUncheckedCreateWithoutInterviewerInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutInterviewerInput
    connect?: ApplicantWhereUniqueInput
  }

  export type ApplicantUncheckedCreateNestedOneWithoutInterviewerInput = {
    create?: XOR<ApplicantCreateWithoutInterviewerInput, ApplicantUncheckedCreateWithoutInterviewerInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutInterviewerInput
    connect?: ApplicantWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInterviewerNestedInput = {
    create?: XOR<UserCreateWithoutInterviewerInput, UserUncheckedCreateWithoutInterviewerInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewerInput
    upsert?: UserUpsertWithoutInterviewerInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutInterviewerInput, UserUncheckedUpdateWithoutInterviewerInput>
  }

  export type ApplicantUpdateOneWithoutInterviewerNestedInput = {
    create?: XOR<ApplicantCreateWithoutInterviewerInput, ApplicantUncheckedCreateWithoutInterviewerInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutInterviewerInput
    upsert?: ApplicantUpsertWithoutInterviewerInput
    disconnect?: boolean
    delete?: boolean
    connect?: ApplicantWhereUniqueInput
    update?: XOR<ApplicantUpdateWithoutInterviewerInput, ApplicantUncheckedUpdateWithoutInterviewerInput>
  }

  export type ApplicantUncheckedUpdateOneWithoutInterviewerNestedInput = {
    create?: XOR<ApplicantCreateWithoutInterviewerInput, ApplicantUncheckedCreateWithoutInterviewerInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutInterviewerInput
    upsert?: ApplicantUpsertWithoutInterviewerInput
    disconnect?: boolean
    delete?: boolean
    connect?: ApplicantWhereUniqueInput
    update?: XOR<ApplicantUpdateWithoutInterviewerInput, ApplicantUncheckedUpdateWithoutInterviewerInput>
  }

  export type InterviewerCreateNestedOneWithoutApplicantInput = {
    create?: XOR<InterviewerCreateWithoutApplicantInput, InterviewerUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: InterviewerCreateOrConnectWithoutApplicantInput
    connect?: InterviewerWhereUniqueInput
  }

  export type JobPostCreateNestedOneWithoutApplicantsInput = {
    create?: XOR<JobPostCreateWithoutApplicantsInput, JobPostUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutApplicantsInput
    connect?: JobPostWhereUniqueInput
  }

  export type EndorsementCreateNestedOneWithoutApplicantInput = {
    create?: XOR<EndorsementCreateWithoutApplicantInput, EndorsementUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: EndorsementCreateOrConnectWithoutApplicantInput
    connect?: EndorsementWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutApplicantInput = {
    create?: XOR<ProfileCreateWithoutApplicantInput, ProfileUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutApplicantInput
    connect?: ProfileWhereUniqueInput
  }

  export type UploadFileCreateNestedOneWithoutApplicantInput = {
    create?: XOR<UploadFileCreateWithoutApplicantInput, UploadFileUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: UploadFileCreateOrConnectWithoutApplicantInput
    connect?: UploadFileWhereUniqueInput
  }

  export type NotificationCreateNestedOneWithoutApplicantInput = {
    create?: XOR<NotificationCreateWithoutApplicantInput, NotificationUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutApplicantInput
    connect?: NotificationWhereUniqueInput
  }

  export type FeedbackCreateNestedManyWithoutApplicantInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutApplicantInput>, Enumerable<FeedbackUncheckedCreateWithoutApplicantInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutApplicantInput>
    createMany?: FeedbackCreateManyApplicantInputEnvelope
    connect?: Enumerable<FeedbackWhereUniqueInput>
  }

  export type ProfileUncheckedCreateNestedOneWithoutApplicantInput = {
    create?: XOR<ProfileCreateWithoutApplicantInput, ProfileUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutApplicantInput
    connect?: ProfileWhereUniqueInput
  }

  export type UploadFileUncheckedCreateNestedOneWithoutApplicantInput = {
    create?: XOR<UploadFileCreateWithoutApplicantInput, UploadFileUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: UploadFileCreateOrConnectWithoutApplicantInput
    connect?: UploadFileWhereUniqueInput
  }

  export type FeedbackUncheckedCreateNestedManyWithoutApplicantInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutApplicantInput>, Enumerable<FeedbackUncheckedCreateWithoutApplicantInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutApplicantInput>
    createMany?: FeedbackCreateManyApplicantInputEnvelope
    connect?: Enumerable<FeedbackWhereUniqueInput>
  }

  export type EnumapplicantStatusFieldUpdateOperationsInput = {
    set?: applicantStatus
  }

  export type InterviewerUpdateOneWithoutApplicantNestedInput = {
    create?: XOR<InterviewerCreateWithoutApplicantInput, InterviewerUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: InterviewerCreateOrConnectWithoutApplicantInput
    upsert?: InterviewerUpsertWithoutApplicantInput
    disconnect?: boolean
    delete?: boolean
    connect?: InterviewerWhereUniqueInput
    update?: XOR<InterviewerUpdateWithoutApplicantInput, InterviewerUncheckedUpdateWithoutApplicantInput>
  }

  export type JobPostUpdateOneRequiredWithoutApplicantsNestedInput = {
    create?: XOR<JobPostCreateWithoutApplicantsInput, JobPostUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutApplicantsInput
    upsert?: JobPostUpsertWithoutApplicantsInput
    connect?: JobPostWhereUniqueInput
    update?: XOR<JobPostUpdateWithoutApplicantsInput, JobPostUncheckedUpdateWithoutApplicantsInput>
  }

  export type EndorsementUpdateOneWithoutApplicantNestedInput = {
    create?: XOR<EndorsementCreateWithoutApplicantInput, EndorsementUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: EndorsementCreateOrConnectWithoutApplicantInput
    upsert?: EndorsementUpsertWithoutApplicantInput
    disconnect?: boolean
    delete?: boolean
    connect?: EndorsementWhereUniqueInput
    update?: XOR<EndorsementUpdateWithoutApplicantInput, EndorsementUncheckedUpdateWithoutApplicantInput>
  }

  export type ProfileUpdateOneWithoutApplicantNestedInput = {
    create?: XOR<ProfileCreateWithoutApplicantInput, ProfileUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutApplicantInput
    upsert?: ProfileUpsertWithoutApplicantInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutApplicantInput, ProfileUncheckedUpdateWithoutApplicantInput>
  }

  export type UploadFileUpdateOneWithoutApplicantNestedInput = {
    create?: XOR<UploadFileCreateWithoutApplicantInput, UploadFileUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: UploadFileCreateOrConnectWithoutApplicantInput
    upsert?: UploadFileUpsertWithoutApplicantInput
    disconnect?: boolean
    delete?: boolean
    connect?: UploadFileWhereUniqueInput
    update?: XOR<UploadFileUpdateWithoutApplicantInput, UploadFileUncheckedUpdateWithoutApplicantInput>
  }

  export type NotificationUpdateOneWithoutApplicantNestedInput = {
    create?: XOR<NotificationCreateWithoutApplicantInput, NotificationUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutApplicantInput
    upsert?: NotificationUpsertWithoutApplicantInput
    disconnect?: boolean
    delete?: boolean
    connect?: NotificationWhereUniqueInput
    update?: XOR<NotificationUpdateWithoutApplicantInput, NotificationUncheckedUpdateWithoutApplicantInput>
  }

  export type FeedbackUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutApplicantInput>, Enumerable<FeedbackUncheckedCreateWithoutApplicantInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutApplicantInput>
    upsert?: Enumerable<FeedbackUpsertWithWhereUniqueWithoutApplicantInput>
    createMany?: FeedbackCreateManyApplicantInputEnvelope
    set?: Enumerable<FeedbackWhereUniqueInput>
    disconnect?: Enumerable<FeedbackWhereUniqueInput>
    delete?: Enumerable<FeedbackWhereUniqueInput>
    connect?: Enumerable<FeedbackWhereUniqueInput>
    update?: Enumerable<FeedbackUpdateWithWhereUniqueWithoutApplicantInput>
    updateMany?: Enumerable<FeedbackUpdateManyWithWhereWithoutApplicantInput>
    deleteMany?: Enumerable<FeedbackScalarWhereInput>
  }

  export type ProfileUncheckedUpdateOneWithoutApplicantNestedInput = {
    create?: XOR<ProfileCreateWithoutApplicantInput, ProfileUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutApplicantInput
    upsert?: ProfileUpsertWithoutApplicantInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<ProfileUpdateWithoutApplicantInput, ProfileUncheckedUpdateWithoutApplicantInput>
  }

  export type UploadFileUncheckedUpdateOneWithoutApplicantNestedInput = {
    create?: XOR<UploadFileCreateWithoutApplicantInput, UploadFileUncheckedCreateWithoutApplicantInput>
    connectOrCreate?: UploadFileCreateOrConnectWithoutApplicantInput
    upsert?: UploadFileUpsertWithoutApplicantInput
    disconnect?: boolean
    delete?: boolean
    connect?: UploadFileWhereUniqueInput
    update?: XOR<UploadFileUpdateWithoutApplicantInput, UploadFileUncheckedUpdateWithoutApplicantInput>
  }

  export type FeedbackUncheckedUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<Enumerable<FeedbackCreateWithoutApplicantInput>, Enumerable<FeedbackUncheckedCreateWithoutApplicantInput>>
    connectOrCreate?: Enumerable<FeedbackCreateOrConnectWithoutApplicantInput>
    upsert?: Enumerable<FeedbackUpsertWithWhereUniqueWithoutApplicantInput>
    createMany?: FeedbackCreateManyApplicantInputEnvelope
    set?: Enumerable<FeedbackWhereUniqueInput>
    disconnect?: Enumerable<FeedbackWhereUniqueInput>
    delete?: Enumerable<FeedbackWhereUniqueInput>
    connect?: Enumerable<FeedbackWhereUniqueInput>
    update?: Enumerable<FeedbackUpdateWithWhereUniqueWithoutApplicantInput>
    updateMany?: Enumerable<FeedbackUpdateManyWithWhereWithoutApplicantInput>
    deleteMany?: Enumerable<FeedbackScalarWhereInput>
  }

  export type ApplicantCreateNestedOneWithoutFileUploadInput = {
    create?: XOR<ApplicantCreateWithoutFileUploadInput, ApplicantUncheckedCreateWithoutFileUploadInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutFileUploadInput
    connect?: ApplicantWhereUniqueInput
  }

  export type ApplicantUpdateOneWithoutFileUploadNestedInput = {
    create?: XOR<ApplicantCreateWithoutFileUploadInput, ApplicantUncheckedCreateWithoutFileUploadInput>
    connectOrCreate?: ApplicantCreateOrConnectWithoutFileUploadInput
    upsert?: ApplicantUpsertWithoutFileUploadInput
    disconnect?: boolean
    delete?: boolean
    connect?: ApplicantWhereUniqueInput
    update?: XOR<ApplicantUpdateWithoutFileUploadInput, ApplicantUncheckedUpdateWithoutFileUploadInput>
  }

  export type CompanyCreateNestedOneWithoutJobPostInput = {
    create?: XOR<CompanyCreateWithoutJobPostInput, CompanyUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJobPostInput
    connect?: CompanyWhereUniqueInput
  }

  export type NotificationCreateNestedOneWithoutJobPostInput = {
    create?: XOR<NotificationCreateWithoutJobPostInput, NotificationUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutJobPostInput
    connect?: NotificationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutJobPostInput = {
    create?: XOR<UserCreateWithoutJobPostInput, UserUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobPostInput
    connect?: UserWhereUniqueInput
  }

  export type ApplicantCreateNestedManyWithoutJobPostInput = {
    create?: XOR<Enumerable<ApplicantCreateWithoutJobPostInput>, Enumerable<ApplicantUncheckedCreateWithoutJobPostInput>>
    connectOrCreate?: Enumerable<ApplicantCreateOrConnectWithoutJobPostInput>
    createMany?: ApplicantCreateManyJobPostInputEnvelope
    connect?: Enumerable<ApplicantWhereUniqueInput>
  }

  export type JobDetailsCreateNestedOneWithoutJobPostInput = {
    create?: XOR<JobDetailsCreateWithoutJobPostInput, JobDetailsUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: JobDetailsCreateOrConnectWithoutJobPostInput
    connect?: JobDetailsWhereUniqueInput
  }

  export type ApplicantUncheckedCreateNestedManyWithoutJobPostInput = {
    create?: XOR<Enumerable<ApplicantCreateWithoutJobPostInput>, Enumerable<ApplicantUncheckedCreateWithoutJobPostInput>>
    connectOrCreate?: Enumerable<ApplicantCreateOrConnectWithoutJobPostInput>
    createMany?: ApplicantCreateManyJobPostInputEnvelope
    connect?: Enumerable<ApplicantWhereUniqueInput>
  }

  export type JobDetailsUncheckedCreateNestedOneWithoutJobPostInput = {
    create?: XOR<JobDetailsCreateWithoutJobPostInput, JobDetailsUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: JobDetailsCreateOrConnectWithoutJobPostInput
    connect?: JobDetailsWhereUniqueInput
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: JobStatus
  }

  export type CompanyUpdateOneRequiredWithoutJobPostNestedInput = {
    create?: XOR<CompanyCreateWithoutJobPostInput, CompanyUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutJobPostInput
    upsert?: CompanyUpsertWithoutJobPostInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutJobPostInput, CompanyUncheckedUpdateWithoutJobPostInput>
  }

  export type NotificationUpdateOneWithoutJobPostNestedInput = {
    create?: XOR<NotificationCreateWithoutJobPostInput, NotificationUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutJobPostInput
    upsert?: NotificationUpsertWithoutJobPostInput
    disconnect?: boolean
    delete?: boolean
    connect?: NotificationWhereUniqueInput
    update?: XOR<NotificationUpdateWithoutJobPostInput, NotificationUncheckedUpdateWithoutJobPostInput>
  }

  export type UserUpdateOneRequiredWithoutJobPostNestedInput = {
    create?: XOR<UserCreateWithoutJobPostInput, UserUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobPostInput
    upsert?: UserUpsertWithoutJobPostInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutJobPostInput, UserUncheckedUpdateWithoutJobPostInput>
  }

  export type ApplicantUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<Enumerable<ApplicantCreateWithoutJobPostInput>, Enumerable<ApplicantUncheckedCreateWithoutJobPostInput>>
    connectOrCreate?: Enumerable<ApplicantCreateOrConnectWithoutJobPostInput>
    upsert?: Enumerable<ApplicantUpsertWithWhereUniqueWithoutJobPostInput>
    createMany?: ApplicantCreateManyJobPostInputEnvelope
    set?: Enumerable<ApplicantWhereUniqueInput>
    disconnect?: Enumerable<ApplicantWhereUniqueInput>
    delete?: Enumerable<ApplicantWhereUniqueInput>
    connect?: Enumerable<ApplicantWhereUniqueInput>
    update?: Enumerable<ApplicantUpdateWithWhereUniqueWithoutJobPostInput>
    updateMany?: Enumerable<ApplicantUpdateManyWithWhereWithoutJobPostInput>
    deleteMany?: Enumerable<ApplicantScalarWhereInput>
  }

  export type JobDetailsUpdateOneWithoutJobPostNestedInput = {
    create?: XOR<JobDetailsCreateWithoutJobPostInput, JobDetailsUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: JobDetailsCreateOrConnectWithoutJobPostInput
    upsert?: JobDetailsUpsertWithoutJobPostInput
    disconnect?: boolean
    delete?: boolean
    connect?: JobDetailsWhereUniqueInput
    update?: XOR<JobDetailsUpdateWithoutJobPostInput, JobDetailsUncheckedUpdateWithoutJobPostInput>
  }

  export type ApplicantUncheckedUpdateManyWithoutJobPostNestedInput = {
    create?: XOR<Enumerable<ApplicantCreateWithoutJobPostInput>, Enumerable<ApplicantUncheckedCreateWithoutJobPostInput>>
    connectOrCreate?: Enumerable<ApplicantCreateOrConnectWithoutJobPostInput>
    upsert?: Enumerable<ApplicantUpsertWithWhereUniqueWithoutJobPostInput>
    createMany?: ApplicantCreateManyJobPostInputEnvelope
    set?: Enumerable<ApplicantWhereUniqueInput>
    disconnect?: Enumerable<ApplicantWhereUniqueInput>
    delete?: Enumerable<ApplicantWhereUniqueInput>
    connect?: Enumerable<ApplicantWhereUniqueInput>
    update?: Enumerable<ApplicantUpdateWithWhereUniqueWithoutJobPostInput>
    updateMany?: Enumerable<ApplicantUpdateManyWithWhereWithoutJobPostInput>
    deleteMany?: Enumerable<ApplicantScalarWhereInput>
  }

  export type JobDetailsUncheckedUpdateOneWithoutJobPostNestedInput = {
    create?: XOR<JobDetailsCreateWithoutJobPostInput, JobDetailsUncheckedCreateWithoutJobPostInput>
    connectOrCreate?: JobDetailsCreateOrConnectWithoutJobPostInput
    upsert?: JobDetailsUpsertWithoutJobPostInput
    disconnect?: boolean
    delete?: boolean
    connect?: JobDetailsWhereUniqueInput
    update?: XOR<JobDetailsUpdateWithoutJobPostInput, JobDetailsUncheckedUpdateWithoutJobPostInput>
  }

  export type JobDetailsCreatelocationInput = {
    set: Enumerable<string>
  }

  export type JobDetailsCreatejobTypeInput = {
    set: Enumerable<string>
  }

  export type JobDetailsCreateworkTypeInput = {
    set: Enumerable<string>
  }

  export type JobPostCreateNestedOneWithoutDetailsInput = {
    create?: XOR<JobPostCreateWithoutDetailsInput, JobPostUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutDetailsInput
    connect?: JobPostWhereUniqueInput
  }

  export type JobDetailsUpdatelocationInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type JobDetailsUpdatejobTypeInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type JobDetailsUpdateworkTypeInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type JobPostUpdateOneWithoutDetailsNestedInput = {
    create?: XOR<JobPostCreateWithoutDetailsInput, JobPostUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: JobPostCreateOrConnectWithoutDetailsInput
    upsert?: JobPostUpsertWithoutDetailsInput
    disconnect?: boolean
    delete?: boolean
    connect?: JobPostWhereUniqueInput
    update?: XOR<JobPostUpdateWithoutDetailsInput, JobPostUncheckedUpdateWithoutDetailsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumnotificationStatusFilter = {
    equals?: notificationStatus
    in?: Enumerable<notificationStatus>
    notIn?: Enumerable<notificationStatus>
    not?: NestedEnumnotificationStatusFilter | notificationStatus
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumnotificationStatusWithAggregatesFilter = {
    equals?: notificationStatus
    in?: Enumerable<notificationStatus>
    notIn?: Enumerable<notificationStatus>
    not?: NestedEnumnotificationStatusWithAggregatesFilter | notificationStatus
    _count?: NestedIntFilter
    _min?: NestedEnumnotificationStatusFilter
    _max?: NestedEnumnotificationStatusFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumendorseStatusFilter = {
    equals?: endorseStatus
    in?: Enumerable<endorseStatus>
    notIn?: Enumerable<endorseStatus>
    not?: NestedEnumendorseStatusFilter | endorseStatus
  }

  export type NestedEnumendorseStatusWithAggregatesFilter = {
    equals?: endorseStatus
    in?: Enumerable<endorseStatus>
    notIn?: Enumerable<endorseStatus>
    not?: NestedEnumendorseStatusWithAggregatesFilter | endorseStatus
    _count?: NestedIntFilter
    _min?: NestedEnumendorseStatusFilter
    _max?: NestedEnumendorseStatusFilter
  }

  export type NestedEnumapplicantStatusFilter = {
    equals?: applicantStatus
    in?: Enumerable<applicantStatus>
    notIn?: Enumerable<applicantStatus>
    not?: NestedEnumapplicantStatusFilter | applicantStatus
  }

  export type NestedEnumapplicantStatusWithAggregatesFilter = {
    equals?: applicantStatus
    in?: Enumerable<applicantStatus>
    notIn?: Enumerable<applicantStatus>
    not?: NestedEnumapplicantStatusWithAggregatesFilter | applicantStatus
    _count?: NestedIntFilter
    _min?: NestedEnumapplicantStatusFilter
    _max?: NestedEnumapplicantStatusFilter
  }

  export type NestedEnumJobStatusFilter = {
    equals?: JobStatus
    in?: Enumerable<JobStatus>
    notIn?: Enumerable<JobStatus>
    not?: NestedEnumJobStatusFilter | JobStatus
  }

  export type NestedEnumJobStatusWithAggregatesFilter = {
    equals?: JobStatus
    in?: Enumerable<JobStatus>
    notIn?: Enumerable<JobStatus>
    not?: NestedEnumJobStatusWithAggregatesFilter | JobStatus
    _count?: NestedIntFilter
    _min?: NestedEnumJobStatusFilter
    _max?: NestedEnumJobStatusFilter
  }

  export type CompanyCreateWithoutUserInput = {
    companyID?: string
    companyName: string
    details?: CompanyDetailsCreateNestedOneWithoutCompanyInput
    createdAt?: Date | string | null
    Endorse?: EndorseCreateNestedManyWithoutCompanyInput
    Endorsement?: EndorsementCreateNestedManyWithoutCompanyInput
    jobPost?: JobPostCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUserInput = {
    companyID?: string
    companyName: string
    details?: CompanyDetailsUncheckedCreateNestedOneWithoutCompanyInput
    createdAt?: Date | string | null
    Endorse?: EndorseUncheckedCreateNestedManyWithoutCompanyInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutCompanyInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUserInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateWithoutUserInput = {
    commentID?: string
    message: string
    notes: string
    createdAt: Date | string
    updatedAt: Date | string
    Endorsement?: EndorsementCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    commentID?: string
    message: string
    notes: string
    createdAt: Date | string
    updatedAt: Date | string
    endorsementID?: string | null
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type EndorseCreateWithoutUserInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    createdAt: Date | string
    feedback?: FeedbackCreateNestedManyWithoutEndorseInput
    Company?: CompanyCreateNestedOneWithoutEndorseInput
    Endorsement?: EndorsementCreateNestedManyWithoutEndorseInput
  }

  export type EndorseUncheckedCreateWithoutUserInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    createdAt: Date | string
    feedback?: FeedbackUncheckedCreateNestedManyWithoutEndorseInput
    companyID?: string | null
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutEndorseInput
  }

  export type EndorseCreateOrConnectWithoutUserInput = {
    where: EndorseWhereUniqueInput
    create: XOR<EndorseCreateWithoutUserInput, EndorseUncheckedCreateWithoutUserInput>
  }

  export type EndorseCreateManyUserInputEnvelope = {
    data: Enumerable<EndorseCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type EndorsementCreateWithoutUserInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    Company?: CompanyCreateNestedOneWithoutEndorsementInput
    Comment?: CommentCreateNestedOneWithoutEndorsementInput
    Endorse?: EndorseCreateNestedManyWithoutEndorsementInput
    Applicant?: ApplicantCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementUncheckedCreateWithoutUserInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    companyID?: string | null
    Comment?: CommentUncheckedCreateNestedOneWithoutEndorsementInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutEndorsementInput
    Applicant?: ApplicantUncheckedCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementCreateOrConnectWithoutUserInput = {
    where: EndorsementWhereUniqueInput
    create: XOR<EndorsementCreateWithoutUserInput, EndorsementUncheckedCreateWithoutUserInput>
  }

  export type EndorsementCreateManyUserInputEnvelope = {
    data: Enumerable<EndorsementCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutUserInput = {
    feedbackID?: string
    feedback: string
    createdAt: Date | string
    Applicant?: ApplicantCreateNestedOneWithoutFeedbackInput
    Endorse?: EndorseCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutUserInput = {
    feedbackID?: string
    feedback: string
    createdAt: Date | string
    endorseID?: string | null
    applicantID?: string | null
  }

  export type FeedbackCreateOrConnectWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type InterviewerCreateWithoutUserInput = {
    interviewerID?: string
    createdAt: Date | string
    Applicant?: ApplicantCreateNestedOneWithoutInterviewerInput
  }

  export type InterviewerUncheckedCreateWithoutUserInput = {
    interviewerID?: string
    createdAt: Date | string
    Applicant?: ApplicantUncheckedCreateNestedOneWithoutInterviewerInput
  }

  export type InterviewerCreateOrConnectWithoutUserInput = {
    where: InterviewerWhereUniqueInput
    create: XOR<InterviewerCreateWithoutUserInput, InterviewerUncheckedCreateWithoutUserInput>
  }

  export type InterviewerCreateManyUserInputEnvelope = {
    data: Enumerable<InterviewerCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type JobPostCreateWithoutUserInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutJobPostInput
    Notification?: NotificationCreateNestedOneWithoutJobPostInput
    Applicants?: ApplicantCreateNestedManyWithoutJobPostInput
    details?: JobDetailsCreateNestedOneWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutUserInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    notificationID?: string | null
    Applicants?: ApplicantUncheckedCreateNestedManyWithoutJobPostInput
    details?: JobDetailsUncheckedCreateNestedOneWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutUserInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutUserInput, JobPostUncheckedCreateWithoutUserInput>
  }

  export type JobPostCreateManyUserInputEnvelope = {
    data: Enumerable<JobPostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    notificationID?: string
    title: string
    notificationStatus?: notificationStatus
    createdAt: Date | string
    JobPost?: JobPostCreateNestedOneWithoutNotificationInput
    Applicant?: ApplicantCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    notificationID?: string
    title: string
    notificationStatus?: notificationStatus
    createdAt: Date | string
    JobPost?: JobPostUncheckedCreateNestedOneWithoutNotificationInput
    Applicant?: ApplicantUncheckedCreateNestedOneWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: Enumerable<NotificationCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    birthday?: Date | string | null
    Applicant?: ApplicantCreateNestedOneWithoutProfileInput
    Address?: AddressCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    birthday?: Date | string | null
    applicantID?: string | null
    Address?: AddressUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type LogsCreateWithoutUserInput = {
    logsID?: string
    title: string
    modifiedBy: string
    createdAt: Date | string
  }

  export type LogsUncheckedCreateWithoutUserInput = {
    logsID?: string
    title: string
    modifiedBy: string
    createdAt: Date | string
  }

  export type LogsCreateOrConnectWithoutUserInput = {
    where: LogsWhereUniqueInput
    create: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput>
  }

  export type CompanyUpsertWithoutUserInput = {
    update: XOR<CompanyUpdateWithoutUserInput, CompanyUncheckedUpdateWithoutUserInput>
    create: XOR<CompanyCreateWithoutUserInput, CompanyUncheckedCreateWithoutUserInput>
  }

  export type CompanyUpdateWithoutUserInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    details?: CompanyDetailsUpdateOneWithoutCompanyNestedInput
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorse?: EndorseUpdateManyWithoutCompanyNestedInput
    Endorsement?: EndorsementUpdateManyWithoutCompanyNestedInput
    jobPost?: JobPostUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUserInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    details?: CompanyDetailsUncheckedUpdateOneWithoutCompanyNestedInput
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorse?: EndorseUncheckedUpdateManyWithoutCompanyNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutCompanyNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CommentUpsertWithoutUserInput = {
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithoutUserInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Endorsement?: EndorsementUpdateOneWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EndorseUpsertWithWhereUniqueWithoutUserInput = {
    where: EndorseWhereUniqueInput
    update: XOR<EndorseUpdateWithoutUserInput, EndorseUncheckedUpdateWithoutUserInput>
    create: XOR<EndorseCreateWithoutUserInput, EndorseUncheckedCreateWithoutUserInput>
  }

  export type EndorseUpdateWithWhereUniqueWithoutUserInput = {
    where: EndorseWhereUniqueInput
    data: XOR<EndorseUpdateWithoutUserInput, EndorseUncheckedUpdateWithoutUserInput>
  }

  export type EndorseUpdateManyWithWhereWithoutUserInput = {
    where: EndorseScalarWhereInput
    data: XOR<EndorseUpdateManyMutationInput, EndorseUncheckedUpdateManyWithoutEndorseInput>
  }

  export type EndorseScalarWhereInput = {
    AND?: Enumerable<EndorseScalarWhereInput>
    OR?: Enumerable<EndorseScalarWhereInput>
    NOT?: Enumerable<EndorseScalarWhereInput>
    endorseID?: StringFilter | string
    endorseStatus?: EnumendorseStatusFilter | endorseStatus
    userID?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    companyID?: StringNullableFilter | string | null
  }

  export type EndorsementUpsertWithWhereUniqueWithoutUserInput = {
    where: EndorsementWhereUniqueInput
    update: XOR<EndorsementUpdateWithoutUserInput, EndorsementUncheckedUpdateWithoutUserInput>
    create: XOR<EndorsementCreateWithoutUserInput, EndorsementUncheckedCreateWithoutUserInput>
  }

  export type EndorsementUpdateWithWhereUniqueWithoutUserInput = {
    where: EndorsementWhereUniqueInput
    data: XOR<EndorsementUpdateWithoutUserInput, EndorsementUncheckedUpdateWithoutUserInput>
  }

  export type EndorsementUpdateManyWithWhereWithoutUserInput = {
    where: EndorsementScalarWhereInput
    data: XOR<EndorsementUpdateManyMutationInput, EndorsementUncheckedUpdateManyWithoutEndorsementInput>
  }

  export type EndorsementScalarWhereInput = {
    AND?: Enumerable<EndorsementScalarWhereInput>
    OR?: Enumerable<EndorsementScalarWhereInput>
    NOT?: Enumerable<EndorsementScalarWhereInput>
    endorsementID?: StringFilter | string
    Status?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userID?: StringNullableFilter | string | null
    companyID?: StringNullableFilter | string | null
  }

  export type FeedbackUpsertWithoutUserInput = {
    update: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackUpdateWithoutUserInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Applicant?: ApplicantUpdateOneWithoutFeedbackNestedInput
    Endorse?: EndorseUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutUserInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endorseID?: NullableStringFieldUpdateOperationsInput | string | null
    applicantID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InterviewerUpsertWithWhereUniqueWithoutUserInput = {
    where: InterviewerWhereUniqueInput
    update: XOR<InterviewerUpdateWithoutUserInput, InterviewerUncheckedUpdateWithoutUserInput>
    create: XOR<InterviewerCreateWithoutUserInput, InterviewerUncheckedCreateWithoutUserInput>
  }

  export type InterviewerUpdateWithWhereUniqueWithoutUserInput = {
    where: InterviewerWhereUniqueInput
    data: XOR<InterviewerUpdateWithoutUserInput, InterviewerUncheckedUpdateWithoutUserInput>
  }

  export type InterviewerUpdateManyWithWhereWithoutUserInput = {
    where: InterviewerScalarWhereInput
    data: XOR<InterviewerUpdateManyMutationInput, InterviewerUncheckedUpdateManyWithoutInterviewerInput>
  }

  export type InterviewerScalarWhereInput = {
    AND?: Enumerable<InterviewerScalarWhereInput>
    OR?: Enumerable<InterviewerScalarWhereInput>
    NOT?: Enumerable<InterviewerScalarWhereInput>
    interviewerID?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userID?: StringFilter | string
  }

  export type JobPostUpsertWithWhereUniqueWithoutUserInput = {
    where: JobPostWhereUniqueInput
    update: XOR<JobPostUpdateWithoutUserInput, JobPostUncheckedUpdateWithoutUserInput>
    create: XOR<JobPostCreateWithoutUserInput, JobPostUncheckedCreateWithoutUserInput>
  }

  export type JobPostUpdateWithWhereUniqueWithoutUserInput = {
    where: JobPostWhereUniqueInput
    data: XOR<JobPostUpdateWithoutUserInput, JobPostUncheckedUpdateWithoutUserInput>
  }

  export type JobPostUpdateManyWithWhereWithoutUserInput = {
    where: JobPostScalarWhereInput
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyWithoutJobPostInput>
  }

  export type JobPostScalarWhereInput = {
    AND?: Enumerable<JobPostScalarWhereInput>
    OR?: Enumerable<JobPostScalarWhereInput>
    NOT?: Enumerable<JobPostScalarWhereInput>
    jobPostID?: StringFilter | string
    title?: StringFilter | string
    description?: StringFilter | string
    qualification?: StringFilter | string
    responsibilities?: StringFilter | string
    status?: EnumJobStatusFilter | JobStatus
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    companyID?: StringFilter | string
    notificationID?: StringNullableFilter | string | null
    userID?: StringFilter | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: Enumerable<NotificationScalarWhereInput>
    OR?: Enumerable<NotificationScalarWhereInput>
    NOT?: Enumerable<NotificationScalarWhereInput>
    notificationID?: StringFilter | string
    title?: StringFilter | string
    notificationStatus?: EnumnotificationStatusFilter | notificationStatus
    createdAt?: DateTimeFilter | Date | string
    userID?: StringNullableFilter | string | null
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Applicant?: ApplicantUpdateOneWithoutProfileNestedInput
    Address?: AddressUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicantID?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type LogsUpsertWithWhereUniqueWithoutUserInput = {
    where: LogsWhereUniqueInput
    update: XOR<LogsUpdateWithoutUserInput, LogsUncheckedUpdateWithoutUserInput>
    create: XOR<LogsCreateWithoutUserInput, LogsUncheckedCreateWithoutUserInput>
  }

  export type LogsUpdateWithWhereUniqueWithoutUserInput = {
    where: LogsWhereUniqueInput
    data: XOR<LogsUpdateWithoutUserInput, LogsUncheckedUpdateWithoutUserInput>
  }

  export type LogsUpdateManyWithWhereWithoutUserInput = {
    where: LogsScalarWhereInput
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyWithoutLogsInput>
  }

  export type LogsScalarWhereInput = {
    AND?: Enumerable<LogsScalarWhereInput>
    OR?: Enumerable<LogsScalarWhereInput>
    NOT?: Enumerable<LogsScalarWhereInput>
    logsID?: StringFilter | string
    title?: StringFilter | string
    modifiedBy?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutLogsInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutUserInput
    Comment?: CommentCreateNestedOneWithoutUserInput
    Endorse?: EndorseCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementCreateNestedManyWithoutUserInput
    Feedback?: FeedbackCreateNestedOneWithoutUserInput
    interviewer?: InterviewerCreateNestedManyWithoutUserInput
    JobPost?: JobPostCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    Comment?: CommentUncheckedCreateNestedOneWithoutUserInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutUserInput
    Feedback?: FeedbackUncheckedCreateNestedOneWithoutUserInput
    interviewer?: InterviewerUncheckedCreateNestedManyWithoutUserInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutLogsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLogsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateManyWithWhereWithoutLogsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    userID?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    role?: EnumRoleFilter | Role
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    companyID?: StringFilter | string
  }

  export type UserCreateWithoutNotificationInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutUserInput
    Comment?: CommentCreateNestedOneWithoutUserInput
    Endorse?: EndorseCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementCreateNestedManyWithoutUserInput
    Feedback?: FeedbackCreateNestedOneWithoutUserInput
    interviewer?: InterviewerCreateNestedManyWithoutUserInput
    JobPost?: JobPostCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedOneWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    Comment?: CommentUncheckedCreateNestedOneWithoutUserInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutUserInput
    Feedback?: FeedbackUncheckedCreateNestedOneWithoutUserInput
    interviewer?: InterviewerUncheckedCreateNestedManyWithoutUserInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type JobPostCreateWithoutNotificationInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutJobPostInput
    User: UserCreateNestedOneWithoutJobPostInput
    Applicants?: ApplicantCreateNestedManyWithoutJobPostInput
    details?: JobDetailsCreateNestedOneWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutNotificationInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    userID: string
    Applicants?: ApplicantUncheckedCreateNestedManyWithoutJobPostInput
    details?: JobDetailsUncheckedCreateNestedOneWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutNotificationInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutNotificationInput, JobPostUncheckedCreateWithoutNotificationInput>
  }

  export type ApplicantCreateWithoutNotificationInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    interviewer?: InterviewerCreateNestedOneWithoutApplicantInput
    JobPost: JobPostCreateNestedOneWithoutApplicantsInput
    Endorsement?: EndorsementCreateNestedOneWithoutApplicantInput
    Profile?: ProfileCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileCreateNestedOneWithoutApplicantInput
    Feedback?: FeedbackCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutNotificationInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    jobPostID: string
    interviewerID?: string | null
    endorsementID?: string | null
    Profile?: ProfileUncheckedCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileUncheckedCreateNestedOneWithoutApplicantInput
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutNotificationInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutNotificationInput, ApplicantUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutUserNestedInput
    Comment?: CommentUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateOneWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    Comment?: CommentUncheckedUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUncheckedUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUncheckedUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JobPostUpsertWithoutNotificationInput = {
    update: XOR<JobPostUpdateWithoutNotificationInput, JobPostUncheckedUpdateWithoutNotificationInput>
    create: XOR<JobPostCreateWithoutNotificationInput, JobPostUncheckedCreateWithoutNotificationInput>
  }

  export type JobPostUpdateWithoutNotificationInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutJobPostNestedInput
    User?: UserUpdateOneRequiredWithoutJobPostNestedInput
    Applicants?: ApplicantUpdateManyWithoutJobPostNestedInput
    details?: JobDetailsUpdateOneWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutNotificationInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    Applicants?: ApplicantUncheckedUpdateManyWithoutJobPostNestedInput
    details?: JobDetailsUncheckedUpdateOneWithoutJobPostNestedInput
  }

  export type ApplicantUpsertWithoutNotificationInput = {
    update: XOR<ApplicantUpdateWithoutNotificationInput, ApplicantUncheckedUpdateWithoutNotificationInput>
    create: XOR<ApplicantCreateWithoutNotificationInput, ApplicantUncheckedCreateWithoutNotificationInput>
  }

  export type ApplicantUpdateWithoutNotificationInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    interviewer?: InterviewerUpdateOneWithoutApplicantNestedInput
    JobPost?: JobPostUpdateOneRequiredWithoutApplicantsNestedInput
    Endorsement?: EndorsementUpdateOneWithoutApplicantNestedInput
    Profile?: ProfileUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUpdateOneWithoutApplicantNestedInput
    Feedback?: FeedbackUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutNotificationInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    jobPostID?: StringFieldUpdateOperationsInput | string
    interviewerID?: NullableStringFieldUpdateOperationsInput | string | null
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
    Profile?: ProfileUncheckedUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUncheckedUpdateOneWithoutApplicantNestedInput
    Feedback?: FeedbackUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantCreateWithoutProfileInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    interviewer?: InterviewerCreateNestedOneWithoutApplicantInput
    JobPost: JobPostCreateNestedOneWithoutApplicantsInput
    Endorsement?: EndorsementCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileCreateNestedOneWithoutApplicantInput
    Notification?: NotificationCreateNestedOneWithoutApplicantInput
    Feedback?: FeedbackCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutProfileInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    jobPostID: string
    interviewerID?: string | null
    endorsementID?: string | null
    FileUpload?: UploadFileUncheckedCreateNestedOneWithoutApplicantInput
    notificaitonID?: string | null
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutProfileInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutProfileInput, ApplicantUncheckedCreateWithoutProfileInput>
  }

  export type UserCreateWithoutProfileInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutUserInput
    Comment?: CommentCreateNestedOneWithoutUserInput
    Endorse?: EndorseCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementCreateNestedManyWithoutUserInput
    Feedback?: FeedbackCreateNestedOneWithoutUserInput
    interviewer?: InterviewerCreateNestedManyWithoutUserInput
    JobPost?: JobPostCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    Comment?: CommentUncheckedCreateNestedOneWithoutUserInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutUserInput
    Feedback?: FeedbackUncheckedCreateNestedOneWithoutUserInput
    interviewer?: InterviewerUncheckedCreateNestedManyWithoutUserInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type AddressCreateWithoutProfileInput = {
    addressID?: string
    city: string
    province: string
    zipcode: string
    street: string
    Company_Details?: CompanyDetailsCreateNestedOneWithoutLocationInput
  }

  export type AddressUncheckedCreateWithoutProfileInput = {
    addressID?: string
    city: string
    province: string
    zipcode: string
    street: string
    companyDetailsID?: string | null
  }

  export type AddressCreateOrConnectWithoutProfileInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutProfileInput, AddressUncheckedCreateWithoutProfileInput>
  }

  export type ApplicantUpsertWithoutProfileInput = {
    update: XOR<ApplicantUpdateWithoutProfileInput, ApplicantUncheckedUpdateWithoutProfileInput>
    create: XOR<ApplicantCreateWithoutProfileInput, ApplicantUncheckedCreateWithoutProfileInput>
  }

  export type ApplicantUpdateWithoutProfileInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    interviewer?: InterviewerUpdateOneWithoutApplicantNestedInput
    JobPost?: JobPostUpdateOneRequiredWithoutApplicantsNestedInput
    Endorsement?: EndorsementUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUpdateOneWithoutApplicantNestedInput
    Notification?: NotificationUpdateOneWithoutApplicantNestedInput
    Feedback?: FeedbackUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutProfileInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    jobPostID?: StringFieldUpdateOperationsInput | string
    interviewerID?: NullableStringFieldUpdateOperationsInput | string | null
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
    FileUpload?: UploadFileUncheckedUpdateOneWithoutApplicantNestedInput
    notificaitonID?: NullableStringFieldUpdateOperationsInput | string | null
    Feedback?: FeedbackUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutUserNestedInput
    Comment?: CommentUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    Comment?: CommentUncheckedUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUncheckedUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUncheckedUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AddressUpsertWithoutProfileInput = {
    update: XOR<AddressUpdateWithoutProfileInput, AddressUncheckedUpdateWithoutProfileInput>
    create: XOR<AddressCreateWithoutProfileInput, AddressUncheckedCreateWithoutProfileInput>
  }

  export type AddressUpdateWithoutProfileInput = {
    addressID?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    Company_Details?: CompanyDetailsUpdateOneWithoutLocationNestedInput
  }

  export type AddressUncheckedUpdateWithoutProfileInput = {
    addressID?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    companyDetailsID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyDetailsCreateWithoutLocationInput = {
    companyDetailsID?: string
    description: string
    mission?: string | null
    vision?: string | null
    Company?: CompanyCreateNestedOneWithoutDetailsInput
  }

  export type CompanyDetailsUncheckedCreateWithoutLocationInput = {
    companyDetailsID?: string
    description: string
    mission?: string | null
    vision?: string | null
    companyID?: string | null
  }

  export type CompanyDetailsCreateOrConnectWithoutLocationInput = {
    where: CompanyDetailsWhereUniqueInput
    create: XOR<CompanyDetailsCreateWithoutLocationInput, CompanyDetailsUncheckedCreateWithoutLocationInput>
  }

  export type ProfileCreateWithoutAddressInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    birthday?: Date | string | null
    Applicant?: ApplicantCreateNestedOneWithoutProfileInput
    User?: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutAddressInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    birthday?: Date | string | null
    applicantID?: string | null
    userID?: string | null
  }

  export type ProfileCreateOrConnectWithoutAddressInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutAddressInput, ProfileUncheckedCreateWithoutAddressInput>
  }

  export type CompanyDetailsUpsertWithoutLocationInput = {
    update: XOR<CompanyDetailsUpdateWithoutLocationInput, CompanyDetailsUncheckedUpdateWithoutLocationInput>
    create: XOR<CompanyDetailsCreateWithoutLocationInput, CompanyDetailsUncheckedCreateWithoutLocationInput>
  }

  export type CompanyDetailsUpdateWithoutLocationInput = {
    companyDetailsID?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mission?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    Company?: CompanyUpdateOneWithoutDetailsNestedInput
  }

  export type CompanyDetailsUncheckedUpdateWithoutLocationInput = {
    companyDetailsID?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mission?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUpsertWithoutAddressInput = {
    update: XOR<ProfileUpdateWithoutAddressInput, ProfileUncheckedUpdateWithoutAddressInput>
    create: XOR<ProfileCreateWithoutAddressInput, ProfileUncheckedCreateWithoutAddressInput>
  }

  export type ProfileUpdateWithoutAddressInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Applicant?: ApplicantUpdateOneWithoutProfileNestedInput
    User?: UserUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutAddressInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicantID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyDetailsCreateWithoutCompanyInput = {
    companyDetailsID?: string
    description: string
    mission?: string | null
    vision?: string | null
    location?: AddressCreateNestedOneWithoutCompany_DetailsInput
  }

  export type CompanyDetailsUncheckedCreateWithoutCompanyInput = {
    companyDetailsID?: string
    description: string
    mission?: string | null
    vision?: string | null
    location?: AddressUncheckedCreateNestedOneWithoutCompany_DetailsInput
  }

  export type CompanyDetailsCreateOrConnectWithoutCompanyInput = {
    where: CompanyDetailsWhereUniqueInput
    create: XOR<CompanyDetailsCreateWithoutCompanyInput, CompanyDetailsUncheckedCreateWithoutCompanyInput>
  }

  export type EndorseCreateWithoutCompanyInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    createdAt: Date | string
    User: UserCreateNestedOneWithoutEndorseInput
    feedback?: FeedbackCreateNestedManyWithoutEndorseInput
    Endorsement?: EndorsementCreateNestedManyWithoutEndorseInput
  }

  export type EndorseUncheckedCreateWithoutCompanyInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    userID: string
    createdAt: Date | string
    feedback?: FeedbackUncheckedCreateNestedManyWithoutEndorseInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutEndorseInput
  }

  export type EndorseCreateOrConnectWithoutCompanyInput = {
    where: EndorseWhereUniqueInput
    create: XOR<EndorseCreateWithoutCompanyInput, EndorseUncheckedCreateWithoutCompanyInput>
  }

  export type EndorseCreateManyCompanyInputEnvelope = {
    data: Enumerable<EndorseCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type EndorsementCreateWithoutCompanyInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedOneWithoutEndorsementInput
    Comment?: CommentCreateNestedOneWithoutEndorsementInput
    Endorse?: EndorseCreateNestedManyWithoutEndorsementInput
    Applicant?: ApplicantCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementUncheckedCreateWithoutCompanyInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    userID?: string | null
    Comment?: CommentUncheckedCreateNestedOneWithoutEndorsementInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutEndorsementInput
    Applicant?: ApplicantUncheckedCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementCreateOrConnectWithoutCompanyInput = {
    where: EndorsementWhereUniqueInput
    create: XOR<EndorsementCreateWithoutCompanyInput, EndorsementUncheckedCreateWithoutCompanyInput>
  }

  export type EndorsementCreateManyCompanyInputEnvelope = {
    data: Enumerable<EndorsementCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type JobPostCreateWithoutCompanyInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    Notification?: NotificationCreateNestedOneWithoutJobPostInput
    User: UserCreateNestedOneWithoutJobPostInput
    Applicants?: ApplicantCreateNestedManyWithoutJobPostInput
    details?: JobDetailsCreateNestedOneWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutCompanyInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    notificationID?: string | null
    userID: string
    Applicants?: ApplicantUncheckedCreateNestedManyWithoutJobPostInput
    details?: JobDetailsUncheckedCreateNestedOneWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutCompanyInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutCompanyInput, JobPostUncheckedCreateWithoutCompanyInput>
  }

  export type JobPostCreateManyCompanyInputEnvelope = {
    data: Enumerable<JobPostCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCompanyInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Comment?: CommentCreateNestedOneWithoutUserInput
    Endorse?: EndorseCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementCreateNestedManyWithoutUserInput
    Feedback?: FeedbackCreateNestedOneWithoutUserInput
    interviewer?: InterviewerCreateNestedManyWithoutUserInput
    JobPost?: JobPostCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedOneWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Comment?: CommentUncheckedCreateNestedOneWithoutUserInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutUserInput
    Feedback?: FeedbackUncheckedCreateNestedOneWithoutUserInput
    interviewer?: InterviewerUncheckedCreateNestedManyWithoutUserInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: Enumerable<UserCreateManyCompanyInput>
    skipDuplicates?: boolean
  }

  export type CompanyDetailsUpsertWithoutCompanyInput = {
    update: XOR<CompanyDetailsUpdateWithoutCompanyInput, CompanyDetailsUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyDetailsCreateWithoutCompanyInput, CompanyDetailsUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyDetailsUpdateWithoutCompanyInput = {
    companyDetailsID?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mission?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    location?: AddressUpdateOneWithoutCompany_DetailsNestedInput
  }

  export type CompanyDetailsUncheckedUpdateWithoutCompanyInput = {
    companyDetailsID?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mission?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    location?: AddressUncheckedUpdateOneWithoutCompany_DetailsNestedInput
  }

  export type EndorseUpsertWithWhereUniqueWithoutCompanyInput = {
    where: EndorseWhereUniqueInput
    update: XOR<EndorseUpdateWithoutCompanyInput, EndorseUncheckedUpdateWithoutCompanyInput>
    create: XOR<EndorseCreateWithoutCompanyInput, EndorseUncheckedCreateWithoutCompanyInput>
  }

  export type EndorseUpdateWithWhereUniqueWithoutCompanyInput = {
    where: EndorseWhereUniqueInput
    data: XOR<EndorseUpdateWithoutCompanyInput, EndorseUncheckedUpdateWithoutCompanyInput>
  }

  export type EndorseUpdateManyWithWhereWithoutCompanyInput = {
    where: EndorseScalarWhereInput
    data: XOR<EndorseUpdateManyMutationInput, EndorseUncheckedUpdateManyWithoutEndorseInput>
  }

  export type EndorsementUpsertWithWhereUniqueWithoutCompanyInput = {
    where: EndorsementWhereUniqueInput
    update: XOR<EndorsementUpdateWithoutCompanyInput, EndorsementUncheckedUpdateWithoutCompanyInput>
    create: XOR<EndorsementCreateWithoutCompanyInput, EndorsementUncheckedCreateWithoutCompanyInput>
  }

  export type EndorsementUpdateWithWhereUniqueWithoutCompanyInput = {
    where: EndorsementWhereUniqueInput
    data: XOR<EndorsementUpdateWithoutCompanyInput, EndorsementUncheckedUpdateWithoutCompanyInput>
  }

  export type EndorsementUpdateManyWithWhereWithoutCompanyInput = {
    where: EndorsementScalarWhereInput
    data: XOR<EndorsementUpdateManyMutationInput, EndorsementUncheckedUpdateManyWithoutEndorsementInput>
  }

  export type JobPostUpsertWithWhereUniqueWithoutCompanyInput = {
    where: JobPostWhereUniqueInput
    update: XOR<JobPostUpdateWithoutCompanyInput, JobPostUncheckedUpdateWithoutCompanyInput>
    create: XOR<JobPostCreateWithoutCompanyInput, JobPostUncheckedCreateWithoutCompanyInput>
  }

  export type JobPostUpdateWithWhereUniqueWithoutCompanyInput = {
    where: JobPostWhereUniqueInput
    data: XOR<JobPostUpdateWithoutCompanyInput, JobPostUncheckedUpdateWithoutCompanyInput>
  }

  export type JobPostUpdateManyWithWhereWithoutCompanyInput = {
    where: JobPostScalarWhereInput
    data: XOR<JobPostUpdateManyMutationInput, JobPostUncheckedUpdateManyWithoutJobPostInput>
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type CompanyCreateWithoutDetailsInput = {
    companyID?: string
    companyName: string
    createdAt?: Date | string | null
    Endorse?: EndorseCreateNestedManyWithoutCompanyInput
    Endorsement?: EndorsementCreateNestedManyWithoutCompanyInput
    jobPost?: JobPostCreateNestedManyWithoutCompanyInput
    User?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDetailsInput = {
    companyID?: string
    companyName: string
    createdAt?: Date | string | null
    Endorse?: EndorseUncheckedCreateNestedManyWithoutCompanyInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutCompanyInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutCompanyInput
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDetailsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDetailsInput, CompanyUncheckedCreateWithoutDetailsInput>
  }

  export type AddressCreateWithoutCompany_DetailsInput = {
    addressID?: string
    city: string
    province: string
    zipcode: string
    street: string
    Profile?: ProfileCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCompany_DetailsInput = {
    addressID?: string
    city: string
    province: string
    zipcode: string
    street: string
    profileID?: string | null
  }

  export type AddressCreateOrConnectWithoutCompany_DetailsInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCompany_DetailsInput, AddressUncheckedCreateWithoutCompany_DetailsInput>
  }

  export type CompanyUpsertWithoutDetailsInput = {
    update: XOR<CompanyUpdateWithoutDetailsInput, CompanyUncheckedUpdateWithoutDetailsInput>
    create: XOR<CompanyCreateWithoutDetailsInput, CompanyUncheckedCreateWithoutDetailsInput>
  }

  export type CompanyUpdateWithoutDetailsInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorse?: EndorseUpdateManyWithoutCompanyNestedInput
    Endorsement?: EndorsementUpdateManyWithoutCompanyNestedInput
    jobPost?: JobPostUpdateManyWithoutCompanyNestedInput
    User?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDetailsInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorse?: EndorseUncheckedUpdateManyWithoutCompanyNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutCompanyNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutCompanyNestedInput
    User?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type AddressUpsertWithoutCompany_DetailsInput = {
    update: XOR<AddressUpdateWithoutCompany_DetailsInput, AddressUncheckedUpdateWithoutCompany_DetailsInput>
    create: XOR<AddressCreateWithoutCompany_DetailsInput, AddressUncheckedCreateWithoutCompany_DetailsInput>
  }

  export type AddressUpdateWithoutCompany_DetailsInput = {
    addressID?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    Profile?: ProfileUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCompany_DetailsInput = {
    addressID?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    profileID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EndorsementCreateWithoutCommentInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    Company?: CompanyCreateNestedOneWithoutEndorsementInput
    User?: UserCreateNestedOneWithoutEndorsementInput
    Endorse?: EndorseCreateNestedManyWithoutEndorsementInput
    Applicant?: ApplicantCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementUncheckedCreateWithoutCommentInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    userID?: string | null
    companyID?: string | null
    Endorse?: EndorseUncheckedCreateNestedManyWithoutEndorsementInput
    Applicant?: ApplicantUncheckedCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementCreateOrConnectWithoutCommentInput = {
    where: EndorsementWhereUniqueInput
    create: XOR<EndorsementCreateWithoutCommentInput, EndorsementUncheckedCreateWithoutCommentInput>
  }

  export type UserCreateWithoutCommentInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutUserInput
    Endorse?: EndorseCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementCreateNestedManyWithoutUserInput
    Feedback?: FeedbackCreateNestedOneWithoutUserInput
    interviewer?: InterviewerCreateNestedManyWithoutUserInput
    JobPost?: JobPostCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedOneWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    Endorse?: EndorseUncheckedCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutUserInput
    Feedback?: FeedbackUncheckedCreateNestedOneWithoutUserInput
    interviewer?: InterviewerUncheckedCreateNestedManyWithoutUserInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type EndorsementUpsertWithoutCommentInput = {
    update: XOR<EndorsementUpdateWithoutCommentInput, EndorsementUncheckedUpdateWithoutCommentInput>
    create: XOR<EndorsementCreateWithoutCommentInput, EndorsementUncheckedCreateWithoutCommentInput>
  }

  export type EndorsementUpdateWithoutCommentInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneWithoutEndorsementNestedInput
    User?: UserUpdateOneWithoutEndorsementNestedInput
    Endorse?: EndorseUpdateManyWithoutEndorsementNestedInput
    Applicant?: ApplicantUpdateManyWithoutEndorsementNestedInput
  }

  export type EndorsementUncheckedUpdateWithoutCommentInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
    Endorse?: EndorseUncheckedUpdateManyWithoutEndorsementNestedInput
    Applicant?: ApplicantUncheckedUpdateManyWithoutEndorsementNestedInput
  }

  export type UserUpsertWithoutCommentInput = {
    update: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type UserUpdateWithoutCommentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutUserNestedInput
    Endorse?: EndorseUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateOneWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    Endorse?: EndorseUncheckedUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUncheckedUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUncheckedUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyCreateWithoutEndorsementInput = {
    companyID?: string
    companyName: string
    details?: CompanyDetailsCreateNestedOneWithoutCompanyInput
    createdAt?: Date | string | null
    Endorse?: EndorseCreateNestedManyWithoutCompanyInput
    jobPost?: JobPostCreateNestedManyWithoutCompanyInput
    User?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutEndorsementInput = {
    companyID?: string
    companyName: string
    details?: CompanyDetailsUncheckedCreateNestedOneWithoutCompanyInput
    createdAt?: Date | string | null
    Endorse?: EndorseUncheckedCreateNestedManyWithoutCompanyInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutCompanyInput
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutEndorsementInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutEndorsementInput, CompanyUncheckedCreateWithoutEndorsementInput>
  }

  export type UserCreateWithoutEndorsementInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutUserInput
    Comment?: CommentCreateNestedOneWithoutUserInput
    Endorse?: EndorseCreateNestedManyWithoutUserInput
    Feedback?: FeedbackCreateNestedOneWithoutUserInput
    interviewer?: InterviewerCreateNestedManyWithoutUserInput
    JobPost?: JobPostCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedOneWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEndorsementInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    Comment?: CommentUncheckedCreateNestedOneWithoutUserInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutUserInput
    Feedback?: FeedbackUncheckedCreateNestedOneWithoutUserInput
    interviewer?: InterviewerUncheckedCreateNestedManyWithoutUserInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEndorsementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEndorsementInput, UserUncheckedCreateWithoutEndorsementInput>
  }

  export type CommentCreateWithoutEndorsementInput = {
    commentID?: string
    message: string
    notes: string
    createdAt: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutEndorsementInput = {
    commentID?: string
    message: string
    notes: string
    createdAt: Date | string
    updatedAt: Date | string
    userID?: string | null
  }

  export type CommentCreateOrConnectWithoutEndorsementInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutEndorsementInput, CommentUncheckedCreateWithoutEndorsementInput>
  }

  export type EndorseCreateWithoutEndorsementInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    createdAt: Date | string
    User: UserCreateNestedOneWithoutEndorseInput
    feedback?: FeedbackCreateNestedManyWithoutEndorseInput
    Company?: CompanyCreateNestedOneWithoutEndorseInput
  }

  export type EndorseUncheckedCreateWithoutEndorsementInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    userID: string
    createdAt: Date | string
    feedback?: FeedbackUncheckedCreateNestedManyWithoutEndorseInput
    companyID?: string | null
  }

  export type EndorseCreateOrConnectWithoutEndorsementInput = {
    where: EndorseWhereUniqueInput
    create: XOR<EndorseCreateWithoutEndorsementInput, EndorseUncheckedCreateWithoutEndorsementInput>
  }

  export type ApplicantCreateWithoutEndorsementInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    interviewer?: InterviewerCreateNestedOneWithoutApplicantInput
    JobPost: JobPostCreateNestedOneWithoutApplicantsInput
    Profile?: ProfileCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileCreateNestedOneWithoutApplicantInput
    Notification?: NotificationCreateNestedOneWithoutApplicantInput
    Feedback?: FeedbackCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutEndorsementInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    jobPostID: string
    interviewerID?: string | null
    Profile?: ProfileUncheckedCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileUncheckedCreateNestedOneWithoutApplicantInput
    notificaitonID?: string | null
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutEndorsementInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutEndorsementInput, ApplicantUncheckedCreateWithoutEndorsementInput>
  }

  export type ApplicantCreateManyEndorsementInputEnvelope = {
    data: Enumerable<ApplicantCreateManyEndorsementInput>
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutEndorsementInput = {
    update: XOR<CompanyUpdateWithoutEndorsementInput, CompanyUncheckedUpdateWithoutEndorsementInput>
    create: XOR<CompanyCreateWithoutEndorsementInput, CompanyUncheckedCreateWithoutEndorsementInput>
  }

  export type CompanyUpdateWithoutEndorsementInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    details?: CompanyDetailsUpdateOneWithoutCompanyNestedInput
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorse?: EndorseUpdateManyWithoutCompanyNestedInput
    jobPost?: JobPostUpdateManyWithoutCompanyNestedInput
    User?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutEndorsementInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    details?: CompanyDetailsUncheckedUpdateOneWithoutCompanyNestedInput
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorse?: EndorseUncheckedUpdateManyWithoutCompanyNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutCompanyNestedInput
    User?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutEndorsementInput = {
    update: XOR<UserUpdateWithoutEndorsementInput, UserUncheckedUpdateWithoutEndorsementInput>
    create: XOR<UserCreateWithoutEndorsementInput, UserUncheckedCreateWithoutEndorsementInput>
  }

  export type UserUpdateWithoutEndorsementInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutUserNestedInput
    Comment?: CommentUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateOneWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEndorsementInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    Comment?: CommentUncheckedUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUncheckedUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUncheckedUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithoutEndorsementInput = {
    update: XOR<CommentUpdateWithoutEndorsementInput, CommentUncheckedUpdateWithoutEndorsementInput>
    create: XOR<CommentCreateWithoutEndorsementInput, CommentUncheckedCreateWithoutEndorsementInput>
  }

  export type CommentUpdateWithoutEndorsementInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutEndorsementInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EndorseUpsertWithWhereUniqueWithoutEndorsementInput = {
    where: EndorseWhereUniqueInput
    update: XOR<EndorseUpdateWithoutEndorsementInput, EndorseUncheckedUpdateWithoutEndorsementInput>
    create: XOR<EndorseCreateWithoutEndorsementInput, EndorseUncheckedCreateWithoutEndorsementInput>
  }

  export type EndorseUpdateWithWhereUniqueWithoutEndorsementInput = {
    where: EndorseWhereUniqueInput
    data: XOR<EndorseUpdateWithoutEndorsementInput, EndorseUncheckedUpdateWithoutEndorsementInput>
  }

  export type EndorseUpdateManyWithWhereWithoutEndorsementInput = {
    where: EndorseScalarWhereInput
    data: XOR<EndorseUpdateManyMutationInput, EndorseUncheckedUpdateManyWithoutEndorseInput>
  }

  export type ApplicantUpsertWithWhereUniqueWithoutEndorsementInput = {
    where: ApplicantWhereUniqueInput
    update: XOR<ApplicantUpdateWithoutEndorsementInput, ApplicantUncheckedUpdateWithoutEndorsementInput>
    create: XOR<ApplicantCreateWithoutEndorsementInput, ApplicantUncheckedCreateWithoutEndorsementInput>
  }

  export type ApplicantUpdateWithWhereUniqueWithoutEndorsementInput = {
    where: ApplicantWhereUniqueInput
    data: XOR<ApplicantUpdateWithoutEndorsementInput, ApplicantUncheckedUpdateWithoutEndorsementInput>
  }

  export type ApplicantUpdateManyWithWhereWithoutEndorsementInput = {
    where: ApplicantScalarWhereInput
    data: XOR<ApplicantUpdateManyMutationInput, ApplicantUncheckedUpdateManyWithoutApplicantInput>
  }

  export type ApplicantScalarWhereInput = {
    AND?: Enumerable<ApplicantScalarWhereInput>
    OR?: Enumerable<ApplicantScalarWhereInput>
    NOT?: Enumerable<ApplicantScalarWhereInput>
    applicantID?: StringFilter | string
    id?: StringFilter | string
    email?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    status?: EnumapplicantStatusFilter | applicantStatus
    jobPostID?: StringFilter | string
    interviewerID?: StringNullableFilter | string | null
    endorsementID?: StringNullableFilter | string | null
    notificaitonID?: StringNullableFilter | string | null
  }

  export type UserCreateWithoutEndorseInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutUserInput
    Comment?: CommentCreateNestedOneWithoutUserInput
    Endorsement?: EndorsementCreateNestedManyWithoutUserInput
    Feedback?: FeedbackCreateNestedOneWithoutUserInput
    interviewer?: InterviewerCreateNestedManyWithoutUserInput
    JobPost?: JobPostCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedOneWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEndorseInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    Comment?: CommentUncheckedCreateNestedOneWithoutUserInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutUserInput
    Feedback?: FeedbackUncheckedCreateNestedOneWithoutUserInput
    interviewer?: InterviewerUncheckedCreateNestedManyWithoutUserInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEndorseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEndorseInput, UserUncheckedCreateWithoutEndorseInput>
  }

  export type FeedbackCreateWithoutEndorseInput = {
    feedbackID?: string
    feedback: string
    createdAt: Date | string
    Applicant?: ApplicantCreateNestedOneWithoutFeedbackInput
    User?: UserCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutEndorseInput = {
    feedbackID?: string
    feedback: string
    createdAt: Date | string
    userID?: string | null
    applicantID?: string | null
  }

  export type FeedbackCreateOrConnectWithoutEndorseInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutEndorseInput, FeedbackUncheckedCreateWithoutEndorseInput>
  }

  export type FeedbackCreateManyEndorseInputEnvelope = {
    data: Enumerable<FeedbackCreateManyEndorseInput>
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutEndorseInput = {
    companyID?: string
    companyName: string
    details?: CompanyDetailsCreateNestedOneWithoutCompanyInput
    createdAt?: Date | string | null
    Endorsement?: EndorsementCreateNestedManyWithoutCompanyInput
    jobPost?: JobPostCreateNestedManyWithoutCompanyInput
    User?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutEndorseInput = {
    companyID?: string
    companyName: string
    details?: CompanyDetailsUncheckedCreateNestedOneWithoutCompanyInput
    createdAt?: Date | string | null
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutCompanyInput
    jobPost?: JobPostUncheckedCreateNestedManyWithoutCompanyInput
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutEndorseInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutEndorseInput, CompanyUncheckedCreateWithoutEndorseInput>
  }

  export type EndorsementCreateWithoutEndorseInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    Company?: CompanyCreateNestedOneWithoutEndorsementInput
    User?: UserCreateNestedOneWithoutEndorsementInput
    Comment?: CommentCreateNestedOneWithoutEndorsementInput
    Applicant?: ApplicantCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementUncheckedCreateWithoutEndorseInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    userID?: string | null
    companyID?: string | null
    Comment?: CommentUncheckedCreateNestedOneWithoutEndorsementInput
    Applicant?: ApplicantUncheckedCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementCreateOrConnectWithoutEndorseInput = {
    where: EndorsementWhereUniqueInput
    create: XOR<EndorsementCreateWithoutEndorseInput, EndorsementUncheckedCreateWithoutEndorseInput>
  }

  export type UserUpsertWithoutEndorseInput = {
    update: XOR<UserUpdateWithoutEndorseInput, UserUncheckedUpdateWithoutEndorseInput>
    create: XOR<UserCreateWithoutEndorseInput, UserUncheckedCreateWithoutEndorseInput>
  }

  export type UserUpdateWithoutEndorseInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutUserNestedInput
    Comment?: CommentUpdateOneWithoutUserNestedInput
    Endorsement?: EndorsementUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateOneWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEndorseInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    Comment?: CommentUncheckedUpdateOneWithoutUserNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUncheckedUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUncheckedUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FeedbackUpsertWithWhereUniqueWithoutEndorseInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutEndorseInput, FeedbackUncheckedUpdateWithoutEndorseInput>
    create: XOR<FeedbackCreateWithoutEndorseInput, FeedbackUncheckedCreateWithoutEndorseInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutEndorseInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutEndorseInput, FeedbackUncheckedUpdateWithoutEndorseInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutEndorseInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutFeedbackInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: Enumerable<FeedbackScalarWhereInput>
    OR?: Enumerable<FeedbackScalarWhereInput>
    NOT?: Enumerable<FeedbackScalarWhereInput>
    feedbackID?: StringFilter | string
    feedback?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    endorseID?: StringNullableFilter | string | null
    userID?: StringNullableFilter | string | null
    applicantID?: StringNullableFilter | string | null
  }

  export type CompanyUpsertWithoutEndorseInput = {
    update: XOR<CompanyUpdateWithoutEndorseInput, CompanyUncheckedUpdateWithoutEndorseInput>
    create: XOR<CompanyCreateWithoutEndorseInput, CompanyUncheckedCreateWithoutEndorseInput>
  }

  export type CompanyUpdateWithoutEndorseInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    details?: CompanyDetailsUpdateOneWithoutCompanyNestedInput
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorsement?: EndorsementUpdateManyWithoutCompanyNestedInput
    jobPost?: JobPostUpdateManyWithoutCompanyNestedInput
    User?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutEndorseInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    details?: CompanyDetailsUncheckedUpdateOneWithoutCompanyNestedInput
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorsement?: EndorsementUncheckedUpdateManyWithoutCompanyNestedInput
    jobPost?: JobPostUncheckedUpdateManyWithoutCompanyNestedInput
    User?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EndorsementUpsertWithWhereUniqueWithoutEndorseInput = {
    where: EndorsementWhereUniqueInput
    update: XOR<EndorsementUpdateWithoutEndorseInput, EndorsementUncheckedUpdateWithoutEndorseInput>
    create: XOR<EndorsementCreateWithoutEndorseInput, EndorsementUncheckedCreateWithoutEndorseInput>
  }

  export type EndorsementUpdateWithWhereUniqueWithoutEndorseInput = {
    where: EndorsementWhereUniqueInput
    data: XOR<EndorsementUpdateWithoutEndorseInput, EndorsementUncheckedUpdateWithoutEndorseInput>
  }

  export type EndorsementUpdateManyWithWhereWithoutEndorseInput = {
    where: EndorsementScalarWhereInput
    data: XOR<EndorsementUpdateManyMutationInput, EndorsementUncheckedUpdateManyWithoutEndorsementInput>
  }

  export type ApplicantCreateWithoutFeedbackInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    interviewer?: InterviewerCreateNestedOneWithoutApplicantInput
    JobPost: JobPostCreateNestedOneWithoutApplicantsInput
    Endorsement?: EndorsementCreateNestedOneWithoutApplicantInput
    Profile?: ProfileCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileCreateNestedOneWithoutApplicantInput
    Notification?: NotificationCreateNestedOneWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutFeedbackInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    jobPostID: string
    interviewerID?: string | null
    endorsementID?: string | null
    Profile?: ProfileUncheckedCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileUncheckedCreateNestedOneWithoutApplicantInput
    notificaitonID?: string | null
  }

  export type ApplicantCreateOrConnectWithoutFeedbackInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutFeedbackInput, ApplicantUncheckedCreateWithoutFeedbackInput>
  }

  export type EndorseCreateWithoutFeedbackInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    createdAt: Date | string
    User: UserCreateNestedOneWithoutEndorseInput
    Company?: CompanyCreateNestedOneWithoutEndorseInput
    Endorsement?: EndorsementCreateNestedManyWithoutEndorseInput
  }

  export type EndorseUncheckedCreateWithoutFeedbackInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    userID: string
    createdAt: Date | string
    companyID?: string | null
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutEndorseInput
  }

  export type EndorseCreateOrConnectWithoutFeedbackInput = {
    where: EndorseWhereUniqueInput
    create: XOR<EndorseCreateWithoutFeedbackInput, EndorseUncheckedCreateWithoutFeedbackInput>
  }

  export type UserCreateWithoutFeedbackInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutUserInput
    Comment?: CommentCreateNestedOneWithoutUserInput
    Endorse?: EndorseCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementCreateNestedManyWithoutUserInput
    interviewer?: InterviewerCreateNestedManyWithoutUserInput
    JobPost?: JobPostCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedOneWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbackInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    Comment?: CommentUncheckedCreateNestedOneWithoutUserInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutUserInput
    interviewer?: InterviewerUncheckedCreateNestedManyWithoutUserInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbackInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
  }

  export type ApplicantUpsertWithoutFeedbackInput = {
    update: XOR<ApplicantUpdateWithoutFeedbackInput, ApplicantUncheckedUpdateWithoutFeedbackInput>
    create: XOR<ApplicantCreateWithoutFeedbackInput, ApplicantUncheckedCreateWithoutFeedbackInput>
  }

  export type ApplicantUpdateWithoutFeedbackInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    interviewer?: InterviewerUpdateOneWithoutApplicantNestedInput
    JobPost?: JobPostUpdateOneRequiredWithoutApplicantsNestedInput
    Endorsement?: EndorsementUpdateOneWithoutApplicantNestedInput
    Profile?: ProfileUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUpdateOneWithoutApplicantNestedInput
    Notification?: NotificationUpdateOneWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutFeedbackInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    jobPostID?: StringFieldUpdateOperationsInput | string
    interviewerID?: NullableStringFieldUpdateOperationsInput | string | null
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
    Profile?: ProfileUncheckedUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUncheckedUpdateOneWithoutApplicantNestedInput
    notificaitonID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EndorseUpsertWithoutFeedbackInput = {
    update: XOR<EndorseUpdateWithoutFeedbackInput, EndorseUncheckedUpdateWithoutFeedbackInput>
    create: XOR<EndorseCreateWithoutFeedbackInput, EndorseUncheckedCreateWithoutFeedbackInput>
  }

  export type EndorseUpdateWithoutFeedbackInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutEndorseNestedInput
    Company?: CompanyUpdateOneWithoutEndorseNestedInput
    Endorsement?: EndorsementUpdateManyWithoutEndorseNestedInput
  }

  export type EndorseUncheckedUpdateWithoutFeedbackInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
    Endorsement?: EndorsementUncheckedUpdateManyWithoutEndorseNestedInput
  }

  export type UserUpsertWithoutFeedbackInput = {
    update: XOR<UserUpdateWithoutFeedbackInput, UserUncheckedUpdateWithoutFeedbackInput>
    create: XOR<UserCreateWithoutFeedbackInput, UserUncheckedCreateWithoutFeedbackInput>
  }

  export type UserUpdateWithoutFeedbackInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutUserNestedInput
    Comment?: CommentUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUpdateManyWithoutUserNestedInput
    interviewer?: InterviewerUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateOneWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbackInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    Comment?: CommentUncheckedUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutUserNestedInput
    interviewer?: InterviewerUncheckedUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInterviewerInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutUserInput
    Comment?: CommentCreateNestedOneWithoutUserInput
    Endorse?: EndorseCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementCreateNestedManyWithoutUserInput
    Feedback?: FeedbackCreateNestedOneWithoutUserInput
    JobPost?: JobPostCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedOneWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInterviewerInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    Comment?: CommentUncheckedCreateNestedOneWithoutUserInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutUserInput
    Feedback?: FeedbackUncheckedCreateNestedOneWithoutUserInput
    JobPost?: JobPostUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInterviewerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterviewerInput, UserUncheckedCreateWithoutInterviewerInput>
  }

  export type ApplicantCreateWithoutInterviewerInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    JobPost: JobPostCreateNestedOneWithoutApplicantsInput
    Endorsement?: EndorsementCreateNestedOneWithoutApplicantInput
    Profile?: ProfileCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileCreateNestedOneWithoutApplicantInput
    Notification?: NotificationCreateNestedOneWithoutApplicantInput
    Feedback?: FeedbackCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutInterviewerInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    jobPostID: string
    endorsementID?: string | null
    Profile?: ProfileUncheckedCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileUncheckedCreateNestedOneWithoutApplicantInput
    notificaitonID?: string | null
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutInterviewerInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutInterviewerInput, ApplicantUncheckedCreateWithoutInterviewerInput>
  }

  export type UserUpsertWithoutInterviewerInput = {
    update: XOR<UserUpdateWithoutInterviewerInput, UserUncheckedUpdateWithoutInterviewerInput>
    create: XOR<UserCreateWithoutInterviewerInput, UserUncheckedCreateWithoutInterviewerInput>
  }

  export type UserUpdateWithoutInterviewerInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutUserNestedInput
    Comment?: CommentUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUpdateOneWithoutUserNestedInput
    JobPost?: JobPostUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateOneWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInterviewerInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    Comment?: CommentUncheckedUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUncheckedUpdateOneWithoutUserNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ApplicantUpsertWithoutInterviewerInput = {
    update: XOR<ApplicantUpdateWithoutInterviewerInput, ApplicantUncheckedUpdateWithoutInterviewerInput>
    create: XOR<ApplicantCreateWithoutInterviewerInput, ApplicantUncheckedCreateWithoutInterviewerInput>
  }

  export type ApplicantUpdateWithoutInterviewerInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    JobPost?: JobPostUpdateOneRequiredWithoutApplicantsNestedInput
    Endorsement?: EndorsementUpdateOneWithoutApplicantNestedInput
    Profile?: ProfileUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUpdateOneWithoutApplicantNestedInput
    Notification?: NotificationUpdateOneWithoutApplicantNestedInput
    Feedback?: FeedbackUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutInterviewerInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    jobPostID?: StringFieldUpdateOperationsInput | string
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
    Profile?: ProfileUncheckedUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUncheckedUpdateOneWithoutApplicantNestedInput
    notificaitonID?: NullableStringFieldUpdateOperationsInput | string | null
    Feedback?: FeedbackUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type InterviewerCreateWithoutApplicantInput = {
    interviewerID?: string
    createdAt: Date | string
    User: UserCreateNestedOneWithoutInterviewerInput
  }

  export type InterviewerUncheckedCreateWithoutApplicantInput = {
    interviewerID?: string
    createdAt: Date | string
    userID: string
  }

  export type InterviewerCreateOrConnectWithoutApplicantInput = {
    where: InterviewerWhereUniqueInput
    create: XOR<InterviewerCreateWithoutApplicantInput, InterviewerUncheckedCreateWithoutApplicantInput>
  }

  export type JobPostCreateWithoutApplicantsInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutJobPostInput
    Notification?: NotificationCreateNestedOneWithoutJobPostInput
    User: UserCreateNestedOneWithoutJobPostInput
    details?: JobDetailsCreateNestedOneWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutApplicantsInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    notificationID?: string | null
    userID: string
    details?: JobDetailsUncheckedCreateNestedOneWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutApplicantsInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutApplicantsInput, JobPostUncheckedCreateWithoutApplicantsInput>
  }

  export type EndorsementCreateWithoutApplicantInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    Company?: CompanyCreateNestedOneWithoutEndorsementInput
    User?: UserCreateNestedOneWithoutEndorsementInput
    Comment?: CommentCreateNestedOneWithoutEndorsementInput
    Endorse?: EndorseCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementUncheckedCreateWithoutApplicantInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    userID?: string | null
    companyID?: string | null
    Comment?: CommentUncheckedCreateNestedOneWithoutEndorsementInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutEndorsementInput
  }

  export type EndorsementCreateOrConnectWithoutApplicantInput = {
    where: EndorsementWhereUniqueInput
    create: XOR<EndorsementCreateWithoutApplicantInput, EndorsementUncheckedCreateWithoutApplicantInput>
  }

  export type ProfileCreateWithoutApplicantInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    birthday?: Date | string | null
    User?: UserCreateNestedOneWithoutProfileInput
    Address?: AddressCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutApplicantInput = {
    profileID?: string
    firstname: string
    lastname: string
    phone: string
    birthday?: Date | string | null
    userID?: string | null
    Address?: AddressUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutApplicantInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutApplicantInput, ProfileUncheckedCreateWithoutApplicantInput>
  }

  export type UploadFileCreateWithoutApplicantInput = {
    uploadFileID?: string
    file: string
    video: string
    createdAt: Date | string
  }

  export type UploadFileUncheckedCreateWithoutApplicantInput = {
    uploadFileID?: string
    file: string
    video: string
    createdAt: Date | string
  }

  export type UploadFileCreateOrConnectWithoutApplicantInput = {
    where: UploadFileWhereUniqueInput
    create: XOR<UploadFileCreateWithoutApplicantInput, UploadFileUncheckedCreateWithoutApplicantInput>
  }

  export type NotificationCreateWithoutApplicantInput = {
    notificationID?: string
    title: string
    notificationStatus?: notificationStatus
    createdAt: Date | string
    User?: UserCreateNestedOneWithoutNotificationInput
    JobPost?: JobPostCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutApplicantInput = {
    notificationID?: string
    title: string
    notificationStatus?: notificationStatus
    createdAt: Date | string
    userID?: string | null
    JobPost?: JobPostUncheckedCreateNestedOneWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutApplicantInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutApplicantInput, NotificationUncheckedCreateWithoutApplicantInput>
  }

  export type FeedbackCreateWithoutApplicantInput = {
    feedbackID?: string
    feedback: string
    createdAt: Date | string
    Endorse?: EndorseCreateNestedOneWithoutFeedbackInput
    User?: UserCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutApplicantInput = {
    feedbackID?: string
    feedback: string
    createdAt: Date | string
    endorseID?: string | null
    userID?: string | null
  }

  export type FeedbackCreateOrConnectWithoutApplicantInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutApplicantInput, FeedbackUncheckedCreateWithoutApplicantInput>
  }

  export type FeedbackCreateManyApplicantInputEnvelope = {
    data: Enumerable<FeedbackCreateManyApplicantInput>
    skipDuplicates?: boolean
  }

  export type InterviewerUpsertWithoutApplicantInput = {
    update: XOR<InterviewerUpdateWithoutApplicantInput, InterviewerUncheckedUpdateWithoutApplicantInput>
    create: XOR<InterviewerCreateWithoutApplicantInput, InterviewerUncheckedCreateWithoutApplicantInput>
  }

  export type InterviewerUpdateWithoutApplicantInput = {
    interviewerID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutInterviewerNestedInput
  }

  export type InterviewerUncheckedUpdateWithoutApplicantInput = {
    interviewerID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostUpsertWithoutApplicantsInput = {
    update: XOR<JobPostUpdateWithoutApplicantsInput, JobPostUncheckedUpdateWithoutApplicantsInput>
    create: XOR<JobPostCreateWithoutApplicantsInput, JobPostUncheckedCreateWithoutApplicantsInput>
  }

  export type JobPostUpdateWithoutApplicantsInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutJobPostNestedInput
    Notification?: NotificationUpdateOneWithoutJobPostNestedInput
    User?: UserUpdateOneRequiredWithoutJobPostNestedInput
    details?: JobDetailsUpdateOneWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutApplicantsInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    notificationID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: StringFieldUpdateOperationsInput | string
    details?: JobDetailsUncheckedUpdateOneWithoutJobPostNestedInput
  }

  export type EndorsementUpsertWithoutApplicantInput = {
    update: XOR<EndorsementUpdateWithoutApplicantInput, EndorsementUncheckedUpdateWithoutApplicantInput>
    create: XOR<EndorsementCreateWithoutApplicantInput, EndorsementUncheckedCreateWithoutApplicantInput>
  }

  export type EndorsementUpdateWithoutApplicantInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneWithoutEndorsementNestedInput
    User?: UserUpdateOneWithoutEndorsementNestedInput
    Comment?: CommentUpdateOneWithoutEndorsementNestedInput
    Endorse?: EndorseUpdateManyWithoutEndorsementNestedInput
  }

  export type EndorsementUncheckedUpdateWithoutApplicantInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUncheckedUpdateOneWithoutEndorsementNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutEndorsementNestedInput
  }

  export type ProfileUpsertWithoutApplicantInput = {
    update: XOR<ProfileUpdateWithoutApplicantInput, ProfileUncheckedUpdateWithoutApplicantInput>
    create: XOR<ProfileCreateWithoutApplicantInput, ProfileUncheckedCreateWithoutApplicantInput>
  }

  export type ProfileUpdateWithoutApplicantInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneWithoutProfileNestedInput
    Address?: AddressUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutApplicantInput = {
    profileID?: StringFieldUpdateOperationsInput | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: AddressUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UploadFileUpsertWithoutApplicantInput = {
    update: XOR<UploadFileUpdateWithoutApplicantInput, UploadFileUncheckedUpdateWithoutApplicantInput>
    create: XOR<UploadFileCreateWithoutApplicantInput, UploadFileUncheckedCreateWithoutApplicantInput>
  }

  export type UploadFileUpdateWithoutApplicantInput = {
    uploadFileID?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadFileUncheckedUpdateWithoutApplicantInput = {
    uploadFileID?: StringFieldUpdateOperationsInput | string
    file?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpsertWithoutApplicantInput = {
    update: XOR<NotificationUpdateWithoutApplicantInput, NotificationUncheckedUpdateWithoutApplicantInput>
    create: XOR<NotificationCreateWithoutApplicantInput, NotificationUncheckedCreateWithoutApplicantInput>
  }

  export type NotificationUpdateWithoutApplicantInput = {
    notificationID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notificationStatus?: EnumnotificationStatusFieldUpdateOperationsInput | notificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutNotificationNestedInput
    JobPost?: JobPostUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutApplicantInput = {
    notificationID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notificationStatus?: EnumnotificationStatusFieldUpdateOperationsInput | notificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    JobPost?: JobPostUncheckedUpdateOneWithoutNotificationNestedInput
  }

  export type FeedbackUpsertWithWhereUniqueWithoutApplicantInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutApplicantInput, FeedbackUncheckedUpdateWithoutApplicantInput>
    create: XOR<FeedbackCreateWithoutApplicantInput, FeedbackUncheckedCreateWithoutApplicantInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutApplicantInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutApplicantInput, FeedbackUncheckedUpdateWithoutApplicantInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutApplicantInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutFeedbackInput>
  }

  export type ApplicantCreateWithoutFileUploadInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    interviewer?: InterviewerCreateNestedOneWithoutApplicantInput
    JobPost: JobPostCreateNestedOneWithoutApplicantsInput
    Endorsement?: EndorsementCreateNestedOneWithoutApplicantInput
    Profile?: ProfileCreateNestedOneWithoutApplicantInput
    Notification?: NotificationCreateNestedOneWithoutApplicantInput
    Feedback?: FeedbackCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutFileUploadInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    jobPostID: string
    interviewerID?: string | null
    endorsementID?: string | null
    Profile?: ProfileUncheckedCreateNestedOneWithoutApplicantInput
    notificaitonID?: string | null
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutFileUploadInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutFileUploadInput, ApplicantUncheckedCreateWithoutFileUploadInput>
  }

  export type ApplicantUpsertWithoutFileUploadInput = {
    update: XOR<ApplicantUpdateWithoutFileUploadInput, ApplicantUncheckedUpdateWithoutFileUploadInput>
    create: XOR<ApplicantCreateWithoutFileUploadInput, ApplicantUncheckedCreateWithoutFileUploadInput>
  }

  export type ApplicantUpdateWithoutFileUploadInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    interviewer?: InterviewerUpdateOneWithoutApplicantNestedInput
    JobPost?: JobPostUpdateOneRequiredWithoutApplicantsNestedInput
    Endorsement?: EndorsementUpdateOneWithoutApplicantNestedInput
    Profile?: ProfileUpdateOneWithoutApplicantNestedInput
    Notification?: NotificationUpdateOneWithoutApplicantNestedInput
    Feedback?: FeedbackUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutFileUploadInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    jobPostID?: StringFieldUpdateOperationsInput | string
    interviewerID?: NullableStringFieldUpdateOperationsInput | string | null
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
    Profile?: ProfileUncheckedUpdateOneWithoutApplicantNestedInput
    notificaitonID?: NullableStringFieldUpdateOperationsInput | string | null
    Feedback?: FeedbackUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type CompanyCreateWithoutJobPostInput = {
    companyID?: string
    companyName: string
    details?: CompanyDetailsCreateNestedOneWithoutCompanyInput
    createdAt?: Date | string | null
    Endorse?: EndorseCreateNestedManyWithoutCompanyInput
    Endorsement?: EndorsementCreateNestedManyWithoutCompanyInput
    User?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutJobPostInput = {
    companyID?: string
    companyName: string
    details?: CompanyDetailsUncheckedCreateNestedOneWithoutCompanyInput
    createdAt?: Date | string | null
    Endorse?: EndorseUncheckedCreateNestedManyWithoutCompanyInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutCompanyInput
    User?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutJobPostInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutJobPostInput, CompanyUncheckedCreateWithoutJobPostInput>
  }

  export type NotificationCreateWithoutJobPostInput = {
    notificationID?: string
    title: string
    notificationStatus?: notificationStatus
    createdAt: Date | string
    User?: UserCreateNestedOneWithoutNotificationInput
    Applicant?: ApplicantCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutJobPostInput = {
    notificationID?: string
    title: string
    notificationStatus?: notificationStatus
    createdAt: Date | string
    userID?: string | null
    Applicant?: ApplicantUncheckedCreateNestedOneWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutJobPostInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutJobPostInput, NotificationUncheckedCreateWithoutJobPostInput>
  }

  export type UserCreateWithoutJobPostInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutUserInput
    Comment?: CommentCreateNestedOneWithoutUserInput
    Endorse?: EndorseCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementCreateNestedManyWithoutUserInput
    Feedback?: FeedbackCreateNestedOneWithoutUserInput
    interviewer?: InterviewerCreateNestedManyWithoutUserInput
    Notification?: NotificationCreateNestedManyWithoutUserInput
    Profile?: ProfileCreateNestedOneWithoutUserInput
    Logs?: LogsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJobPostInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    Comment?: CommentUncheckedCreateNestedOneWithoutUserInput
    Endorse?: EndorseUncheckedCreateNestedManyWithoutUserInput
    Endorsement?: EndorsementUncheckedCreateNestedManyWithoutUserInput
    Feedback?: FeedbackUncheckedCreateNestedOneWithoutUserInput
    interviewer?: InterviewerUncheckedCreateNestedManyWithoutUserInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutUserInput
    Profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    Logs?: LogsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJobPostInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobPostInput, UserUncheckedCreateWithoutJobPostInput>
  }

  export type ApplicantCreateWithoutJobPostInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    interviewer?: InterviewerCreateNestedOneWithoutApplicantInput
    Endorsement?: EndorsementCreateNestedOneWithoutApplicantInput
    Profile?: ProfileCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileCreateNestedOneWithoutApplicantInput
    Notification?: NotificationCreateNestedOneWithoutApplicantInput
    Feedback?: FeedbackCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantUncheckedCreateWithoutJobPostInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    interviewerID?: string | null
    endorsementID?: string | null
    Profile?: ProfileUncheckedCreateNestedOneWithoutApplicantInput
    FileUpload?: UploadFileUncheckedCreateNestedOneWithoutApplicantInput
    notificaitonID?: string | null
    Feedback?: FeedbackUncheckedCreateNestedManyWithoutApplicantInput
  }

  export type ApplicantCreateOrConnectWithoutJobPostInput = {
    where: ApplicantWhereUniqueInput
    create: XOR<ApplicantCreateWithoutJobPostInput, ApplicantUncheckedCreateWithoutJobPostInput>
  }

  export type ApplicantCreateManyJobPostInputEnvelope = {
    data: Enumerable<ApplicantCreateManyJobPostInput>
    skipDuplicates?: boolean
  }

  export type JobDetailsCreateWithoutJobPostInput = {
    jobDetailsID?: string
    location?: JobDetailsCreatelocationInput | Enumerable<string>
    jobType?: JobDetailsCreatejobTypeInput | Enumerable<string>
    workType?: JobDetailsCreateworkTypeInput | Enumerable<string>
    category: string
    salary: string
  }

  export type JobDetailsUncheckedCreateWithoutJobPostInput = {
    jobDetailsID?: string
    location?: JobDetailsCreatelocationInput | Enumerable<string>
    jobType?: JobDetailsCreatejobTypeInput | Enumerable<string>
    workType?: JobDetailsCreateworkTypeInput | Enumerable<string>
    category: string
    salary: string
  }

  export type JobDetailsCreateOrConnectWithoutJobPostInput = {
    where: JobDetailsWhereUniqueInput
    create: XOR<JobDetailsCreateWithoutJobPostInput, JobDetailsUncheckedCreateWithoutJobPostInput>
  }

  export type CompanyUpsertWithoutJobPostInput = {
    update: XOR<CompanyUpdateWithoutJobPostInput, CompanyUncheckedUpdateWithoutJobPostInput>
    create: XOR<CompanyCreateWithoutJobPostInput, CompanyUncheckedCreateWithoutJobPostInput>
  }

  export type CompanyUpdateWithoutJobPostInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    details?: CompanyDetailsUpdateOneWithoutCompanyNestedInput
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorse?: EndorseUpdateManyWithoutCompanyNestedInput
    Endorsement?: EndorsementUpdateManyWithoutCompanyNestedInput
    User?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutJobPostInput = {
    companyID?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    details?: CompanyDetailsUncheckedUpdateOneWithoutCompanyNestedInput
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Endorse?: EndorseUncheckedUpdateManyWithoutCompanyNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutCompanyNestedInput
    User?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type NotificationUpsertWithoutJobPostInput = {
    update: XOR<NotificationUpdateWithoutJobPostInput, NotificationUncheckedUpdateWithoutJobPostInput>
    create: XOR<NotificationCreateWithoutJobPostInput, NotificationUncheckedCreateWithoutJobPostInput>
  }

  export type NotificationUpdateWithoutJobPostInput = {
    notificationID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notificationStatus?: EnumnotificationStatusFieldUpdateOperationsInput | notificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutNotificationNestedInput
    Applicant?: ApplicantUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutJobPostInput = {
    notificationID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notificationStatus?: EnumnotificationStatusFieldUpdateOperationsInput | notificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    Applicant?: ApplicantUncheckedUpdateOneWithoutNotificationNestedInput
  }

  export type UserUpsertWithoutJobPostInput = {
    update: XOR<UserUpdateWithoutJobPostInput, UserUncheckedUpdateWithoutJobPostInput>
    create: XOR<UserCreateWithoutJobPostInput, UserUncheckedCreateWithoutJobPostInput>
  }

  export type UserUpdateWithoutJobPostInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutUserNestedInput
    Comment?: CommentUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateOneWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJobPostInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    Comment?: CommentUncheckedUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUncheckedUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ApplicantUpsertWithWhereUniqueWithoutJobPostInput = {
    where: ApplicantWhereUniqueInput
    update: XOR<ApplicantUpdateWithoutJobPostInput, ApplicantUncheckedUpdateWithoutJobPostInput>
    create: XOR<ApplicantCreateWithoutJobPostInput, ApplicantUncheckedCreateWithoutJobPostInput>
  }

  export type ApplicantUpdateWithWhereUniqueWithoutJobPostInput = {
    where: ApplicantWhereUniqueInput
    data: XOR<ApplicantUpdateWithoutJobPostInput, ApplicantUncheckedUpdateWithoutJobPostInput>
  }

  export type ApplicantUpdateManyWithWhereWithoutJobPostInput = {
    where: ApplicantScalarWhereInput
    data: XOR<ApplicantUpdateManyMutationInput, ApplicantUncheckedUpdateManyWithoutApplicantsInput>
  }

  export type JobDetailsUpsertWithoutJobPostInput = {
    update: XOR<JobDetailsUpdateWithoutJobPostInput, JobDetailsUncheckedUpdateWithoutJobPostInput>
    create: XOR<JobDetailsCreateWithoutJobPostInput, JobDetailsUncheckedCreateWithoutJobPostInput>
  }

  export type JobDetailsUpdateWithoutJobPostInput = {
    jobDetailsID?: StringFieldUpdateOperationsInput | string
    location?: JobDetailsUpdatelocationInput | Enumerable<string>
    jobType?: JobDetailsUpdatejobTypeInput | Enumerable<string>
    workType?: JobDetailsUpdateworkTypeInput | Enumerable<string>
    category?: StringFieldUpdateOperationsInput | string
    salary?: StringFieldUpdateOperationsInput | string
  }

  export type JobDetailsUncheckedUpdateWithoutJobPostInput = {
    jobDetailsID?: StringFieldUpdateOperationsInput | string
    location?: JobDetailsUpdatelocationInput | Enumerable<string>
    jobType?: JobDetailsUpdatejobTypeInput | Enumerable<string>
    workType?: JobDetailsUpdateworkTypeInput | Enumerable<string>
    category?: StringFieldUpdateOperationsInput | string
    salary?: StringFieldUpdateOperationsInput | string
  }

  export type JobPostCreateWithoutDetailsInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    Company: CompanyCreateNestedOneWithoutJobPostInput
    Notification?: NotificationCreateNestedOneWithoutJobPostInput
    User: UserCreateNestedOneWithoutJobPostInput
    Applicants?: ApplicantCreateNestedManyWithoutJobPostInput
  }

  export type JobPostUncheckedCreateWithoutDetailsInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    notificationID?: string | null
    userID: string
    Applicants?: ApplicantUncheckedCreateNestedManyWithoutJobPostInput
  }

  export type JobPostCreateOrConnectWithoutDetailsInput = {
    where: JobPostWhereUniqueInput
    create: XOR<JobPostCreateWithoutDetailsInput, JobPostUncheckedCreateWithoutDetailsInput>
  }

  export type JobPostUpsertWithoutDetailsInput = {
    update: XOR<JobPostUpdateWithoutDetailsInput, JobPostUncheckedUpdateWithoutDetailsInput>
    create: XOR<JobPostCreateWithoutDetailsInput, JobPostUncheckedCreateWithoutDetailsInput>
  }

  export type JobPostUpdateWithoutDetailsInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutJobPostNestedInput
    Notification?: NotificationUpdateOneWithoutJobPostNestedInput
    User?: UserUpdateOneRequiredWithoutJobPostNestedInput
    Applicants?: ApplicantUpdateManyWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutDetailsInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    notificationID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: StringFieldUpdateOperationsInput | string
    Applicants?: ApplicantUncheckedUpdateManyWithoutJobPostNestedInput
  }

  export type EndorseCreateManyUserInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    createdAt: Date | string
    companyID?: string | null
  }

  export type EndorsementCreateManyUserInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    companyID?: string | null
  }

  export type InterviewerCreateManyUserInput = {
    interviewerID?: string
    createdAt: Date | string
  }

  export type JobPostCreateManyUserInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    companyID: string
    notificationID?: string | null
  }

  export type NotificationCreateManyUserInput = {
    notificationID?: string
    title: string
    notificationStatus?: notificationStatus
    createdAt: Date | string
  }

  export type EndorseUpdateWithoutUserInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUpdateManyWithoutEndorseNestedInput
    Company?: CompanyUpdateOneWithoutEndorseNestedInput
    Endorsement?: EndorsementUpdateManyWithoutEndorseNestedInput
  }

  export type EndorseUncheckedUpdateWithoutUserInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateManyWithoutEndorseNestedInput
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
    Endorsement?: EndorsementUncheckedUpdateManyWithoutEndorseNestedInput
  }

  export type EndorseUncheckedUpdateManyWithoutEndorseInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EndorsementUpdateWithoutUserInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneWithoutEndorsementNestedInput
    Comment?: CommentUpdateOneWithoutEndorsementNestedInput
    Endorse?: EndorseUpdateManyWithoutEndorsementNestedInput
    Applicant?: ApplicantUpdateManyWithoutEndorsementNestedInput
  }

  export type EndorsementUncheckedUpdateWithoutUserInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUncheckedUpdateOneWithoutEndorsementNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutEndorsementNestedInput
    Applicant?: ApplicantUncheckedUpdateManyWithoutEndorsementNestedInput
  }

  export type EndorsementUncheckedUpdateManyWithoutEndorsementInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InterviewerUpdateWithoutUserInput = {
    interviewerID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Applicant?: ApplicantUpdateOneWithoutInterviewerNestedInput
  }

  export type InterviewerUncheckedUpdateWithoutUserInput = {
    interviewerID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Applicant?: ApplicantUncheckedUpdateOneWithoutInterviewerNestedInput
  }

  export type InterviewerUncheckedUpdateManyWithoutInterviewerInput = {
    interviewerID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobPostUpdateWithoutUserInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutJobPostNestedInput
    Notification?: NotificationUpdateOneWithoutJobPostNestedInput
    Applicants?: ApplicantUpdateManyWithoutJobPostNestedInput
    details?: JobDetailsUpdateOneWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutUserInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    notificationID?: NullableStringFieldUpdateOperationsInput | string | null
    Applicants?: ApplicantUncheckedUpdateManyWithoutJobPostNestedInput
    details?: JobDetailsUncheckedUpdateOneWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateManyWithoutJobPostInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    notificationID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    notificationID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notificationStatus?: EnumnotificationStatusFieldUpdateOperationsInput | notificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobPost?: JobPostUpdateOneWithoutNotificationNestedInput
    Applicant?: ApplicantUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    notificationID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notificationStatus?: EnumnotificationStatusFieldUpdateOperationsInput | notificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    JobPost?: JobPostUncheckedUpdateOneWithoutNotificationNestedInput
    Applicant?: ApplicantUncheckedUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateManyWithoutNotificationInput = {
    notificationID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notificationStatus?: EnumnotificationStatusFieldUpdateOperationsInput | notificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUpdateWithoutUserInput = {
    logsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    modifiedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUncheckedUpdateWithoutUserInput = {
    logsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    modifiedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogsUncheckedUpdateManyWithoutLogsInput = {
    logsID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    modifiedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutLogsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneRequiredWithoutUserNestedInput
    Comment?: CommentUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
    Comment?: CommentUncheckedUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUncheckedUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUncheckedUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyID?: StringFieldUpdateOperationsInput | string
  }

  export type EndorseCreateManyCompanyInput = {
    endorseID?: string
    endorseStatus?: endorseStatus
    userID: string
    createdAt: Date | string
  }

  export type EndorsementCreateManyCompanyInput = {
    endorsementID?: string
    Status: string
    createdAt: Date | string
    updatedAt: Date | string
    userID?: string | null
  }

  export type JobPostCreateManyCompanyInput = {
    jobPostID?: string
    title: string
    description: string
    qualification: string
    responsibilities: string
    status: JobStatus
    createdAt: Date | string
    updatedAt: Date | string
    notificationID?: string | null
    userID: string
  }

  export type UserCreateManyCompanyInput = {
    userID?: string
    email: string
    password: string
    role: Role
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type EndorseUpdateWithoutCompanyInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutEndorseNestedInput
    feedback?: FeedbackUpdateManyWithoutEndorseNestedInput
    Endorsement?: EndorsementUpdateManyWithoutEndorseNestedInput
  }

  export type EndorseUncheckedUpdateWithoutCompanyInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateManyWithoutEndorseNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutEndorseNestedInput
  }

  export type EndorsementUpdateWithoutCompanyInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutEndorsementNestedInput
    Comment?: CommentUpdateOneWithoutEndorsementNestedInput
    Endorse?: EndorseUpdateManyWithoutEndorsementNestedInput
    Applicant?: ApplicantUpdateManyWithoutEndorsementNestedInput
  }

  export type EndorsementUncheckedUpdateWithoutCompanyInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUncheckedUpdateOneWithoutEndorsementNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutEndorsementNestedInput
    Applicant?: ApplicantUncheckedUpdateManyWithoutEndorsementNestedInput
  }

  export type JobPostUpdateWithoutCompanyInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Notification?: NotificationUpdateOneWithoutJobPostNestedInput
    User?: UserUpdateOneRequiredWithoutJobPostNestedInput
    Applicants?: ApplicantUpdateManyWithoutJobPostNestedInput
    details?: JobDetailsUpdateOneWithoutJobPostNestedInput
  }

  export type JobPostUncheckedUpdateWithoutCompanyInput = {
    jobPostID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    qualification?: StringFieldUpdateOperationsInput | string
    responsibilities?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | JobStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notificationID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: StringFieldUpdateOperationsInput | string
    Applicants?: ApplicantUncheckedUpdateManyWithoutJobPostNestedInput
    details?: JobDetailsUncheckedUpdateOneWithoutJobPostNestedInput
  }

  export type UserUpdateWithoutCompanyInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUpdateManyWithoutUserNestedInput
    Notification?: NotificationUpdateManyWithoutUserNestedInput
    Profile?: ProfileUpdateOneWithoutUserNestedInput
    Logs?: LogsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    userID?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUncheckedUpdateOneWithoutUserNestedInput
    Endorse?: EndorseUncheckedUpdateManyWithoutUserNestedInput
    Endorsement?: EndorsementUncheckedUpdateManyWithoutUserNestedInput
    Feedback?: FeedbackUncheckedUpdateOneWithoutUserNestedInput
    interviewer?: InterviewerUncheckedUpdateManyWithoutUserNestedInput
    JobPost?: JobPostUncheckedUpdateManyWithoutUserNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    Profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    Logs?: LogsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ApplicantCreateManyEndorsementInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    jobPostID: string
    interviewerID?: string | null
    notificaitonID?: string | null
  }

  export type EndorseUpdateWithoutEndorsementInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutEndorseNestedInput
    feedback?: FeedbackUpdateManyWithoutEndorseNestedInput
    Company?: CompanyUpdateOneWithoutEndorseNestedInput
  }

  export type EndorseUncheckedUpdateWithoutEndorsementInput = {
    endorseID?: StringFieldUpdateOperationsInput | string
    endorseStatus?: EnumendorseStatusFieldUpdateOperationsInput | endorseStatus
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: FeedbackUncheckedUpdateManyWithoutEndorseNestedInput
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicantUpdateWithoutEndorsementInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    interviewer?: InterviewerUpdateOneWithoutApplicantNestedInput
    JobPost?: JobPostUpdateOneRequiredWithoutApplicantsNestedInput
    Profile?: ProfileUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUpdateOneWithoutApplicantNestedInput
    Notification?: NotificationUpdateOneWithoutApplicantNestedInput
    Feedback?: FeedbackUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutEndorsementInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    jobPostID?: StringFieldUpdateOperationsInput | string
    interviewerID?: NullableStringFieldUpdateOperationsInput | string | null
    Profile?: ProfileUncheckedUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUncheckedUpdateOneWithoutApplicantNestedInput
    notificaitonID?: NullableStringFieldUpdateOperationsInput | string | null
    Feedback?: FeedbackUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateManyWithoutApplicantInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    jobPostID?: StringFieldUpdateOperationsInput | string
    interviewerID?: NullableStringFieldUpdateOperationsInput | string | null
    notificaitonID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackCreateManyEndorseInput = {
    feedbackID?: string
    feedback: string
    createdAt: Date | string
    userID?: string | null
    applicantID?: string | null
  }

  export type FeedbackUpdateWithoutEndorseInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Applicant?: ApplicantUpdateOneWithoutFeedbackNestedInput
    User?: UserUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutEndorseInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    applicantID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackUncheckedUpdateManyWithoutFeedbackInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    applicantID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EndorsementUpdateWithoutEndorseInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Company?: CompanyUpdateOneWithoutEndorsementNestedInput
    User?: UserUpdateOneWithoutEndorsementNestedInput
    Comment?: CommentUpdateOneWithoutEndorsementNestedInput
    Applicant?: ApplicantUpdateManyWithoutEndorsementNestedInput
  }

  export type EndorsementUncheckedUpdateWithoutEndorseInput = {
    endorsementID?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    companyID?: NullableStringFieldUpdateOperationsInput | string | null
    Comment?: CommentUncheckedUpdateOneWithoutEndorsementNestedInput
    Applicant?: ApplicantUncheckedUpdateManyWithoutEndorsementNestedInput
  }

  export type FeedbackCreateManyApplicantInput = {
    feedbackID?: string
    feedback: string
    createdAt: Date | string
    endorseID?: string | null
    userID?: string | null
  }

  export type FeedbackUpdateWithoutApplicantInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Endorse?: EndorseUpdateOneWithoutFeedbackNestedInput
    User?: UserUpdateOneWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutApplicantInput = {
    feedbackID?: StringFieldUpdateOperationsInput | string
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endorseID?: NullableStringFieldUpdateOperationsInput | string | null
    userID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicantCreateManyJobPostInput = {
    applicantID?: string
    id: string
    email: string
    createdAt: Date | string
    updatedAt: Date | string
    status?: applicantStatus
    interviewerID?: string | null
    endorsementID?: string | null
    notificaitonID?: string | null
  }

  export type ApplicantUpdateWithoutJobPostInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    interviewer?: InterviewerUpdateOneWithoutApplicantNestedInput
    Endorsement?: EndorsementUpdateOneWithoutApplicantNestedInput
    Profile?: ProfileUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUpdateOneWithoutApplicantNestedInput
    Notification?: NotificationUpdateOneWithoutApplicantNestedInput
    Feedback?: FeedbackUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateWithoutJobPostInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    interviewerID?: NullableStringFieldUpdateOperationsInput | string | null
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
    Profile?: ProfileUncheckedUpdateOneWithoutApplicantNestedInput
    FileUpload?: UploadFileUncheckedUpdateOneWithoutApplicantNestedInput
    notificaitonID?: NullableStringFieldUpdateOperationsInput | string | null
    Feedback?: FeedbackUncheckedUpdateManyWithoutApplicantNestedInput
  }

  export type ApplicantUncheckedUpdateManyWithoutApplicantsInput = {
    applicantID?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumapplicantStatusFieldUpdateOperationsInput | applicantStatus
    interviewerID?: NullableStringFieldUpdateOperationsInput | string | null
    endorsementID?: NullableStringFieldUpdateOperationsInput | string | null
    notificaitonID?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}